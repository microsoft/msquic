<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>Using Streams </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="Using Streams ">
      
      <link rel="icon" href="../favicon.ico">
      <link rel="stylesheet" href="../public/docfx.min.css">
      <link rel="stylesheet" href="../public/main.css">
      <meta name="docfx:navrel" content="../toc.html">
      <meta name="docfx:tocrel" content="toc.html">
      
      <meta name="docfx:rel" content="../">
      
      
      <meta name="docfx:docurl" content="https://github.com/microsoft/msquic/blob/3833/merge/docs/Streams.md/#L1">
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
  </head>

  <script type="module">
    import options from './../public/main.js'
    import { init } from './../public/docfx.min.js'
    init(options)
  </script>

  <script>
    const theme = localStorage.getItem('theme') || 'auto'
    document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
  </script>


  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../index.html">
            <img id="logo" class="svg" src="../logo.svg" alt="">
            
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
              <form class="search" role="search" id="search">
                <i class="bi bi-search"></i>
                <input class="form-control" id="search-query" type="search" disabled="" placeholder="Search" autocomplete="off" aria-label="Search">
              </form>
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" style="margin-top: -.65em; margin-left: -.8em" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="">
<h1 id="using-streams">Using Streams</h1>

<p>Streams are the primary mechanism apps use to reliably exchange data with their peer. Streams can be opened by either peer (client or server) and can be unidirectional (can only send) or bidirectional (can send and receive). So, there are 4 types of streams:</p>
<ul>
<li>Client initiated, unidirectional stream</li>
<li>Server initiated, unidirectional stream</li>
<li>Client initiated, bidirectional stream</li>
<li>Server initiated, bidirectional stream</li>
</ul>
<h1 id="stream-id-flow-control">Stream ID Flow Control</h1>
<p>The QUIC protocol allows a maximum number of streams equal to 2 ^ 62. As there are 4 unique stream types, the maximum number of streams is 2 ^ 60, per stream type. No app would likely need to have this many streams open at any point.</p>
<p>For this reason, each app controls the number of streams that the peer is allowed to open. The concept is similar to flow control of the actual data on a stream. The app tells the peer how many streams it's willing to accept at any point. Instead of a buffer size, it's a stream count.</p>
<p>The protocol for synchronizing the maximum stream count is complicated, but MsQuic simplifies it by requiring the app to specify a number of simultaneous streams to allow the peer to open at any time. MsQuic then takes care of updating the maximum stream count for the peer as old streams get shut down.</p>
<p>The app can configure the unidirectional and bidirectional limits separately. <strong>The default value for these is 0.</strong> If the app wants to allow the peer to open any streams, it must set a value. To set the limit on a connection, the app must call <a href="api/SetParam.html">SetParam</a> for <code>QUIC_PARAM_CONN_PEER_BIDI_STREAM_COUNT</code> and/or <code>QUIC_PARAM_CONN_PEER_UNIDI_STREAM_COUNT</code>. MsQuic currently restricts this count to a maximum of 2 ^ 16.</p>
<h1 id="opening-and-starting-streams">Opening and Starting Streams</h1>
<p>An app calls <a href="api/StreamOpen.html">StreamOpen</a> to allocate a new stream. The stream object returned from <a href="api/StreamOpen.html">StreamOpen</a> is locally usable. The app can call any other stream API on the object, but until the stream is started all operations are essentially queued. While in this state the stream has no ID and generates no &quot;on-wire&quot; changes.</p>
<p>If a stream is closed (<a href="api/StreamClose.html">StreamClose</a>) before being successfully started, the app essentially abandons the stream. No on-wire changes will ever result from that stream.</p>
<p>To start using the stream on-wire, the app calls <a href="api/StreamStart.html">StreamStart</a>. On success, all queued operations (i.e. sends or shutdown) will immediately trigger, and the stream can start receiving <code>QUIC_STREAM_EVENT_RECEIVE</code> events.</p>
<p>When calling <a href="api/StreamStart.html">StreamStart</a> the app passes a set of <code>QUIC_STREAM_START_FLAGS</code> flags to control the behavior. Starting the stream <strong>always</strong> results in a <code>QUIC_STREAM_EVENT_START_COMPLETE</code> event, regardless of success/fail or synchronous/asynchronous flags.</p>
<p>For peer initiated streams, the app gets a <code>QUIC_CONNECTION_EVENT_PEER_STREAM_STARTED</code> event on the connection. A stream is officially started when this event or the <code>QUIC_STREAM_EVENT_START_COMPLETE</code> event is received.</p>
<h1 id="sending">Sending</h1>
<p>An app can send on any locally initiated stream or a peer initiated bidirectional stream. The app uses the <a href="api/StreamSend.html">StreamSend</a> API send data. MsQuic holds on to any buffers queued via <a href="api/StreamSend.html">StreamSend</a> until they have been completed via the <code>QUIC_STREAM_EVENT_SEND_COMPLETE</code> event.</p>
<h2 id="send-buffering">Send Buffering</h2>
<p>There are two buffering modes for sending supported by MsQuic. The first mode has MsQuic buffer the stream data internally. As long as there is room to buffer the data, MsQuic will copy the data locally and then immediately complete the send back to the app, via the <code>QUIC_STREAM_EVENT_SEND_COMPLETE</code> event. If there is no room to copy the data, then MsQuic will hold onto the buffer until there is room.</p>
<p>With this mode, the app can &quot;keep the pipe full&quot; using only a single outstanding send. It continually keeps a send pending on the stream. When the send is completed, the app immediately queues a send again with any new data it has.</p>
<p>This is seen by many as the simplest design for apps, but does introduce an additional copy in the data path, which has some performance draw backs. <strong>This is the default MsQuic behavior.</strong></p>
<p>The other buffering mode supported by MsQuic requires no internal copy of the data. MsQuic holds onto the app buffers until all the data has been acknowledged by the peer.</p>
<p>To fill the pipe in this mode, the app is responsible for keeping enough sends pending at all times to ensure the connection doesn't go idle. MsQuic indicates the amount of data the app should keep pending in the <code>QUIC_STREAM_EVENT_IDEAL_SEND_BUFFER_SIZE</code> event. The app should always have at least two sends pending at a time. If only a single send is used, the connection can go idle for the time between that send is completed and the new send is queued.</p>
<p>By default, this mode is not used. To enable this mode, the app must call <a href="api/SetParam.html">SetParam</a> on the connection with the <code>QUIC_PARAM_CONN_SEND_BUFFERING</code> parameter set to <code>FALSE</code>.</p>
<h2 id="send-shutdown">Send Shutdown</h2>
<p>The send direction can be shut down in three different ways:</p>
<ul>
<li><p><strong>Graceful</strong> - The sender can gracefully shut down the send direction by calling <a href="api/StreamShutdown.html">StreamShutdown</a> with the <code>QUIC_STREAM_SHUTDOWN_FLAG_GRACEFUL</code> flag or by including the <code>QUIC_SEND_FLAG_FIN</code> flag on the last <a href="api/StreamSend.html">StreamSend</a> call. In this scenario all data will be delivered to the peer and then the peer is informed the stream has been gracefully shut down.</p>
</li>
<li><p><strong>Sender Abort</strong> - The sender can abortively shut down the send direction by calling <a href="api/StreamShutdown.html">StreamShutdown</a> with the <code>QUIC_STREAM_SHUTDOWN_FLAG_ABORT_SEND</code> flag. In this scenario, all outstanding sends are immediately canceled and are not delivered to the peer. The peer is immediately informed of the abort.</p>
</li>
<li><p><strong>Receiver Abort</strong> - The receiver can abortively shut down their peer's send direction. When this happens the sender will get a <code>QUIC_STREAM_EVENT_PEER_RECEIVE_ABORTED</code> event.</p>
</li>
</ul>
<p>When the send has been completely shut down the app will get a <code>QUIC_STREAM_EVENT_SEND_SHUTDOWN_COMPLETE</code> event. This will happen immediately on an abortive send or after a graceful send has been acknowledged by the peer.</p>
<h2 id="0-rtt">0-RTT</h2>
<p>An app can opt in to sending stream data with 0-RTT keys (if available) by including the <code>QUIC_SEND_FLAG_ALLOW_0_RTT</code> flag on <a href="api/StreamSend.html">StreamSend</a> call. MsQuic doesn't make any guarantees that the data will actually be sent with 0-RTT keys. There are several reasons it may not happen, such as keys not being available, packet loss, flow control, etc.</p>
<h1 id="receiving">Receiving</h1>
<p>Data is received and delivered to apps via the <code>QUIC_STREAM_EVENT_RECEIVE</code> event. The event indicates zero, one or more contiguous buffers up to the application.</p>
<p>Typically, the buffer count is one, which means that most events will include a single buffer containing the received data.</p>
<p>When the buffer count is 0, it signifies the reception of a QUIC frame with empty data, which also indicates the end of stream data.</p>
<p>Currently, the maximum buffer count is 2 in the case of partial receive, where only a portion of the buffer data is consumed (as explained below). However, it is strongly advised not to assume in application code that the upper limit is always 2. This caution is important because future releases may incorporate multiple circular buffers to enhance performance, leading to potential changes in the buffer count limit.</p>
<p>The app then may respond to the event in a number of ways:</p>
<h2 id="synchronous-vs-asynchronous">Synchronous vs Asynchronous</h2>
<p>The app has the option of either processing the received data in the callback (synchronous) or queuing the work to a separate thread (asynchronous). If the app processes the data synchronously it must do so in a timely manner. Any significant delays will delay other QUIC processing (such as sending acknowledgements), which can cause protocol issues (dropped connections).</p>
<p>If the app wants to queue the data to a separate thread, the app must return <code>QUIC_STATUS_PENDING</code> from the receive callback. This informs MsQuic that the app still has an outstanding reference on the buffers, and it will not modify or free them. Once the app is done with the buffers it must call <a href="api/StreamReceiveComplete.html">StreamReceiveComplete</a>.</p>
<h2 id="partial-data-acceptance">Partial Data Acceptance</h2>
<p>Whenever the app gets the <code>QUIC_STREAM_EVENT_RECEIVE</code> event, it can partially accept/consume the received data.</p>
<p>For synchronous receives, the app indicates how much of the data it accepted via the <strong>TotalBufferLength</strong> variable in the payload of the <code>QUIC_STREAM_EVENT_RECEIVE</code> event. On input, that variable indicates the total amount of data being indicated. On output (return from the callback), the variable is taken as how much data the app consumed. By default, if the variable is left unmodified, then all data is assumed to be accepted.</p>
<p>For asynchronous receives, the app indicates how much of the data it accepted via the <strong>BufferLength</strong> parameter passed into the <a href="api/StreamReceiveComplete.html">StreamReceiveComplete</a> API.</p>
<p>Any value less than or equal to the initial <strong>TotalBufferLength</strong> value is allowed, including zero.</p>
<p>Whenever a receive isn't fully accepted by the app, additional receive events are immediately disabled. The app is assumed to be at capacity and not able to consume more until further indication. To re-enable receive callbacks, the app must call <a href="api/StreamReceiveSetEnabled.html">StreamReceiveSetEnabled</a>.</p>
<p>There are cases where an app may want to partially accept the current data, but still immediately get a callback with the rest of the data. To do this (only works in the synchronous flow) the app must return <code>QUIC_STATUS_CONTINUE</code>.</p>
</article>

        <div class="contribution d-print-none">
          <a href="https://github.com/microsoft/msquic/blob/3833/merge/docs/Streams.md/#L1" class="edit-link">Edit this page</a>
        </div>

        <div class="next-article d-print-none border-top" id="nextArticle"></div>
        
      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>

    <div class="container-xxl search-results" id="search-results"></div>

    <footer class="border-top">
      <div class="container-xxl">
        <div class="flex-fill">
          <span>Made with <a href="https://dotnet.github.io/docfx">docfx</a></span>
        </div>
      </div>
    </footer>
  </body>
</html>