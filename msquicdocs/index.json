{
  "README.html": {
    "href": "README.html",
    "title": "",
    "summary": "MsQuic is a Microsoft implementation of the IETF QUIC protocol. It is cross-platform, written in C and designed to be a general purpose QUIC library. MsQuic also has C++ API wrapper classes and exposes interop layers for both Rust and C#. Tip You are using MsQuic? Let us know! Knowing our users lets us prioritize work and keep improving MsQuic in the best possible direction. Post in the Discussion to say hello and give us a wave on Discord! Protocol Features QUIC has many benefits when compared to existing \"TLS over TCP\" scenarios: All packets are encrypted and handshake is authenticated with TLS 1.3. Parallel streams of (reliable and unreliable) application data. Exchange application data in the first round trip (0-RTT). Improved congestion control and loss recovery. Survives a change in the clients IP address or port. Stateless load balancing. Easily extendable for new features and extensions. Library Features MsQuic has several features that differentiates it from other QUIC implementations: Optimized for client and server. Optimized for maximal throughput and minimal latency. Asynchronous IO. Receive side scaling (RSS) support. UDP send and receive coalescing support. Kernel stack bypass via XDP. Documentation For platform support details, see the Platforms docs. For release details, see the Release docs. For performance data, see the Performance dashboard. For building the library, see the Build docs. For testing the library, see the Testing docs. For using the API, see the API docs or the Sample. For running a sample server and client app, see the Quick Start Guide. For deploying QUIC, see the Deployment docs. For diagnosing issues, see the Diagnostics docs and the Trouble Shooting Guide. For other frequently asked questions, see the FAQs. Contributing For information on contributing, please see our contribution guidelines. Feel free to take a look at our Good First Issues list if you're looking for somewhere to start. If you'd just like to talk, come chat with us on Discord."
  },
  "docs/API.html": {
    "href": "docs/API.html",
    "title": "MsQuic API",
    "summary": "MsQuic API The MsQuic API is written in C (like the rest of the libary) and is cross platform. It is also possible to invoke from any other language that supports calling C (such as C# or Rust). The primary API header can be found in the inc directory: msquic.h Terminology Term Definition app The application that is calling into MsQuic. client The app that initiates a connection. server The app that accepts a connection from a peer. handle A pointer to an MsQuic object. endpoint One side of a connection; client or server. peer The other side of a connection. callback handler The function pointer the app registers with an MsQuic object. app context or context A (possibly null) pointer registered with an MsQuic object. It is passed to the app's callback handlers. event Beginning or ending of a specific condition or action in the MsQuic library that results in the app's callback hander invocation. High Level Overview Object Model graph LR; App-->API; API-->Registration; Registration-->Configuration; Registration-->Listener; Registration-->Connection; Connection-->Stream; The API supports both server and client applications. All functionality is exposed primarily via a set of different objects: Api - The top level handle and function table for all other API calls. Registration – Manages the execution context for all child objects. An app may open multiple registrations but ideally should only open one. Configuration – Abstracts the configuration for a connection. This generally consists both of security related and common QUIC settings. Listener – Server side only, this object provides the interface for an app to accept incoming connections from clients. Once the connection has been accepted, it is independent of the listener. The app may create as many of these as necessary. Connection – Represents the actual QUIC connection state between the client and server. The app may create (and/or accept) as many of these as necessary. Stream – The layer at which application data is exchanged. Streams may be opened by either peer of a connection and may be unidirectional or bidirectional. For a single connection, as many streams as necessary may be created. (For more details on the inner design of MsQuic see: TLS) Versioning MsQuic API follows semantic versioning rules for updating the library version number (seen here). The MAJOR version must change when: The signature of an existing function changes. The position of any functions in the API function table changes. The behavior of an existing function changes that breaks existing clients. The MINOR version may change when: New values are added to existing flags or enums. New functions are added to the end of the API function table. The behavior of an existing function changes but can either be controlled via a flags field or doesn't break existing clients. The PATCH version only changes when a servicing fix is made to an existing release. Execution Mode MsQuic has a very different execution model than classic BSD-style sockets. Please see Execution for more details on how threads and upcalls are handled inside of MsQuic. Settings and Configuration MsQuic supports a variety of configuration options available to both application developers and administrators deploying MsQuic. See Settings for a detailed explanation of these settings and configuration options. API Objects Library Function Table There are only two top level functions: MsQuicOpenVersion - Initializes the MsQuic library and returns a the API function table. MsQuicClose - Cleans up the function table and releases the library reference from the previous MsQuicOpenVersion call. When the app is done with the MsQuic library, it must call MsQuicClose and pass in the function table it received from MsQuicOpenVersion. This allows for the library state to be cleaned up. Please note, there is no explicit start/stop API for this library. Each API function table has a reference on the QUIC library: the library is initialized when the first call to MsQuicOpenVersion succeeds and uninitialized when the last call to MsQuicClose completes. An app should therefore beware of repeatedly calling MsQuicOpenVersion and MsQuicClose, as library setup/cleanup can be expensive. Registration Generally, each app only needs a single registration. The registration represents the execution context where all logic for the app's connections run. The library will create a number of worker threads for each registration, shared for all the connections. This execution context is not shared between different registrations. A registration is created by calling RegistrationOpen and deleted by calling RegistrationClose or (Preview) RegistrationClose2. Configuration TODO A configuration is created by calling ConfigurationOpen and deleted by calling ConfigurationClose. Listener To create a QUIC server, a server must create a listener via ListenerOpen. This will return a new listener handle that is ready to start accepting incoming connections. Then, the server must call ListenerStart to get callbacks for new incoming connections. ListenerStart takes the network address and ALPNs the server wants to listener on. When a new connection is started by a client, the server will get a callback allowing it to accept the connection. This happens via the QUIC_LISTENER_EVENT_NEW_CONNECTION callback event, which contains all the currently known information in the QUIC_NEW_CONNECTION_INFO struct. The server then returns either a success or failure status to indicate if the connection was accepted or not. If the server accepts the connection, it now has ownership of the connection object. It must set the callback handler via SetCallbackHandler before the callback returns. Additionally, when it’s done with the connection, the app must call ConnectionClose on the connection to clean it up. For an accepted connection to actually continue with its handshake, the server must call ConnectionSetConfiguration to configure the necessary security (TLS) parameters. This may be called either on the callback (before it returns) or later on a different thread. When the server wishes to stop accepting new connections and stop further callbacks to the registered handler, it can call ListenerStop. This call is asynchronous, and may be called from any thread. The QUIC_LISTENER_EVENT_STOP_COMPLETE event will be delivered when the listener is stopped. The server may call ListenerStart again on the listener to start listening for incoming connections again. To clean up the listener object, the server calls ListenerClose. If the listener was not previously stopped, this function implicitly calls ListenerStop, so all the same restrictions to that call apply. Connection A connection handle represents a single QUIC connection and is generally the same thing on both client and server side. The main difference between client and server is just how the handle gets initially created. On client it is created explicitly by the app via a call to ConnectionOpen. On server it is created by the listener and delivered to the app via a callback to the registered QUIC_LISTENER_CALLBACK_HANDLER. Just like all objects in MsQuic, the connection requires the app to always be registered for event callbacks. After the client creates the new connection, it starts the process of connecting to a remote server by calling ConnectionStart. If the connection attempt succeeds, the connection event handler will be invoked for a QUIC_CONNECTION_EVENT_CONNECTED event; otherwise a QUIC_CONNECTION_EVENT_CLOSED event will be received. Once the app has a connection (either client or server) it can start opening streams and receiving events for remotely opened streams. Remotely opened streams are indicated to the callback handler via a QUIC_CONNECTION_EVENT_PEER_STREAM_STARTED event. The app is required to immediately call SetCallbackHandler to register a callback handler for the new stream. See Stream usage for more details on how stream are used. When the app is done with the connection, it can then call ConnectionShutdown to start the process of shutting down. This would cause the connection to immediately shutdown all open streams and send the shutdown indication to the peer over the network. When this process completes, the connection will invoke the event handler with a QUIC_CONNECTION_EVENT_SHUTDOWN_COMPLETE event. After this, the app would be free to call ConnectionClose to free up the connection resources. Stream Streams are the primary means of exchanging app data over a connection. Streams can be bidirectional or unidirectional. They can also be initiated/opened by either endpoint (Client or server). Each endpoint dictates exactly how many streams of each type (unidirectional or bidirectional) their peer can open at a given time. Finally, they can be shutdown by either endpoint, in either direction. A stream handle represents a single QUIC stream. It can be locally created by a call to StreamOpen or remotely created and then indicated to the app via the connection's callback handler via a QUIC_CONNECTION_EVENT_PEER_STREAM_STARTED event. Locally created streams must be started (via StreamStart) before they can send or receive data. Remote streams are already started when indicated to the app. Once the stream handle is available and started, the app can start receiving events on its callback handler (such as QUIC_STREAM_EVENT_RECEIVE) and start sending on the stream (via StreamSend). For more details see Using Streams. Datagrams MsQuic supports the unreliable datagram extension which allows for the app to send and receive unreliable (i.e. not retransmitted on packet loss) data securely. To enable support for receiving datagrams, the app must set DatagramReceiveEnabled to TRUE in its QUIC_SETTINGS. During the handshake, support for receiving datagrams is negotiated between endpoints. The app receives the QUIC_CONNECTION_EVENT_DATAGRAM_STATE_CHANGED event to indicate if the peer supports receiving datagrams (and what the current maximum size is). If the peer has enabled receiving datagrams, then an app may call DatagramSend. If/when the app receives a datagram from the peer it will receive a QUIC_CONNECTION_EVENT_DATAGRAM_RECEIVED event."
  },
  "docs/Architecture.html": {
    "href": "docs/Architecture.html",
    "title": "Architecture",
    "summary": "Architecture MsQuic has primarily two high-level layers: QUIC and the platform. The platform layer includes abstractions for TLS, UDP and OS stuff (like threads and locks). The QUIC layer is platform independent logic, built on the platform abstraction layers. Component Breakdown Platform Abstraction Layer The platform abstraction layer (or PAL) supports the following platforms: Windows (User and Kernel) Linux FreeBSD macOS Basic OS Interfaces The most fundamental part of the PAL is definitions of basic constructs like locks, events, interlocked operations, threads, and time. Most of these definitions are implemented inline in C macros. The goal is to minimize overhead and simply be a minimal abstraction for various interfaces. Datapath Another large piece of the PAL is the abstraction of UDP and TCP sockets, named the \"datapath\" layer. This layer is designed to be highly parallelized and performant. It uses asynchronous callbacks driven by the current execution model (see below) threads. Currently, it also has preview support of XDP on Windows. XDP datapath is used when XDP initialization succeeds XDP deps are installed XDP capable NIC is available Targetting to non-loopback address Crypto The PAL exposes various cryptographic interfaces as well, such has encryption/decryption and cryptographic hashing. This layer currently supports BCrypt and OpenSSL variants on Windows, and OpenSSL on Linux. TLS Related to Crypto, the TLS layer abstracts the necessary TLS functionality required by the QUIC protocol. This layer currently supports Schannel and OpenSSL variants on Windows, and OpenSSL on Linux. Platform Initialization The platform layer isn't completely stateless, and requires some setup and cleanup. This is split into two layers: Library Load This is when the library is loaded into memory, and does very minimal work, such as initializing some global state, and generally cannot fail. See CxPlatSystemLoad and CxPlatSystemUnload in the code for more details. Library Initialization This is when the library is first used by the upper layer(s). It does the rest of the work, especially the more intensive work that may fail under extreme circumstances (missing dependencies or OOM). See CxPlatInitialize and CxPlatUninitialize in the code for more details. QUIC The QUIC layer builds on the abstractions exposed by the PAL to implement platform-independent protocol logic of the QUIC protocol. TODO - Add details Execution Model The execution model refers to how and where work is scheduled and executed. TODO - Add details"
  },
  "docs/BUILD.html": {
    "href": "docs/BUILD.html",
    "title": "Building MsQuic",
    "summary": "Building MsQuic First, clone the repo recursively: git clone --recurse-submodules https://github.com/microsoft/msquic.git For existing repositories, run git submodule update --init --recursive to get all the submodules. Source Code The source (found in the src directory) is divided into several directories: bin - Packages up all static libraries into the platform specific binaries. core - Platform independent code that implements the QUIC protocol. inc - Header files used by all the other directories. manifest - Windows ETW manifest and related files. platform - Platform specific code for OS types, sockets and TLS. test - Test code for the MsQuic API / protocol. tools - Tools for exercising MsQuic. PowerShell Usage MsQuic uses several cross-platform PowerShell scripts to simplify build and test operations. The latest PowerShell will need to be installed for them to work. These scripts are the recommended way to build and test MsQuic, but they are not required. If you prefer to use CMake directly, please scroll down to the end of this page and start with the Building with CMake instructions. Install on Windows You can install the latest PowerShell on Windows by running the following PowerShell script or read the complete instructions here. iex \"& { $(irm https://aka.ms/install-powershell.ps1) } -UseMSI\" Then you will need to manually launch \"PowerShell 7\" to continue. This install does not replace the built-in version of PowerShell. Install on Linux You can find the full installation instructions for PowerShell on Linux here. For Ubuntu you can run the following: # Update the list of packages sudo apt-get update # Install pre-requisite packages. sudo apt-get install -y wget apt-transport-https software-properties-common # Get the version of Ubuntu source /etc/os-release # Download the Microsoft repository keys wget -q https://packages.microsoft.com/config/ubuntu/$VERSION_ID/packages-microsoft-prod.deb # Register the Microsoft repository keys sudo dpkg -i packages-microsoft-prod.deb # Delete the Microsoft repository keys file rm packages-microsoft-prod.deb # Update the list of packages after we added packages.microsoft.com sudo apt-get update ################################### # Install PowerShell sudo apt-get install -y powershell # Start PowerShell pwsh Note If you get this error trying to install PowerShell: powershell : Depends: libicu55 but it is not installable Then you will need to run the following first (as a workaround): sudo apt-get remove libicu57 wget http://security.ubuntu.com/ubuntu/pool/main/i/icu/libicu55_55.1-7ubuntu0.5_amd64.deb sudo dpkg -i libicu55_55.1-7ubuntu0.5_amd64.deb wget http://security.ubuntu.com/ubuntu/pool/main/o/openssl/libssl1.0.0_1.0.2g-1ubuntu4.18_amd64.deb sudo dpkg -i libssl1.0.0_1.0.2g-1ubuntu4.18_amd64.deb Then you will need to manually run \"pwsh\" to continue. Install on macOS brew install powershell Then you will need to manually run \"pwsh\" to continue. Building with PowerShell Install Dependencies In order to install the necessary dependencies, a copy of the .NET Core 3.1 SDK (or newer, such as .NET 9 SDK), is required. Go to the following location and find the install page for your platform. .NET Core After installing .NET [Core] SDK, you may need to restart your terminal. For the very first time you build, it's recommend to make sure you have all the dependencies installed. You can ensure this by running: ./scripts/prepare-machine.ps1 Note at minimum CMake 3.20 on windows and 3.16 on other platforms is required. Instructions for installing the newest version on Ubuntu can be found here. https://apt.kitware.com/. The prepare-machine script will not do this for you. Additional Requirements on Windows CMake (The version installed with Visual Studio will likely not be new enough) Strawberry Perl optional (required for OpenSSL build) Visual Studio 2019 or 2022 (or Build Tools for Visual Studio 2019/2022) with C++ CMake tools for Windows MSVC v142 - VS 2019 (or 2022) C++ (Arch) build tools Windows SDK version 10.0.26100.0 or newer Latest Windows Insider builds (required for SChannel build) Running a Build To build the code, you just need to run build.ps1 in the scripts folder: ./scripts/build.ps1 Note that schannel TLS provider requires the latest Windows versions (Windows Server 2022 or Insider Preview) to function. If you don't have schannel use openssl to build and test. ./scripts/build.ps1 -Tls openssl The script has a lot of additional configuration options, but the default should be fine for most. Config options -Config <Debug/Release> Allows for building in debug or release mode. Debug is the default configuration. -Arch <x86/x64/arm/arm64> Allow for building for different architectures. x64 is the defualt architecture. -Static Compiles msquic as a monolithic statically linkable library. Supported only by Windows currently. -Tls <schannel/openssl> Allows for building with different TLS providers. The default is platform dependent (Windows = schannel, Linux = openssl). -Clean Forces a clean build of everything. For more info, take a look at the build.ps1 script. Build Output By default the build output will go in the build folder and the final build binaries in the artifacts folder. Under that it will create per-platform folders with subfolders for architecture/tls combinations. This allows for building different platforms and configurations at the same time. Updating Clog Sidecar Some code changes such as adding/updating new MsQuic traces require updating the CLOG sidecar for successful Linux builds. This is done by running the following command: ./scripts/update-sidecar.ps1 This makes any necessary updates to the clog sidecar manifest and the generated files under src/generated/ folder. The modified files must be committed along with the rest of the code changes for addressing the Linux build failures. Building with CMake The following section details how to build MsQuic purely with CMake commands. Please note that since using CMake directly is not the recommended way of building MsQuic, it's likely that these instructions may fall out of date more often than the Building with PowerShell ones. Note that you will need to disable logging if building with CMake exclusively. Logging enabled requires .NET Core and at least the configuration from prepare-machine.ps1 in order to build. Note at minimum CMake 3.16 is required. Instructions for installing a the newest version on Ubuntu can be found here. https://apt.kitware.com/ Install Dependencies Linux The following are generally required. Actual installations may vary. sudo apt-add-repository ppa:lttng/stable-2.13 sudo apt-get update sudo apt-get install cmake sudo apt-get install build-essential sudo apt-get install liblttng-ust-dev sudo apt-get install lttng-tools On RHEL 8, you'll need to manually install CMake to get the latest version. Download the x86_64 Linux installation script from cmake.org, and run the following sudo sh cmake.sh --prefix=/usr/local/ --exclude-subdir to install CMake. RHEL 8 also requires the following: sudo dnf install openssl-devel sudo dnf install libatomic Linux XDP Linux XDP is experimentally supported on amd64 && Ubuntu 22.04LTS. Commands below install dependencies and setup runtime environment. WARN: This might break your system by installing Ubuntu 24.04LTS packages on ubuntu 22.04.Do not run on production environment and need to understand the side effect. You can workaround this prompt by -ForceXdpInstall $ pwsh ./scripts/prepare-machine.ps1 -UseXdp !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! WARN !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! Linux XDP installs dependencies from Ubuntu 24.04 packages, which should affect your environment You need to understand the impact of this on your environment before proceeding Type 'YES' to proceed: YES or $ pwsh ./scripts/prepare-machine.ps1 -UseXdp -ForceXdpInstall $ pwsh ./scripts/build.ps1 -UseXdp ./scripts/prepare-machine.ps1 internally does the below commands. This might break your environment. # for libxdp v1.4.2 on Ubuntu 22.04. Ubuntu 24.04 doesn't need this step sudo apt-add-repository \"deb http://mirrors.kernel.org/ubuntu noble main\" -y # install runtime dependencies sudo apt-get install -y libxdp1 libbpf1 libnl-3-200 libnl-route-3-200 libnl-genl-3-200 # install build dependencies sudo apt-get --no-install-recommends -y install libxdp-dev libbpf-dev libnl-3-dev libnl-genl-3-dev libnl-route-3-dev zlib1g-dev zlib1g pkg-config m4 clang libpcap-dev libelf-dev libc6-dev-i386 # Optional. This is required when you run test with duonic (XDP capable virtual nic pair) sudo apt-get -y install iproute2 iptables sudo ./scripts/duonic.sh install Test # \"sudo\" and --duoNic required # You can explicitly specify directory of datapath_raw_xdp_kern.o by MSQUIC_XDP_OBJECT_PATH # By default, libmsquic.so searchs for same directory as its executable # If something failed, fallback to normal socket sudo ./artifacts/bin/linux/x64_Debug_quictls/msquictest --duoNic Q&A Q: Is this workload really running on XDP? A: If you have the xdp-dump command, try using sudo xdp-dump --list-interfaces. The xdp_main function is located in src/platform/datapath_raw_xdp_linux_kern.c. If none of the interfaces load the XDP program, something must be wrong. $ sudo ./xdp-tools/xdp-dump/xdpdump --list-interfaces Interface Prio Program name Mode ID Tag Chain actions -------------------------------------------------------------------------------------- lo <No XDP program loaded!> eth0 <No XDP program loaded!> docker0 <No XDP program loaded!> duo2 xdp_dispatcher native 608211 4d7e87c0d30db711 => 50 xdp_main 608220 c8fcabdd9e3895f3 XDP_PASS duo1 xdp_dispatcher native 608225 4d7e87c0d30db711 => 50 xdp_main 608228 c8fcabdd9e3895f3 XDP_PASS Q: Is Ubuntu 20.04LTS supported? A: Not officially, but you can still build it by running apt-get upgrade linux-libc-dev. Please be aware of potential side effects from the upgrade. macOS The build needs CMake and compiler. brew install cmake Minimally, build needs Xcode 'Command Line Tools`. That can be done via XCode in App Store or from command line xcode-select --install Generating Build Files Windows Ensure the corresponding \"MSVC v142 - VS 2019 (or 2022) C++ (Arch) build tools\" are installed for the target arch, e.g. selecting \"Desktop development with C++\" only includes x64/x86 but not ARM64 by default. VS 2019 mkdir build && cd build cmake -G 'Visual Studio 16 2019' -A x64 .. VS 2022 mkdir build && cd build cmake -G 'Visual Studio 17 2022' -A x64 .. Linux mkdir build && cd build cmake -G 'Unix Makefiles' .. Running a Build cmake --build . Building for Rust Rust support is currently experimental, and not officially supported. To build MsQuic for Rust, you still must install the dependencies listed above for the various platforms. Then simply run: cargo build To run the tests: cargo test Installing from vcpkg You can download and install MsQuic using the vcpkg dependency manager: git clone https://github.com/Microsoft/vcpkg.git cd vcpkg ./bootstrap-vcpkg.sh #.\\bootstrap-vcpkg.bat(for windows) ./vcpkg integrate install ./vcpkg install ms-quic The MsQuic port in vcpkg is kept up to date by Microsoft team members and community contributors. If the version is out of date, please create an issue or pull request on the vcpkg repository. Build Automation MsQuic has several types and locations for build automation. GitHub The most comprehensive build automation is on GitHub and run via GitHub Action workflows (see here) on every PR and push to main. As of June 2025, over 200 different build configurations are run. These are meant to completely cover pretty much all build scenarios that are important to the project. These builds don't produce any official, signed artifacts. They are merely used for validation and then test (execution) purposes. Internal Microsoft then has official build pipelines that run internally (private) in secure build containers to produce the official binaries. These are then signed and eventually officially released. The main pipeline may be found here (MSFT-only access required). This pipeline automatically picks up all main branch, release branch and tags from the public repo and mirrors them internally. There is an older pipeline here, which has mostly been superceded by the pipeline above. Issue #4766 tracks the work to completely move things over. For instance, Linux package publishing still only functions in this older pipeline."
  },
  "docs/CredScan.html": {
    "href": "docs/CredScan.html",
    "title": "Suppressing CredScan Warnings",
    "summary": "Suppressing CredScan Warnings When updating the openssl submodule, new tests or code may get flagged by CredScan, and will need to be suppressed as it's 3rd party and we can't fix it. These are the steps to silence the warnings: Look at the sdl_sources results Click on 1 artifact produced and navigate to drop_sdl_sources/sdl_sources Download the .gdnsuppress file Copy the new warnings into openssl.gdnsuppress, sorting by the Target field Commit the changes and ingest into Windows. Note - You may also have to copy suppressions from other stages, similar to the process above. Regeneration from Scratch To regenerate the openssl.gdnsuppress completely, create a temporary mscodehub PR that removes the suppression: suppressionFile: from OneBranch.PullRequest.yml. Then follow the instructions above to get the new suppression file, but completely copy over the existing one instead. TODO - Perhaps we should automate the regeneration in a pipeline."
  },
  "docs/Deployment.html": {
    "href": "docs/Deployment.html",
    "title": "Deploying MsQuic",
    "summary": "Deploying MsQuic MsQuic is used as the basis for several different protocols (HTTP, SMB, etc.), but they all have several things in common when it comes time to deploy them. This document outlines the various things that must be taken into account whenever deploying an MsQuic based solution. Deploying QUIC Generally, for any existing TCP based deployments that are adding QUIC support, there are a number of things to be considered. Many things are different between a TCP based solution and a QUIC based one, including breaking some pretty \"core\" assumptions made for TCP: QUIC uses UDP instead of TCP. Any firewalls or other network devices must take this into account, and make sure this traffic is allowed. QUIC traffic is designed to be generally indistinguishable from other UDP traffic. Network devices must not assume UDP traffic on any port is QUIC unless explicitly configured. Current QUIC based protocols primarily use port 443 on the server, but not necessarily exclusively. HTTP and SMB use this port, but other protocols (e.g. DNS over QUIC) likely will not. QUIC is versioned and extensible, and thus is expected to be very dynamic on the network. Network devices must not assume anything about the structure of a QUIC packet beyond what is stated in the Invariants RFC. QUIC is completely encrypted end to end. Most information that might have been viewable on a TCP connection is now only visible to the endpoints. A single UDP flow or tuple (address + port) does not necessarily map to a single connection. A single QUIC connection may span multiple flows. Multiple QUIC connections may share a single flow. NAT bindings for UDP flows on the internet generally timeout much quicker than TCP; resulting in flow changes much more often. QUIC, as a protocol, is able to survive these changes, unlike TCP. For more details, please see the Manageability RFC. Configuration Please see Settings for information on MsQuic configuration. Windows On Windows, these settings can set via the registry and will persist across reboots and build upgrades. For most settings, a reboot is not required for them to immediately take effect. Also note that updated settings will only affect new connections (not existing ones). The main registry path for the keys is: HKLM:\\System\\CurrentControlSet\\Services\\MsQuic\\Parameters The settings can also be set per \"app-name\" (as indicated in RegistrationOpen): HKLM:\\System\\CurrentControlSet\\Services\\MsQuic\\Parameters\\app-name The DWORD type should be used for all 32-bit or less types. For 64-bit types, DWORD or QWORD may be used. If invalid types or values are used, they will be ignored and the built-in default will be used instead. For example, to set the Initial Window Size setting to 20 packets, you may do the following: reg.exe add \"HKLM\\System\\CurrentControlSet\\Services\\MsQuic\\Parameters\" /v InitialWindowPackets /t REG_DWORD /d 20 Cipher Suites Windows Important - ChaCha20-Poly1305 is not yet supported with MsQuic and Schannel, so this doesn't do anything yet. By default, the new cipher suite TLS_CHACHA20_POLY1305_SHA256 is disabled. It can be enabled via the following command: Enable-TlsCipherSuite -Name TLS_CHACHA20_POLY1305_SHA256 Firewall Windows In order to configure the Windows firewall to allow inbound QUIC traffic efficiently, use a command such as the one below. Generally, the firewall rule should be applied for all scenarios, unless a layer below you (e.g. IIS) is already doing it on your behalf. New-NetFirewallRule -DisplayName \"Allow QUIC\" -Direction Inbound -Protocol UDP -LocalPort 443 -Action Allow -LocalOnlyMapping $true Note the use of the -LocalOnlyMapping $true argument. This is a performance optimizing feature that should be used for UDP based protocols (like QUIC). See MSDN for additional details. Load Balancing MsQuic currently supports load balancing modes where the server encodes information into the \"Server ID\", bytes 1 through 4 of the connection IDs it creates. You can read more details about the general encoding in Load Balancers draft. 0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | First octet | Server ID (X=8..152) | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Any (0..152-X) | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ Server ID is 4 bytes long, and can encode various data interpretations. This encoding is not enabled by default. Please set the LoadBalancingMode setting accordingly to configure the desired load balancing mode. By default, . Note Any time the LoadBalancingMode is updated, the server must be restarted for this setting to take effect. IP Address Encoded Server ID MsQuic supports encoding the local IPv4 address or IPv6 suffix into Server ID. The load balancer can use this encoded IP address/suffix to directly route received QUIC packets to the appropriate server. To configure this mode, set the LoadBalancingMode setting to 1. Fixed Server ID MsQuic supports encoding a fixed, 4-byte value into Server ID. The load balancer can use this value to look up and route received QUIC packets to the appropriate server. To configure this mode, set the LoadBalancingMode setting to 2 and the FixedServerID setting to your desired value. Client Migration Client migration is a key feature in the QUIC protocol that allows for the connection to survive changes in the client's IP address or UDP port. MsQuic generally supports this but it requires QUIC load balancing support (when using a load balancer). QUIC encodes a connection identifier (connection ID or CID) in every packet it sends. This CID allows a server to encode routing information that a coordinating load balancer can use to route the packet, instead of using the IP tuple as most existing load balancers currently use to route UDP traffic. NAT Rebindings without Load Balancing Support If your deployment does not have QUIC load balancing support then you will not be able to make sure of the client migration feature described above to survive any NAT rebindings that change the client's IP tuple (from the server's perspective). This can be especially painful for any services migrating from a TCP based solution to QUIC, since most middleboxes on the internet have a much smaller timeout period for UDP (20 to 30 seconds) compared to TCP. This means any QUIC connection that goes idle for greater than ~20 seconds runs the risk of getting rebound by the NAT the next time the client sends a packet, resulting in a tuple change, and then likely resulting in the packet getting routed to the incorrect load balanced server. The mitigation to this problem is to enable QUIC keep alives. They can be enabled on either the client or server side, but only need to be enabled on one side. They can be enabled either dynamically in the code or globally via the settings. To enable keep alives via the settings, set the KeepAliveIntervalMs setting to a reasonable value, such as 20000 (20 seconds). DoS Mitigations MsQuic has a few built-in denial of service mitigations (server side). Stateless Retry MsQuic tracks the number of outstanding connections currently in the handshake state. When that reaches a certain threshold, MsQuic will start forcing clients to retry before the connection will be accepted. This entails the following: The server sends back a \"Stateless Retry\" packet with an encrypted token to the client. The server drops the incoming packet and doesn't save any state. The client must then reply back with its initial packet, this time including the encrypted token. The server validates the token, and only if successful, accept the connection. This protects the server from naive attackers trying to flood the server with new connection attempts; especially in scenarios where the client is spoofing its source IP address in an attempt to avoid attribution. The threshold mentioned above is currently tracked as a percentage of total avaialble (nonpaged pool) memory. This percentage of avaiable memory can be configured via the RetryMemoryFraction setting. Overloaded Worker Threads MsQuic uses worker threads internally to execute the QUIC protocol logic. For each worker thread, MsQuic tracks the average queue delay for any work done on one of these threads. This queue delay is simply the time from when the work is added to the queue to when the work is removed from the queue. If this delay hits a certain threshold, then existing connections can start to suffer (i.e. spurious packet loss, decreased throughput, or even connection failures). In order to prevent this, new connections are rejected with the SERVER_BUSY error, when this threshold is reached. The queue delay threshold can be configured via the MaxWorkerQueueDelayMs setting. Version Negotiation MsQuic supports QUIC protocol versions 1 and 2, and the version negotiation extension. By default, version negotiation is off, but can be enabled at runtime. Instructions for configuring and deploying QUIC versions are at Versions. Diagnostics For details on how to diagnose any issues with your deployment at the MsQuic layer see Diagnostics."
  },
  "docs/Development.html": {
    "href": "docs/Development.html",
    "title": "Developing MsQuic",
    "summary": "Developing MsQuic This document contains tips and tricks for configuring known editors to make MsQuic development easier. Configuring Visual Studio Code for MsQuic Using the VS Code C/C++ Tools extension (https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools) getting intellisense working for MsQuic is easy, but requires a small amount of configuration. The configuration UI can be started by going to the command palette (View -> Command Palette) and running C/C++: Edit Configurations (UI). This UI is a bit awkward to use, to set a field you have to click on another field. If you click out of the window it won't save. For User Mode (Windows, Linux or macOS), the following defines need to be added to the configuration. \"_DEBUG\", \"UNICODE\", \"_UNICODE\", \"QUIC_EVENTS_STUB\", \"QUIC_LOGS_STUB\" Additionally, cStandard and cppStandard need to be set to c17 and c++17 respectively. For Kernel Mode, create a new configuration with the Add Configuration button and call it Kernel. Add a Compiler argument /kernel to force kernel mode in the compiler. Add the following defines _DEBUG UNICODE _UNICODE QUIC_EVENTS_STUB QUIC_LOGS_STUB _AMD64_ _WIN32_WINNT=0x0A00 Set cStandard and cppStandard to c17 and c++17 respectively. Finally, you'll need to add the kernel mode header paths to Include path. On my system they're C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\km C:\\Program Files (x86)\\Windows Kits\\10\\Include\\wdf\\kmdf\\1.33 Depending on which WDK you have installed, the versions might change, but the relative folder paths should be similar. You will have to switch between configurations depending on if you want kernel mode or user mode context. To do this, while youre in a c or cpp file the status bar on the buttom right will have the configuration mode. For user it will be called Win32 and for kernel it will be called Kernel. To switch contexts, click the text, and you'll get a drop down to select other configurations. In the end, your c_cpp_properties.json file (in the .vscode folder) should look similar to the following. Some paths might be different, but they're trivially fixable. { \"configurations\": [ { \"name\": \"Win32\", \"includePath\": [ \"${workspaceFolder}/**\" ], \"defines\": [ \"_DEBUG\", \"UNICODE\", \"_UNICODE\", \"QUIC_EVENTS_STUB\", \"QUIC_LOGS_STUB\" ], \"windowsSdkVersion\": \"10.0.22000.0\", \"cStandard\": \"c17\", \"cppStandard\": \"c++17\", \"intelliSenseMode\": \"windows-msvc-x64\", \"compilerPath\": \"C:/Program Files/Microsoft Visual Studio/2022/Enterprise/VC/Tools/MSVC/14.30.30705/bin/Hostx64/x64/cl.exe\" }, { \"name\": \"Kernel\", \"includePath\": [ \"C:\\\\Program Files (x86)\\\\Windows Kits\\\\10\\\\Include\\\\10.0.22000.0\\\\km\", \"C:\\\\Program Files (x86)\\\\Windows Kits\\\\10\\\\Include\\\\wdf\\\\kmdf\\\\1.33\", \"${workspaceFolder}/**\" ], \"defines\": [ \"_DEBUG\", \"UNICODE\", \"_UNICODE\", \"QUIC_EVENTS_STUB\", \"QUIC_LOGS_STUB\", \"_AMD64_\", \"_WIN32_WINNT=0x0A00\" ], \"compilerPath\": \"C:/Program Files/Microsoft Visual Studio/2022/Enterprise/VC/Tools/MSVC/14.30.30705/bin/Hostx64/x64/cl.exe\", \"windowsSdkVersion\": \"10.0.22000.0\", \"cStandard\": \"c17\", \"cppStandard\": \"c++17\", \"intelliSenseMode\": \"windows-msvc-x64\", \"compilerArgs\": [ \"/kernel\" ] } ], \"version\": 4 }"
  },
  "docs/Diagnostics.html": {
    "href": "docs/Diagnostics.html",
    "title": "Diagnosing Issues with MsQuic",
    "summary": "Diagnosing Issues with MsQuic This document describes various ways to debug and diagnose issues when using MsQuic. Built-in Tracing For debugging issues, logging is generally the best way to diagnose problems. MsQuic has extensive logs in the code to facilitate debugging. The logs can simply be converted to human readable text or they can be processed by various automated tools to help improve diagnostics. Note Currently tools only support Windows ETW. Windows On Windows, MsQuic leverages manifested ETW for its logging. All dependencies should be included with Windows; nothing additional should be required. Linux stdout The easiest and quickest way to enable msquic logging is by compiling msquic with the following cmake arguments to direct the logs to standard output: cmake -D QUIC_ENABLE_LOGGING=ON -D QUIC_LOGGING_TYPE=stdout ... LTTng On Linux, MsQuic leverages LTTng for its logging. Some dependencies, such as babeltrace2 (or babeltrace), lttng, and clog2text_lttng are required. The simplest way to install all dependencies is by running ./scripts/prepare-machine.ps1 -ForTest, but if you only want to collect the traces on the machine, the minimal dependencies are: sudo apt-add-repository ppa:lttng/stable-2.13 sudo apt-get update sudo apt-get install -y lttng-tools Perf For general tracing, refer Stacks and CPU usage macOS Tracing is currently unsupported on macOS. Trace Collection Windows There are a lot of general tools and ways to collect and interact with ETW. In the sections below are our recommended ways to collect and consume the MsQuic ETW logs. MsQuicEtw.man specifies all the details for each event. For instance: <event keywords=\"ut:Connection ut:DataFlow\" level=\"win:Verbose\" message=\"$(string.Etw.ConnOutFlowStats)\" opcode=\"Connection\" symbol=\"QuicConnOutFlowStats\" template=\"tid_CONN_OUT_FLOW_STATS\" value=\"5140\" /> This details everything about the QuicConnOutFlowStats event (see ConnOutFlowStats in the code), including it's level (verbose) and it's keywords (ut:Connection and ut:DataFlow). So this event would be collected if the level is 5 or higher and either the ut:Connection or the ut:DataFlow keywords are configured. The numeric value for the keywords is at the top of the manifest file: <keyword mask=\"0x0000000000000020\" name=\"ut:Connection\" /> <keyword mask=\"0x0000000040000000\" name=\"ut:DataFlow\" /> netsh.exe netsh.exe (short for Net Shell, but generally pronounced \"net-s-h\") is an inbox Windows command line tool. It has many uses, but one of the most used is around tracing (at least for the networking community). To start collecting a trace with netsh, use the following command: netsh.exe trace start overwrite=yes report=dis correlation=dis traceFile=quic.etl provider={ff15e657-4f26-570e-88ab-0796b258d11c} level=0x5 keywords=0xffffffff There are a lot of parameters being passed and if you want the complete help text explaining them all you can run netsh.exe trace start help. A few of the important parameters are: traceFile - The name/path of the output ETL file that the logs will be saved to. provider - The GUID of the ETW provider that should be collected. In this case, {ff15e657-4f26-570e-88ab-0796b258d11c} is the GUID for the MsQuic provider. level - The level at which to collect traces. 5 indicates the verbose level. 4 is informational. keywords - The set of flags that indicate which type of events should be collected. The command above collects all keywords (0xffffffff) which may be too verbose for some scenarios, such as high throughput testing or large number of parallel connections. For a detailed list of the available keywords, see MsQuicEtw.man and see <keywords>. Once you are done with collecting all the events, to stop the trace session, use the following command: netsh.exe trace stop This will flush and finalize the output ETL file specified in the netsh trace start command. This ETL file can either be converted to text or used in the automated tools. wpr.exe wpr.exe is another inbox Windows command line tool that can be used to collect ETW traces, but it requires an additional \"profile\" file: MsQuic.wprp. This WPR profile file details several specifically tailored trace configurations. To use it, you must copy MsQuic.wprp to the machine you wish to collect the traces for, you can simply run the following to start trace collection: wpr.exe -start MsQuic.wprp!PROFILE -filemode You must replace PROFILE with the name of the profile you want to run. Some of the useful profiles are: Stacks.Light- Collects CPU callstacks. Stacks.Verbose- Collects CPU callstacks, DPCs and interrupts. Performance.Light - Collects performance related events useful for automated tool processing. Performance.Verbose - Collects Performance.Light plus CPU callstacks. Basic.Light - Collects general, \"low volume\" MsQuic events. Useful for a \"big picture\" understanding, with as few events collected as possible. Basic.Verbose - Collects all MsQuic events. This is very verbose. Scheduling.Verbose - Collects \"low volume\" and scheduling related MsQuic events. Datapath.Light - Collects \"low volume\" and datapath related MsQuic events. Datapath.Verbose - Collects Datapath.Light plus CPU callstacks. Full.Light - Collects all MsQuic events as well as TAEF events. For most, this will be equivalent to Basic.Verbose. Full.Verbose - Collects all MsQuic events, TAEF events and several networking components' events. This is the most verbose possible, and should only be used for the most minimal scenarios. When you're done and ready to collect the logs, you run: wpr.exe -stop ETL_PATH You must replace ETL_PATH with the path of the output ETL file that you want to be written. If you no longer need the logs being collected, you can cancel a trace instead of saving it to file: wpr.exe -cancel Other Ways As already indicated, there are lots of ways to collect ETW traces. Feel free to look at Configuring and Starting an Event Tracing Session for more information. Linux All in one command This script wraps collecting trace then converting to text as well WARN: This wrapper doesn't work with ./scripts/test.ps1 etc. as it is also creating lttng session internally. cd ${MSQUIC_PATH} ./scripts/log_wrapper.sh ${YOUR_COMMAND} # e.g. ./scripts/log_wrapper.sh ./artifacts/bin/linux/x64_Debug_openssl/msquictest --gtest_filter=Basic.* ls msquic_lttng0 # data quic.babel.txt quic.log Step by step command Instead, you can use the following commands: mkdir msquic_lttng lttng create msquic -o=./msquic_lttng lttng enable-event --userspace \"CLOG_*\" lttng add-context --userspace --type=vpid --type=vtid lttng start And to stop log the trace session, you can use the following command: lttng stop msquic Trace Conversion to Text Windows To convert an ETL file to human-readable text, you can use the following netsh.exe command: netsh.exe trace convert quic.etl overwrite=yes If you're using a version of MsQuic that uses an ETW manifest version more recent than the one built into the Windows image, decoding may not provide correct output. To solve this issue, newer versions of Windows (11 and Server 2022) support a manpath parameter that can be used to manually specify a manifest. This will likely always be needed for apps using MsQuic in user mode. netsh.exe trace convert quic.etl manpath=path/to/manifest/MsQuicEtw.man For older versions of Windows that don't support the manpath parameter, you can manually update the installed manifest that is used to decode the file. You can run the following wevtutil.exe commands in an Admin window: wevtutil.exe um path\\to\\MsQuicEtw.man wevtutil.exe im path\\to\\MsQuicEtw.man /rf:path\\to\\msquic.dll /mf:path\\to\\msquic.dll Replace path\\to with the actual paths to the respective files. With the latest manifests installed, now the normal netsh.exe convert command should work. Linux NOTE: msquic.lttng.so must be built to enable lttng logging - see https://lttng.org/docs/v2.13/#doc-liblttng-ust-dl and it must be placed in the same directory as the msquic.so. Building clog2text_lttng: cat > /etc/apt/preferences.d/99microsoft-dotnet.pref <<EOF Package: * Pin: origin \"packages.microsoft.com\" Pin-Priority: 1001 EOF apt update apt install --no-install-recommends -y dotnet-runtime-6.0 dotnet-sdk-6.0 dotnet-host git submodule update --init submodules/clog dotnet build submodules/clog/src/clog2text/clog2text_lttng/ -c Release Note if you see error \"A fatal error occurred. The folder [/usr/share/dotnet/host/fxr] does not exist\" follow steps in https://stackoverflow.com/questions/73753672/a-fatal-error-occurred-the-folder-usr-share-dotnet-host-fxr-does-not-exist To convert the trace, you can use the following commands: # Using babeltrace2 (preferred) babeltrace2 --names all ./msquic_lttng/* > quic.babel.txt # OR using babeltrace (fallback) babeltrace --names all ./msquic_lttng/* > quic.babel.txt ~/.dotnet/tools/clog2text_lttng -i quic.babel.txt -s clog.sidecar -o quic.log --showTimestamp --showCpuInfo Note The clog.sidecar file that was used to build MsQuic must be used. It can be found in the ./src/manifest directory of the repository. Trace Analysis MsQuic supports a custom plugin for Windows Performance Analyzer (WPA) to detailed analysis of ETW traces. See the WPA instructions for more details. Text Analysis Tool When viewing the traces as text, we recommend TextAnalysisTool.NET (Windows only) and we have several filter files we maintain for it (folder). The different filters are meant to quickly highlight and color code important information. You may also open the trace in Windows Performance Analyzer. See the WPA instructions for more details. Note WPA support for LTTng based logs is not yet available but will be supported in the future. Performance Counters To assist investigations into running systems, MsQuic has a number of performance counters that are updated during runtime. These counters are exposed as an array of unsigned 64-bit integers, via a global GetParam parameter. Sample code demonstrating how to query the performance counters: uint64_t Counters[QUIC_PERF_COUNTER_MAX]; uint32_t BufferLength = sizeof(Counters); MsQuic->GetParam( NULL, QUIC_PARAM_GLOBAL_PERF_COUNTERS, &BufferLength, Counters); Each of the counters available is described here: Counter | Description --------|------------ QUIC_PERF_COUNTER_CONN_CREATED | Total connections ever allocated QUIC_PERF_COUNTER_CONN_HANDSHAKE_FAIL | Total connections that failed during handshake QUIC_PERF_COUNTER_CONN_APP_REJECT | Total connections rejected by the application QUIC_PERF_COUNTER_CONN_RESUMED | Total connections resumed QUIC_PERF_COUNTER_CONN_ACTIVE | Connections currently allocated QUIC_PERF_COUNTER_CONN_CONNECTED | Connections currently in the connected state QUIC_PERF_COUNTER_CONN_PROTOCOL_ERRORS | Total connections shutdown with a protocol error QUIC_PERF_COUNTER_CONN_NO_ALPN | Total connection attempts with no matching ALPN QUIC_PERF_COUNTER_STRM_ACTIVE | Current streams allocated QUIC_PERF_COUNTER_PKTS_SUSPECTED_LOST | Total suspected packets lost QUIC_PERF_COUNTER_PKTS_DROPPED | Total packets dropped for any reason QUIC_PERF_COUNTER_PKTS_DECRYPTION_FAIL | Total packets with decryption failures QUIC_PERF_COUNTER_UDP_RECV | Total UDP datagrams received QUIC_PERF_COUNTER_UDP_SEND | Total UDP datagrams sent QUIC_PERF_COUNTER_UDP_RECV_BYTES | Total UDP payload bytes received QUIC_PERF_COUNTER_UDP_SEND_BYTES | Total UDP payload bytes sent QUIC_PERF_COUNTER_UDP_RECV_EVENTS | Total UDP receive events QUIC_PERF_COUNTER_UDP_SEND_CALLS | Total UDP send API calls QUIC_PERF_COUNTER_APP_SEND_BYTES | Total bytes sent by applications QUIC_PERF_COUNTER_APP_RECV_BYTES | Total bytes received by applications QUIC_PERF_COUNTER_CONN_QUEUE_DEPTH | Current connections queued for processing QUIC_PERF_COUNTER_CONN_OPER_QUEUE_DEPTH | Current connection operations queued QUIC_PERF_COUNTER_CONN_OPER_QUEUED | Total connection operations queued ever QUIC_PERF_COUNTER_CONN_OPER_COMPLETED | Total connection operations processed ever QUIC_PERF_COUNTER_WORK_OPER_QUEUE_DEPTH | Current worker operations queued QUIC_PERF_COUNTER_WORK_OPER_QUEUED | Total worker operations queued ever QUIC_PERF_COUNTER_WORK_OPER_COMPLETED | Total worker operations processed ever QUIC_PERF_COUNTER_PATH_VALIDATED | Total path challenges that succeed ever QUIC_PERF_COUNTER_PATH_FAILURE | Total path challenges that fail ever QUIC_PERF_COUNTER_SEND_STATELESS_RESET | Total stateless reset packets sent ever QUIC_PERF_COUNTER_SEND_STATELESS_RETRY | Total stateless retry packets sent ever QUIC_PERF_COUNTER_CONN_LOAD_REJECT | Total connections rejected due to worker load. QUIC_PERF_COUNTER_LISTEN_QUEUE_DEPTH | Current listeners queued for processing. Windows Performance Monitor On the latest version of Windows, these counters are also exposed via PerfMon.exe under the QUIC Performance Diagnostics category. The values exposed via PerfMon only represent kernel mode usages of MsQuic, and do not include user mode counters. ETW Counters are also captured at the beginning of MsQuic ETW traces, and unlike PerfMon, includes all MsQuic instances running on the system, both user and kernel mode. Network Troubleshooting To see what is being transmited on the wire you might use an open-source tool like Wireshark. The packets captured by such tool will be encrypted due to TLS, therefore we must provide the secrets to enable Wireshark to decrypt the packets. To enable this we must generate a SSLKEYLOGFILE with information about the secrets used in the TLS connection. With such file we will be able to decrypt the packets. For some browsers all you have to do is to set an environment variable SSLKEYLOGFILE with the absolute path of the log file to be generated and then you can load it into Wireshark for troubleshooting. For MsQuic applications we need to generate such file. A good practice is to check if the SSLKEYLOGFILE env variable is set and if so you write the file. The steps are: Set the QUIC_PARAM_CONN_TLS_SECRETS connection param with a struct to be populated with the TLS secrets by MsQuic. // Define empty struct for the TLS Secrets QUIC_TLS_SECRETS ClientSecrets{}; ... // Get the value of the env variable to log the secrets const char* SslKeyLogFile = getenv(\"SSLKEYLOGFILE\"); ... // If the variable is set then we have a file to write the TLS secrets thus we // pass the struct to be filled if (SslKeyLogFile != NULL) { MsQuic->SetParam(Connection, QUIC_PARAM_CONN_TLS_SECRETS, sizeof(ClientSecrets), &ClientSecrets); // Check for errors... } Write the file when the connection succeeds (event QUIC_CONNECTION_EVENT_CONNECTED). // On your connection callback function ... if (Event->Type == QUIC_CONNECTION_EVENT_CONNECTED) { if (SslKeyLogFile != NULL) { WriteSslKeyLogFile(SslKeyLogFile, ClientSecrets); } } Write the WriteSslKeyLogFile function. You can just copy the function from src/inc/msquichelper.h#WriteSslKeyLogFile if it serves your needs or write your own. Set the SSLKEYLOGFILE env variable set to the path of the log file and run the program. Then check the file with the secets. Load the key log into Wireshark and start capturing to decrypt the packets. To learn how to load such file inside Wireshark refer to this documentation: Using the (Pre)-Master-Secret. Using a Wireshark version that supports QUIC is not mandatory but could help when troubleshooting. To know which version supports QUIC refer to https://github.com/quicwg/base-drafts/wiki/Tools#wireshark. If you need a working example on how to generate the key log file please refer to the Sample at src/tools/sample/sample.c. Detailed Troubleshooting For detailed trouble shooting steps please see the MsQuic Trouble Shooting Guide."
  },
  "docs/Execution.html": {
    "href": "docs/Execution.html",
    "title": "Execution",
    "summary": "Execution The MsQuic API uses a different execution model compared to BSD-style sockets and most other networking libraries built on them. The sections below detail the designs MsQuic uses and the reasons behind these choices. Event Model MsQuic Object Model describes the hierarchy of MsQuic objects. The MsQuic API delivers all state changes and notifications for a specific MsQuic object directly to the corresponding callback handler registered by the application. These include connection state changes, new streams being created, stream data being received, and stream sends completing, among others. Example definition of Listener object callback API: typedef struct QUIC_LISTENER_EVENT { QUIC_LISTENER_EVENT_TYPE Type; union { struct { ... } NEW_CONNECTION; struct { ... } STOP_COMPLETE; ... }; } QUIC_LISTENER_EVENT; typedef _IRQL_requires_max_(PASSIVE_LEVEL) _Function_class_(QUIC_LISTENER_CALLBACK) QUIC_STATUS (QUIC_API QUIC_LISTENER_CALLBACK)( _In_ HQUIC Listener, _In_opt_ void* Context, _Inout_ QUIC_LISTENER_EVENT* Event ); The application must register a callback handler for every MsQuic object it creates, as well as for some objects automatically created by MsQuic (such as those created for Peer Initiated Streams or Server Connections). This handler must manage all the events MsQuic may indicate for that object. The handler must also return a status for each event indicating to MsQuic how the event was handled. This returned status is often success/failure, but sometimes indicates MsQuic that further processing is required. This handler must return QUIC_STATUS_SUCCESS for all events it currently does not handle (default case) to insulate the code from future additions to list of events for a specific object. This approach differs significantly from sockets and most networking libraries, where the application must make a call (e.g., send or recv) to determine if something happened. This design choice was made for several reasons: The MsQuic API runs in-process, eliminating the need for a kernel to user mode boundary switch to notify the application layer. This makes the callback-based design more practical compared to sockets. The various events defined in MsQuic are derived from the underlying QUIC protocol. Applications may have hundreds of objects with potential state changes. The callback model allows the application to avoid synchronization/call management on each object and focus on event handling for the object. Writing correct, scalable code in every application built on top of the socket interfaces is a repetetive, challenging task prone to errors. Offloading the threading and synchronization to MsQuic enables every application to be scalable with minimal effort, making things \"just work\" out of the box. Simplifies MsQuic logic by eliminating a queue/cached state to track yet-to-be-delivered application notifications/data. Such state is maintained in the socket model and the networking stack must wait for call(s) from the application before indicating completion. This represents reduced code, complexity and memory usage in the MsQuic library compared to the socket model. Writing Event Handlers Event handlers are required for all objects that can receive events, as much of the MsQuic API operates through these callbacks. Critical events, such as \"shutdown complete\" notifications, provide vital information necessary for the application to function correctly. Without these events, the application cannot determine when it is safe to clean up objects. Applications must keep the execution time within callbacks to a minimum. MsQuic does not use separate threads for protocol execution and upcalls to the application. Therefore, any significant delays in the callback will delay the protocol. Any substantial work required by the application must be performed on threads created by the application. This does not imply that the application needs separate threads to perform all of its work. Many operations are designed to be most efficient when executed within the callback. For example, closing a handle to a connection or stream is ideally done during the \"shutdown complete\" event notification callback. Some callbacks necessitate the application to call MsQuic API in return. Such cyclic call patterns could lead to deadlocks in a generic implementation, but not so in MsQuic. Special attention has been paid to ensure that MsQuic API (down) calls made from a callback thread always occur inline (thus avoiding deadlocks) and will take precedence over any calls in progress or queued from a separate thread. By default, MsQuic will never invoke a recursive callback to the application in these cases. The only exception to this rule is if the application opts in via the QUIC_STREAM_SHUTDOWN_FLAG_INLINE flag when calling StreamShudown on a callback. Threading MsQuic creates its own threads by default to manage the execution of its logic. The number and configuration of these threads depend on the settings passed to RegistrationOpen or QUIC_PARAM_GLOBAL_EXECUTION_CONFIG. MsQuic typically creates a dedicated worker thread for each processor, which are hard-affinitized to a specific NUMA node and soft-affinitized (set as 'ideal processor') to a specific processor. Each of these threads handle both the datapath (i.e., UDP) and QUIC layers by default. QUIC may be configured to run these layers on separate threads. Using a single worker thread for both layers helps MsQuic can achieve lower latency and using separate threads for the two layers can help achieve higher throughput. MsQuic aligns its processing logic with the rest of the networking stack (including hardware RSS) to ensure that all processing stays on the same NUMA node, and ideally, the same processor. The complexity of aligning processing across various threads and processors is the primary reason for MsQuic to manage its own threading. This provides developers with a performant abstraction of both functionality and threading model, which simplifies application development using MsQuic, ensuring that things \"just work\" efficiently for QUIC by default. Each thread manages the execution of one or more connections. Connections are distributed across threads based on their RSS alignment, which should evenly distribute traffic based on different UDP tuples. Each connection and its derived state (i.e., streams) are managed and executed by a single thread at a time, but may move across threads to align with any RSS changes. This ensures that each connection and its streams are effectively single-threaded, including all upcalls to the application layer. MsQuic will never make upcalls for a single connection or any of its streams in parallel. For listeners, the application callback will be called in parallel for new connections, allowing server applications to scale efficiently with the number of processors. graph TD subgraph Kernel NIC-Queue1[NIC Queue] NIC-Queue2[NIC Queue] NIC-Queue1 -->|RSS Receive| UDP1[IP/UDP] NIC-Queue2 -->|RSS Receive| UDP2[IP/UDP] end subgraph MsQuic Process UDP1 -.-> Processor1 UDP2 -.-> Processor2 subgraph Processor1[Processor 0] Thread1[Thread] Thread1 -->|Manages| Connection1[Connection 1] Thread1 -->|Manages| Connection2[Connection 2] Connection1 -->|Delivers Event| ApplicationCallback1[App Callback] Connection2 -->|Delivers Event| ApplicationCallback2[App Callback] end subgraph Processor2[Processor 1] Thread2[Thread] Thread2 -->|Manages| Connection3[Connection 3] Connection3 -->|Delivers Event| ApplicationCallback3[App Callback] end end Custom Execution MsQuic also supports scenarios where the application layer creates the threads that MsQuic uses to execute on. In this mode, the application creates one or more execution contexts that MsQuic will use to run all its internal logic. The application is responsible for calling down into MsQuic to allow these execution contexts to run. To create an execution context, the app much first create an event queue object, which is a platform specific type: Windows: IOCP Linux: epoll macOS: kqueue On Windows, the following types are defined: typedef HANDLE QUIC_EVENTQ; typedef OVERLAPPED_ENTRY CXPLAT_CQE; typedef _IRQL_requires_max_(PASSIVE_LEVEL) void (CXPLAT_EVENT_COMPLETION)( _In_ CXPLAT_CQE* Cqe ); typedef CXPLAT_EVENT_COMPLETION *CXPLAT_EVENT_COMPLETION_HANDLER; typedef struct CXPLAT_SQE { OVERLAPPED Overlapped; CXPLAT_EVENT_COMPLETION_HANDLER Completion; } CXPLAT_SQE; You will also notice the definiton for QUIC_SQE (SQE stands for submission queue entry), which defines the format that all completion events must take so they may be generically processed from the event queue (more on this below). Once the app has the event queue, it may create the execution context with the ExecutionCreate function: HANDLE IOCP = CreateIoCompletionPort(INVALID_HANDLE_VALUE, nullptr, 0, 1); QUIC_EXECUTION_CONFIG ExecConfig = { 0, &IOCP }; QUIC_EXECUTION* ExecContext = nullptr; QUIC_STATUS Status = MsQuic->ExecutionCreate(QUIC_GLOBAL_EXECUTION_CONFIG_FLAG_NONE, 0, 1, &ExecConfig, &ExecContext); The above code createa a new IOCP (for Windows), sets up an execution config, indicating an ideal processor of 0 and the pointer to the IOCP, and then calls MsQuic to create 1 execution context. An application may expand this code to create multiple execution contexts, depending on their needs. To drive this execution context, the app will need to to periodically call ExecutionPoll and use the platform specific function to drain completion events from the event queue. bool AllDone = false; while (!AllDone) { uint32_t WaitTime = MsQuic->ExecutionPoll(ExecContext); ULONG OverlappedCount = 0; OVERLAPPED_ENTRY Overlapped[8]; if (GetQueuedCompletionStatusEx(IOCP, Overlapped, ARRAYSIZE(Overlapped), &OverlappedCount, WaitTime, FALSE)) { for (ULONG i = 0; i < OverlappedCount; ++i) { QUIC_SQE* Sqe = CONTAINING_RECORD(Overlapped[i].lpOverlapped, QUIC_SQE, Overlapped); Sqe->Completion(&Overlapped[i]); } } } Above, you can see a simple loop that properly drives a single execution context on Windows. OVERLAPPED_ENTRY objects received from GetQueuedCompletionStatusEx are used to get the submission queue entry and then call its completion handler. In a real application, these completion events may come both from MsQuic and the application itself, therefore, this means the application must use the same base format for its own submission entries. This is necessary to be able to share the same event queue object. See Also QUIC_STREAM_CALLBACK QUIC_STREAM_EVENT QUIC_CONNECTION_CALLBACK QUIC_CONNECTION_EVENT QUIC_LISTENER_CALLBACK QUIC_LISTENER_EVENT"
  },
  "docs/FAQ.html": {
    "href": "docs/FAQ.html",
    "title": "Frequently Asked Questions",
    "summary": "Frequently Asked Questions Will the rest of Windows also go open source? At this time there is no plan to open source the rest of Windows. When is this shipping with Windows? The kernel mode version, msquic.sys, ships in Windows (Server 2022 and Windows 11). At this time, there is no plan to ship msquic.dll in Windows. For more details see our platform support documentation. Why isn’t there an HTTP/3 implementation along with MsQuic? MsQuic is designed as a generic QUIC transport for any application protocol. Several HTTP/3 stacks that use MsQuic exist, both internal to Windows (http.sys) and external (.NET Core). What platforms does MsQuic support? MsQuic currently supports Windows (including Xbox), Linux (including Android) and macOS (alpha) based platforms. Isn’t QUIC a Google product? QUIC was started by Google, but then was standardized by the IETF (see here). MsQuic is an implementation of that standard. Does this mean Microsoft will stop investing in TCP? TCP will continue to be used widely for a long time and we will continue to improve it as necessary. Why is MsQuic written in C? Windows Kernel mode is one of the supported platforms, and while it supports some C++ features, it does not support all of them. So, it was decided to use just pure C to reduce complexity. The MsQuic API is exposed/projected into several other languages, including C++, C# and Rust."
  },
  "docs/FIPS.html": {
    "href": "docs/FIPS.html",
    "title": "MsQuic and FIPS 140",
    "summary": "MsQuic and FIPS 140 FIPS 140 certification only applies to cryptographic primitives, and thus neither the TLS implementation, nor MsQuic, needs FIPS certification itself. This means that as long as the cryptographic library used by MsQuic's TLS layer is FIPS certified, MsQuic is compliant. Windows and FIPS 140 Information about the Microsoft Windows(tm) FIPS certification process can be found here. Linux and FIPS 140 On Linux, FIPS is more complicated. The system-provided libcrypto needs to be FIPS certified, and MsQuic needs to be built to use the system-provided libcrypto instead of staticly linking it into the MsQuic library. To accomplish this on Linux, MsQuic must be built using the following flags: pwsh ./build.ps1 -Tls OpenSSL -UseSystemOpenSSLCrypto After that, the system that MsQuic will run on must be configured to use FIPS. An incomplete list below is provided with steps for enabling FIPS mode on known Linux distributions. RHEL 8 Steps and documentation can be found here."
  },
  "docs/InteropServerSetup.html": {
    "href": "docs/InteropServerSetup.html",
    "title": "Setting Up an MsQuic Interop Server",
    "summary": "Setting Up an MsQuic Interop Server One of the tools in the MsQuic repo is quicinteropserver (source). It is our server solution used for QUIC interoperability testing. You can find the general requirements for this on the QUIC WG Wiki. Building The tool is automatically built with the rest of the repo. See complete build instructions here. There are a few additional things to note beyond the default build instructions. Currently, 0-RTT is only supported on Windows, when using the OpenSSL TLS library. To build for OpenSSL, you must use the -Tls openssl option when calling build.ps. If 0-RTT is not required/needed, then -Tls schannel should be fine to use on Windows, and -Tls openssl for Linux. Once built, you can find the quicinteropserver in (assuming PowerShell is used to build): ./artifacts/bin/{platform}/{arch}_{config}_{tls} For example, if you build with build.ps1 -Config Release -Tls openssl on Windows, the output would be in: ./artifacts/bin/windows/x64_release_openssl The directory contains all the build artifacts, including the base MsQuic library (msquic.dll or libmsquic.so). Deploying To deploy quicinteropserver both the base MsQuic library and the application binary itself will have to be copied to the server machine. If you run quicinteropserver without any arguments, you will get the default usage text. For instance: quicinteropserver is simple http 0.9/1.1 server. Usage: quicinteropserver -listen:<addr or *> -root:<path> [-thumbprint:<cert_thumbprint>] [-name:<cert_name>] [-file:<cert_filepath> AND -key:<cert_key_filepath>] [-port:<####> (def:4433)] [-retry:<0/1> (def:0)] [-upload:<path>] Examples: quicinteropserver -listen:127.0.0.1 -name:localhost -port:443 -root:c:\\temp quicinteropserver -listen:* -retry:1 -thumbprint:175342733b39d81c997817296c9b691172ca6b6e -root:c:\\temp Please see Deployment.md for additional deployment considerations. Windows Instructions The simplest and quickest way to set up the server on Windows is to use a self-signed certificate. The following PowerShell command can easily create one for you: New-SelfSignedCertificate -DnsName $env:computername,localhost,{DnsName} -FriendlyName QuicInteropServer -KeyUsageProperty Sign -KeyUsage DigitalSignature -CertStoreLocation cert:\\CurrentUser\\My -HashAlgorithm SHA256 -Provider \"Microsoft Software Key Storage Provider\" Make sure to replace {DnsName} with the actual public domain name of the server, if you have one. If not available, you may just omit the parameter all together. The PowerShell command will dump the new certificate's thumbprint/hash to the console. You can then use that to start the server. For example: quicinteropserver.exe -listen:* -port:4433 -thumbprint:{thumbprint} -root:{html_root_dir} Make sure to replace {thumbprint} with the thumbprint of the certificate and {html_root_dir} with the full path of directory containing the HTML files you which to serve. It's recommended to include an index.html at the very least in this directory. Also make sure to configure both any necessary firewalls to allow incoming UDP traffic on the configured port (4433 in the case above). The following PowerShell command can easily open up the port in the Windows firewall: New-NetFirewallRule -DisplayName \"QuicInteropServer\" -Direction Inbound -Protocol UDP -LocalPort 4433 -Action Allow Linux Instructions TO-DO Enabling Dump Collection It is a good idea to enable dump collection for any possible crashes, since this is only a test application, and not actual production quality. Windows Instructions You can easily configure WER (Windows Error Reporting) to collect dump files and save them locally, in the directory of you're choosing, via the following PowerShell registry commands: $OutputDir = \"C:\\dumps\" $WerDumpRegPath = \"HKLM:\\Software\\Microsoft\\Windows\\Windows Error Reporting\\LocalDumps\\quicinteropserver.exe\" if (!(Test-Path $WerDumpRegPath)) { New-Item -Path $WerDumpRegPath -Force | Out-Null } New-ItemProperty -Path $WerDumpRegPath -Name DumpType -PropertyType DWord -Value 2 -Force | Out-Null New-ItemProperty -Path $WerDumpRegPath -Name DumpFolder -PropertyType ExpandString -Value $OutputDir -Force | Out-Null Feel free to update $OutputDir to whatever local directory you wish. Linux Instructions The following commands (run as root) should configure core dumps to be created in the local directory: # Enable core dumps for the system. sudo sh -c \"echo 'root soft core unlimited' >> /etc/security/limits.conf\" sudo sh -c \"echo 'root hard core unlimited' >> /etc/security/limits.conf\" sudo sh -c \"echo '* soft core unlimited' >> /etc/security/limits.conf\" sudo sh -c \"echo '* hard core unlimited' >> /etc/security/limits.conf\" # Set the core dump pattern. sudo sh -c \"echo -n '%e.%p.%t.core' > /proc/sys/kernel/core_pattern\" The following are sudo basd run especially for using XDP # Increase the number of file descriptors. sudo sh -c \"echo 'root soft nofile 1048576' >> /etc/security/limits.conf\" sudo sh -c \"echo 'root hard nofile 1048576' >> /etc/security/limits.conf\" sudo sh -c \"echo '* soft nofile 1048576' >> /etc/security/limits.conf\" sudo sh -c \"echo '* hard nofile 1048576' >> /etc/security/limits.conf\""
  },
  "docs/PGO.html": {
    "href": "docs/PGO.html",
    "title": "Profile Guided Optimizations",
    "summary": "Profile Guided Optimizations MsQuic uses profile-guided optimizations (PGO) to generate optimized builds of the MsQuic library. PGO lets you optimize the whole library by using data from a previous run of the library. Note This document is Windows specific. Build During the build for x86 and x64 release builds (arm/arm64 are currently unsupported) a profile-guided database file (.pgd), generated from a previous run, is passed to the linker. The linker uses this data to optimize the new build. Build for Training > ./scripts/build.ps1 -Config Release -PGO By default, the library is not built in \"training mode\". To enable this, you must pass the -PGO switch to the build.ps1 PowerShell script. This configures the linker to configure the library so that it can be trained. Whenever the library unloads a .pgc file will be dumped to the local directory. This file can be used update the existing .pgd file. Training A fundamental part of profile-guided optimizations is training. The code is run through production scenarios while in \"training mode\" to generate a data set that can be used for a future build to optimize for the scenario. Build for training. Copy the binaries to the test machine(s). The PGO msquic library. The test tool (e.g. secnetperf). The PGO runtime library from your VS install: (e.g. \"C:\\Program Files (x86)\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.26.28801\\bin\\Hostx64\\x64\\pgort140.dll\"). Run the test for the production/performance scenario. Use pgomgr to merge the .pgc into the .pgd. Update the .pgd and .pdb files in the repository. Kernel mode Profile Guided Optimizations PGO for kernel mode is a much more manual process than user mode. These steps guide you through the process. Build To build for kernel PGO, copy pgortsys.lib locally and edit the msquicpriv.kernel.vcxproj file with the following patch: diff --git a/src/bin/winkernel/msquicpriv.kernel.vcxproj b/src/bin/winkernel/msquicpriv.kernel.vcxproj index 04d89207..b125cdd7 100644 --- a/src/bin/winkernel/msquicpriv.kernel.vcxproj +++ b/src/bin/winkernel/msquicpriv.kernel.vcxproj @@ -78,7 +78,7 @@ <ImportGroup Label=\"PropertySheets\"> <Import Project=\"$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props\" Condition=\"exists('$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props')\" Label=\"LocalAppDataPlatform\" /> </ImportGroup> - <PropertyGroup Label=\"UserMacros\" /> + <PropertyGroup><LibraryPath>$(LibraryPath);$(VC_LibraryPath_VC_x64_Desktop);c:\\path\\to\\directory\\containing\\pgortsys.lib\\</LibraryPath></PropertyGroup> <PropertyGroup> <QUIC_VER_BUILD_ID Condition=\"'$(QUIC_VER_BUILD_ID)' == ''\">0</QUIC_VER_BUILD_ID> <QUIC_VER_SUFFIX Condition=\"'$(QUIC_VER_SUFFIX)' == ''\">-private</QUIC_VER_SUFFIX> @@ -106,7 +106,7 @@ </ClCompile> <Link> <ModuleDefinitionFile>msquicpriv.src</ModuleDefinitionFile> - <AdditionalDependencies>cng.lib;ksecdd.lib;msnetioid.lib;ndis.lib;netio.lib;uuid.lib;%(AdditionalDependencies)</AdditionalDependencies> + <AdditionalDependencies>cng.lib;ksecdd.lib;msnetioid.lib;ndis.lib;netio.lib;uuid.lib;pgortsys.lib;%(AdditionalDependencies)</AdditionalDependencies> <AdditionalOptions>/kernel /NOOPTIDATA /pdbcompress /MERGE:.gfids=GFIDS /MERGE:.orpc=.text /MERGE:_PAGE=PAGE /MERGE:_RDATA=.rdata /MERGE:_TEXT=.text /section:GFIDS,d</AdditionalOptions> <LinkTimeCodeGeneration>UseLinkTimeCodeGeneration</LinkTimeCodeGeneration> </Link> @@ -126,7 +126,7 @@ </ItemDefinitionGroup> <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\"> <Link> - <AdditionalOptions>%(AdditionalOptions) /FORCE:PGOREPRO /USEPROFILE:PGD=$(SolutionDir)artifacts\\bin\\winkernel\\$(Platform)_$(Configuration)_schannel\\priv\\msquic.pgd</AdditionalOptions> + <AdditionalOptions>%(AdditionalOptions) /FORCE:PGOREPRO /LTCG:PGI /Profile</AdditionalOptions> </Link> </ItemDefinitionGroup> <ItemGroup> You should clean build for x64 and Release. Then build user mode MsQuic using the regular script with the following flags -PGO -Tls schannel -config Release. Setting up the perf machines To train kernel mode PGO, we use the secnetperf utility. To configure the perf machines, run the following powershell script as Administrator: param( # Build path [Parameter(Mandatory=$true)] [string]$BuildPath, # MsQuic location [Parameter(Mandatory=$true)] [string]$MsQuicPath, # CPU Architecture [Parameter(Mandatory=$false)] [ValidateSet(\"amd64\", \"x86\", \"arm\", \"arm64\")] [string]$Arch=\"amd64\" ) $PgoBasePath = \"$($BuildPath)\\$($Arch)fre\\pgo\" if (!(Test-Path -Path \"c:\\pgo_collection\")) { New-Item -Path \"c:\\pgo_collection\" -ItemType Directory -Force | Out-Null } Copy-Item -Path \"$($PgoBasePath)\\pgoapi\\*\" -Filter *.ps1 -Destination \"C:\\pgo_collection\" Copy-Item -Path \"$($BuildPath)\\$($Arch)fre\\bin\\idw\\signTool.exe\" -Destination \"C:\\pgo_collection\" Copy-Item -Path \"$($BuildPath)\\$($Arch)fre\\bin\\idw\\signTool.dll\" -Destination \"C:\\pgo_collection\" if (!(Test-Path -Path \"c:\\pgo_collection\\sweep\")) { New-Item -Path \"c:\\pgo_collection\\sweep\" -ItemType Directory -Force | Out-Null } Copy-Item -Path \"$($PgoBasePath)\\kmode\\system32\\pgosweep.exe\" -Destination \"C:\\pgo_collection\\sweep\" Copy-Item -Path \"$($PgoBasePath)\\kmode\\system32\\vcruntime140.dll\" -Destination \"C:\\pgo_collection\\sweep\" Copy-Item -Path \"$($PgoBasePath)\\kmode\\system32\\drivers\\pgodriver.sys\" -Destination \"C:\\pgo_collection\\sweep\" Copy-Item -Path \"$($PgoBasePath)\\bbttools\\bbtlddll.exe\" -Destination \"C:\\pgo_collection\\sweep\" Copy-Item -Path \"$($PgoBasePath)\\bbttools\\createdir.sys\" -Destination \"C:\\pgo_collection\\sweep\" Copy-Item -Path \"$($PgoBasePath)\\tools\\pgort140.dll\" -Destination \"C:\\pgo_collection\\sweep\" # Install PGO powershell -NonInteractive -NoProfile -File \"c:\\pgo_collection\\install-pgo.ps1\" -PgoChunkPath $PgoBasePath -PgoChunkNativePath $PgoBasePath -PgoCollectionDir \"c:\\pgo_collection\" -SignTool \"c:\\pgo_collection\\signtool.exe\" -PGOArch $Arch # Fix PGODriver sc.exe config pgodriver start= auto # Copy MsQuic if ($arch -eq \"amd64\") { $QuicArch = \"x64\" } else { $QuicArch = $Arch } $WindowsBinPath = \"artifacts\\bin\\windows\\$($QuicArch)_Release_schannel\" $WinKernelBinPath = \"artifacts\\bin\\winKernel\\$($QuicArch)_Release_schannel\" if (!(Test-Path -Path \"c:\\msquic\\$($WindowsBinPath)\")) { New-Item -Path \"c:\\msquic\\$($WindowsBinPath)\" -ItemType Directory -Force | Out-Null } if (!(Test-Path -Path \"c:\\msquic\\$($WinKernelBinPath)\")) { New-Item -Path \"c:\\msquic\\$($WinKernelBinPath)\" -ItemType Directory -Force | Out-Null } Copy-Item -Path \"$($MsQuicPath)\\$($WindowsBinPath)\\msquic.dll\" -Destination \"c:\\msquic\\$($WinKernelBinPath)\" Copy-Item -Path \"$($MsQuicPath)\\$($WindowsBinPath)\\secnetperf.exe\" -Destination \"c:\\msquic\\$($WinKernelBinPath)\" Copy-Item -Path \"$($MsQuicPath)\\$($WinKernelBinPath)\\*\" -Destination \"c:\\msquic\\$($WinKernelBinPath)\" sc.exe create \"msquicpriv\" type= kernel binpath= \"C:\\msquic\\$($WinKernelBinPath)\\msquicpriv.sys\" start= demand New-NetFirewallRule -DisplayName \"Allow SecNetPerf\" -Enabled True -Profile Any -Direction Inbound -Action Allow -Protocol UDP -LocalPort 4433 bcdedit /debug on Write-Host Now Reboot the machine Make sure the machine is configured for kernel debugging and a kernel debugger is attached, otherwise the msquicpriv.sys driver won't load. Training Now that the perf machines are configured for kernel mode PGO, it's time to run the scenarios. On the machine that will act as server, run the following command to start the server: secnetperf.exe -kernel Once running, clear the PGO counts on both the client and server machines to get a clean slate: pgosweep.exe /driver msquicpriv.sys .\\msquicpriv.pgc del msquicpriv.pgc On the machine acting as client, run the following commands to generate traffic: secnetperf.exe --kernel -test:tput -target:<server IP> -upload:5000000000 secnetperf.exe --kernel -test:tput -target:<server IP> -download:5000000000 secnetperf.exe --kernel -test:RPS -target:<server IP> secnetperf.exe --kernel -test:HPS -target:<server IP> After the client finishes all scenarios, run this again on the client and the server to collect the updated counts: pgosweep.exe /driver msquicpriv.sys .\\msquicpriv.pgc Copy the .pgc files to a machine with the Visual Studio tools installed and run the following to merge the PGC files into the PGD that was generated during build, and then copy that PGD into the git repo: pgomgr.exe /merge msquicpriv-client.pgc msquicpriv-server.pgc c:\\msquic\\artifacts\\bin\\winkernel\\x64_Release_schannel\\msquicpriv.pgd xcopy :\\msquic\\artifacts\\bin\\winkernel\\x64_Release_schannel\\msquicpriv.pgd c:\\msquic\\src\\bin\\winkernel\\pgo_x64\\msquic.pgd If pgomgr.exe emits a warning that the database doesn't match, use pgodump.exe to check the ID of both the PGD and PGC files and ensure they match. If the PGC file doesn't match, it's most likely because msquicpriv.sys didn't unload completely when you installed a new one. You will need to stop PGODriver.sys before stopping msquicpriv.sys when replacing msquicpriv.sys with a newer version. You can also reboot the system after replacing msquicpriv.sys. Sample output from pgodump.exe showing the IDs are same between PGD and PGC > pgodump.exe c:\\msquic\\artifacts\\bin\\winkernel\\x64_Release_schannel\\msquicpriv.pgd Microsoft (R) Profile Guided Optimization Database Dump Utility Copyright (C) Microsoft Corporation. All rights reserved. PGD File: c:\\msquic\\artifacts\\bin\\winkernel\\x64_Release_schannel\\msquicpriv.pgd (v44, ID CC21BC03, Signature 4F474F50) 10/27/2020 22:25:53 > pgodump.exe msquicpriv-client.pgc Microsoft (R) Profile Guided Optimization Database Dump Utility Copyright (C) Microsoft Corporation. All rights reserved. PGC File: msquicpriv!client.pgc (ID CC21BC03)"
  },
  "docs/Platforms.html": {
    "href": "docs/Platforms.html",
    "title": "Platform Support",
    "summary": "Platform Support MsQuic currently officially supports the following platform configurations. Information on support for MsQuic itself is located in Release.md. Windows On Windows, by default, MsQuic relies on built-in support from Schannel for TLS 1.3 functionality. MsQuic is shipped in-box in the Windows kernel in the form of the msquic.sys driver, to support built-in HTTP and SMB features. User mode applications use msquic.dll (built from here) and package it with their app. Important This configuration requires running either Windows Server 2022, Windows 11 or the latest Windows Insider Preview Builds for Schannel's TLS 1.3 support. Important This configuration does not support 0-RTT due to Schannel's current lack of support. OpenSSL Optionally, msquic.dll can be built with OpenSSL (see below for more details) instead of Schannel on Windows. This removes the Windows OS dependency on TLS from MsQuic, so MsQuic should work on most Windows 10 based client and server versions (it may work on even older Windows releases but supporting them is not a goal for MsQuic). Both version 1.1 and 3.1 of OpenSSL are supported. Linux On Linux, MsQuic relies on OpenSSL for TLS 1.3 functionality. Both version 1.1 and 3.1 are supported. The libmsquic package will generally depend on the default OS installed OpenSSL version's libcrypto. Important This configuration relies on a fork of OpenSSL for QUIC/TLS support. It is still currently unknown as to when mainline will support QUIC. See here for more details. MsQuic with OpenSSL does fully support 0-RTT. Other For testing or experimentation purposes, MsQuic may be built with other configurations, but they are not to be considered officially supported unless they are listed above. Any bugs found while using these configurations may be looked at, but no guarantees are provided that they will be fixed."
  },
  "docs/PreviewFeatures.html": {
    "href": "docs/PreviewFeatures.html",
    "title": "GPreview features",
    "summary": "GPreview features Important Preview features are recently included features in the MsQuic library. The API for the preview features should be considered unstable / not fully baked in / subject to change. Please be aware of these additional risks before using the preview feature API. New features added to the MsQuic library are exposed through newly added API as a preview, for stabilization and gradual adoption. These new API are first made available in the export headers only in the Preview mode. The underlying functionality is still present in the MsQuic library but is unreachable through regular API. When a new feature is deemed ready for wider use, its API is moved from the preview portion to the regular portion of MsQuic library headers. QUIC_API_ENABLE_PREVIEW_FEATURES A preview feature's API declarations (typically in msquic.h) are placed within pre-processor conditional sections that are enabled using the QUIC_API_ENABLE_PREVIEW_FEATURES macro, to isolate it from the rest of the established API. Any application wanting to use the preview features must declare this macro (and set it to 1) before including the MsQuic headers. Current list of Preview features Reliable Reset Negotiated TODO Oneway Delay Negotiated TODO Network Statistics TODO App-provided receive buffers StreamProvideReceiveBuffers QUIC_API_ENABLE_PREVIEW_FEATURES"
  },
  "docs/QTIP.html": {
    "href": "docs/QTIP.html",
    "title": "QTIP",
    "summary": "QTIP What? QTIP is an MsQuic specific concept that allows MsQuic to exercise the QUIC protocol over XDP using TCP packets. To be specific, QTIP adds a TCP header to the QUIC packet instead of a UDP header. It doesn't follow the TCP protocol after the initial handshake: headers are generated with good enough data to be compatible with most networks and leverage TCP specific optimizations, but are not used to operate the protocol. You can think of it as disguising QUIC packets as TCP packets! Why? Certain hardware / networks / cloud environments are optimized for TCP traffic. Instead of pushing for those environments to also optimize for UDP, QTIP allows us to leverage existing hardware with MsQuic. How? To use QTIP, you first must be running XDP. The setting is ignored if XDP is not enabled. QTIPEnabled in QUIC_SETTINGS controls whether client connections exclusively use QTIP, and whether listeners will optionally accept QTIP traffic. Opt in to use QTIP for listeners by setting QTIPEnabled to true at a global level prior to starting the listener. Additionally, all client connections created thereafter will send/recv data over QTIP. This setting can be overridden per client connection, allowing you to create some client connections that send QTIP or UDP traffic. Important Crucial information necessary for users to succeed. Using QTIP will initialize a TCP socket and attempt to bind to your listener's local address. This is to reserve a TCP port for your listener to ensure XDP does not steal any TCP traffic from your other processes later. That also means you need to ensure no other processes are listening on the same TCP port as your listener's local address prior to starting your listener, otherwise the OS will throw a socket access denied / address in use error, and your listener will fail to initialize."
  },
  "docs/ReceiveBuffer.html": {
    "href": "docs/ReceiveBuffer.html",
    "title": "Receive Buffer Architecture",
    "summary": "Receive Buffer Architecture The receive buffer, QUIC_RECV_BUFFER in recv_buffer.c, manages the buffering and reassembly of the crypto or stream data received from a peer. It abstracts the buffer memory management and the data reassembly logic. Since this is core to much of the data path for QUIC, the receive buffer is highly optimized for performance, often at the price of more complexity. Interface The QUIC_RECV_BUFFER provides a fairly simple interface to callers, in recv_buffer.h. It uses 3 main verbs: Write, QuicRecvBufferWrite - Writes received data to the receive buffer. Read, QuicRecvBufferRead - Reads the available data from the front of the receive buffer. Drain, QuicRecvBufferDrain - Drains a length of data from the front of the receive buffer. Initialization, cleanup and various helper functions complete the interface, but are mainly supporting the three actions above. General Usage A caller first 'writes' received data to the receive buffer, which copies the data locally. Internally, the receive buffer manages the memory dynamically to ensure the appropriate amount of space is available to store the data (up to its virtual size, more on this below). The receive buffer also manages the reassembly logic, tracking which offsets and lengths have been received. As an output of the 'write', the receive buffer indicates if data can be read from the front of the buffer. The caller may make multiple writes before any call to read (which improves performances by allowing several 'writes' to be batched into a single 'read'). The caller then 'reads' data. The receive buffer reads as much contiguous data as possible starting from its current reading head position. It will populate the array of QUIC_BUFFER provided by the caller with pointers and length, as a view of its internal buffers. Finally, the caller 'drains' data from the receive buffer. The receive buffer discards the drained data, moving its reading head by the number of drained bytes. The receive buffer ensures that the QUIC_BUFFERs provided for a 'read' are valid until the data is drained (more details on this when discussing the buffer modes). The caller doesn't necessarily drain all the data indicated by a 'read'. Throughout the lifetime of the receive buffer, the cycle of write, read, drain calls continues until the caller is done with the receive buffer. Different Modes of Operation Different modes of operation are supported by the receive buffer. Single, QUIC_RECV_BUF_MODE_SINGLE - Ensures a 'reads' always indicates a single contiguous buffer; Circular, QUIC_RECV_BUF_MODE_CIRCULAR - Default receive buffer mode, balances performances and ease of use; Multiple, QUIC_RECV_BUF_MODE_MULTIPLE - Allows multiple independent pending reads; AppOwned, QUIC_RECV_BUF_MODE_APP_OWNED - Uses memory buffers provided by the caller to write data; The 'write' operation is similar for all modes, but the behavior of 'read' and 'drain' operations change. Contiguous data buffering The Single mode guarantees that all data indicated on a 'read' is contiguous in memory: it always returns a single QUIC_BUFFER. However, Single mode needs additional data copy to implement this behavior and is less performant. This mode is used because the TLS libraries do not support 'gather' semantics and expect to operate on single, contiguous buffers. Other modes can indicate multiple QUIC_BUFFER pointing to non-continuous memory: the number of QUIC_BUFFER reported on a 'read' is not fixed and is subject to change (the caller should not assume an upper bound). In practice, Circular mode can currently use up to 2 buffers, Multiple mode up to 3 and AppOwned mode up to the number of buffers provided by the application. Number of pending 'read' For Single, Circular and AppOwned modes, only a single 'read' can be pending at a time. Each 'read' must be paired with a 'drain' (for up to the size of the 'read', but potentially less), before another 'read' can be done. For the Multiple mode, multiple 'reads' can be pending simultaneously. The number of 'drains' can differ from the number of 'read' (higher or smaller) as long as the total number of bytes drained stays lower than the total number of bytes read at all time. Partial 'drain' For Single, Circular and AppOwned modes, the data indicated during a 'read' that is not drained will be indicated again in the next 'read'. For the Multiple mode, each byte of data is only indicated once. A 'read' will always indicate data starting from the end of the previous 'read'. Memory ownership For Single, Circular and Multiple modes, the receive buffer owns the memory buffers and gives out pointer to its internal buffers on a 'read'. A pre-allocated buffer can be provided by the caller to optimize the receive buffer initialization, this pre-allocated buffer is owned by the caller. For the AppOwned mode, buffers are owned by the application and provided to the receive buffer. The caller must ensure buffers stay valid until they are fully drained or the receive buffer is deinitialized (more precisely, a buffer can be released by the caller as soon as all its bytes have been 'read' as long as the matching 'drain' drains all the buffer bytes - the receive buffer ). This allows to avoid a copy but increases the application memory management complexity. Internal Design In very few words, the receive buffers does the following: It tracks all bytes written during the lifetime of the buffer, from byte index 0. It maintains a reading head pointing to the first byte that has not been drained yet, and the offset of that byte in the stream. It manages buffer allocations to store bytes written to the buffer It grows the allocated buffer space as needed It copies bytes to the appropriate buffer index based on their stream offset to re-order them. It references buffers while they are shared with the client to ensure they aren't freed. Data structures QUIC_RECV_BUFFER store information in two main data structures, with other variables helping to manage them. A WrittenRanges, a QUIC_RANGE which stores which byte numbers that have been written to the receive buffer. It maps directly to the byte offsets from the Quic stream and stores the offsets for all bytes written to the buffer since its creation (not only the one currently stored). A list of Chunks. QUIC_RECV_CHUNKs are essentially memory buffers associated with control variables (size, list link, ...). They contain the memory allocated in the receive buffer. Data is read and written there. The logic surrounding WrittenRanges is pretty straightforward: when data is written to the receive buffer, the new byte offsets are inserted in WrittenRanges. At any time, the first contiguous segment of WrittenRanges is the data that has been, or can be read by the client. The interesting logic is largely about managing the list of Chunks. Active and retired chunks Chunks can be \"active\" or \"retired\". An active chunk data can be used by a new 'read' or 'write' operation. A retired chunk is a chunk that is waiting to be deleted but is currently referenced by the application. All its data has either been drained or has been copied to an active chunk, it will be deleted as soon as it isn't referenced anymore. Currently, the single and circular can have up to one retired chunk and one active chunk. The multiple and app-owned modes do not use retired chunks and can have multiple active chunks. A special chunk: the first active chunk 'Read' and 'write' operations are generally performed linearly on chunks, starting from the buffer start, progressing through it linearly and, if more data needs to be read / written, continuing on the next chunk. However, the first active chunk has a special behavior: it is treated as a circular buffer, starting from the reading head position (see ReadStart below). it can be shrunk, reducing the amount of buffer space that can be used (see Capacity below). Once the index (ReadStart + Capacity) % FirstChunkLength is reached, wrapping around if needed, the processing continues with the next chunk and progress linerarly from there. This circular behavior allows the receive buffer to minimize copy and re-allocations. Control variables and invariants BaseOffset : The stream byte index of the byte at the reading head position. VirtualBufferLength : The size of the receive buffer as indicated to the client code. It doesn't necessarily correspond to the amount of memory currently allocated in the receive buffer. Invariant: BaseOffset and BaseOffset + VirtualBufferLength must only increase through time. However, VirtualBufferLength can decrease. Invariant: A 'write' operation must only write bytes with offset lower than BaseOffset + VirtualBufferLength. Bytes offset lower than BaseOffset are ignored. ReadPendingLength : The number of bytes that have been indicated to the client through a 'read' and not released by 'drain' yet. Invariant: BaseOffset + ReadPendingLength is smaller than the size of the first range in WrittenRanges. For modes other than \"Multiple\", a 'read' is allowed if and only if ReadPendingLength == 0 and a drain reset ReadPendingLength to 0. The variables below are tracking properties of the first active chunk in the Chunks list to handle its special behavior. ReadStart : The offset of the reading head in the first active chunk. Invariant: For Single mode, ReadStart == 0. Capacity : The usable size of the first active chunk. Only bytes in [ReadStart, ReadStart + Capacity) (seen in a circular way) should be accessed. It is used to progressively shrink the size of the first active chunk when data is 'read' and the buffer space should not be re-used (App-owned and Multiple modes). Invariant: For Single and AppOwned modes, ReadStart + Capacity is smaller than the first active chunk size. This implies that the chunk will never be used in a circular fashion in these modes. ReadLength : The number of bytes that can be 'read' from the first active chunk. Invariant: ReadLength is the minimum between Capacity and FirstRangeSize - BaseOffset (where FirstRangeSize is the size of the first range in WrittenRanges). Memory Management As mentioned above, the receive buffer generally manages memory itself and doesn't follow the common socket recv model of requiring the app the pre-post a buffer. The AppOwned mode is the exception, with memory being managed by the caller. Internally, the receive buffer tries to minimize total memory usage, both in terms of bytes and number of unique buffers to keep at once. It generally prefers one large chunk over multiple smaller chunks, even if this means data must be copied from one buffer to another (larger) one. This aims to reduce the complexity of both the internal implementation and the caller implementation. Since the receive buffer gives out pointers to its internal buffers, it must keep track of these external references and extend the lifetimes of chunks so that they are not deleted from underneath the caller. This means the receive buffer might keep a \"retired\" buffer for some time, or decide to have multiple active chunks for a while. Another aspect of memory management is balancing the amount of memory we advertised to the peer we are willing to allocate and how much we actually allocate. The caller controls both the advertised, maximum allocation size, as well as the initial buffer size to allocate. The caller can dynamically increase the maximum size as necessary. The receive buffer takes these values and dynamically allocates memory (doubling in size as necessary) up to the maximum size - except in AppOwned mode, where the application must provide memory to match the maximum size advertised to the peer. Less words, more ASCII art!! x, +: A 'write' put data here .: No data here yet : Bytes that should no longer be accessed A very generic view of the receive buffer could be: Retired Chunk 1 Chunk 2 Chunk 3 ┌──────────────┐ ┌───────────────────────────────────────────────────────────┐ ┌────────────────┐ ┌──────────────┐ │ │ │xxx.......xxxxxxxx xxxxxxxxxxxxxxxxxxxxxx├──►│xxxxxxxx........├──►│xxxxxxxxxxx...│ └──────────────┘ └───▲──────────────▲──────────────────▲───────────────▲─────┘ └────────────────┘ └──────────────┘ │ │ │ │ ReadStart + ReadStart + ReadStart ReadStart + ReadLength Capacity ReadPendingLength This receive buffer has 1 retired chunk and 3 active chunks. WrittenRanges contains 3 data segments: [0, ReadStart + ReadLength], cycling through the end of Chunk 1; The second segment goes over the end of Chunk 1 and the start of Chunk 2; The third segment is at the start of chunk3 However, the state of the receive buffer presented above is so generic it will actually never happen: For instance, single and circular modes would only have a single active chunk at a time. Multiple and app-owned would not have a retired chunk. Still, this is the model to keep in mind for code that must be compatible with all modes. Circular mode Chunk 1 ┌───────────────────────────────────────────────────────────┐ │xxx.......xxxxxxxx...................xxxxxxxxxxxxxxxxxxxxxx│ └───▲─────────────────────────────────▲───────────────▲─────┘ │ │ │ ReadStart + ReadStart ReadStart + ReadLength │ ReadPendingLength │ ReadStart + Capacity In circular mode, the data can wrap around the end. There is always a single active chunk and the capacity is always the full buffer size. A \"retired\" chunk can be present in a similar way as in the Single mode exemple below. Single mode Retired Chunk 1 ┌──────────────┐ ┌───────────────────────────────────────────────────────────┐ │xxxxxxxxxx....│ │xxxxxxxxxx+++++++...++++...................................│ └──────────────┘ └▲─────────▲──────▲─────────────────────────────────────────▲ │ │ │ │ ReadStart │ ReadStart + ReadStart + │ ReadLength Capacity │ ReadStart + ReadPendingLength In single mode, ReadStart is always at the front of the buffer. A 'read' was pending and data + could not fit in the initial chunk: the old chunk had to be retired until it isn't referenced anymore and data x was copied to the new chunk front. Multiple mode Chunk 1 Chunk 2 ┌───────────────────────────────────────────────────────────┐ ┌────────────────┐ │xxx.......xxxxxxxx ++++++++++++++++xxxxxx├──►│xxxxxxxx........│ └───▲──────────────▲──────────────────▲───────────────▲─────┘ └────────────────┘ │ │ │ │ ReadStart + ReadStart + ReadStart ReadStart + ReadLength Capacity ReadPendingLength In multiple mode, several chunks can be active at the same time. It took several steps to arrive to the situation above: Data + was written to the buffer A 'read' was performed for all the data + More data x was written to the buffer, causing the creation of Chunk 2 once Chunk 1 was full Note that if a read was not pending on Chunk 1, data would have been copied instead to Chunk 2. A 'drain' was performed for part of the data + Since a second chunk is present, the Capacity was shrunk as part of the drain App-owned mode Chunk 1 Chunk 2 Chunk 3 ┌───────────────────────────────────────────────────────────┐ ┌────────────────┐ ┌──────────────┐ │ xxxxxxxxxxxxxxxxxxxxxxxx..............├──►│xxxxxxxx........├──►│....xxxxxxx...│ └─────────────────────▲───────────────────────▲─────────────▲ └────────────────┘ └──────────────┘ │ │ │ ReadStart ReadStart + ReadStart + ReadLength Capacity In app-owned mode, ReadStart + Capacity always point to the end of the first chunk, no wrap around ever happen. Bytes from the start of the first chunk up to ReadStart should no longer be accessed: we need to write in the provided buffer only once and in order. Many active chunks can be present at the same time."
  },
  "docs/Release.html": {
    "href": "docs/Release.html",
    "title": "Support for MsQuic",
    "summary": "Support for MsQuic An MsQuic release begins its life in the main branch where it receives feature updates as well as servicing for security and bug fixes. When it is time to release, the code will be forked into a release branch where it is considered stable and will generally only receive servicing for security and bug fixes. MsQuic Branches MsQuic has two main types of branches main and release defined as: Main - Main is the primary development branch, and receives security and bug fixes just the same as the release branches. However, the main branch is where active development happens and because of this the main branch may experience breaking changes as we develop new features. Release - Release branches only receive security and bug fixes, and are considered stable. There should be no breaking changes in these branches, and they can be used for stable products. Prerelease - The Releases section below indicates which releases are considered officially supported and serviced releases. All others are considered prereleases, which are generally considered stable, but will not receive servicing fixes. * Both main and official release branches receive critical fixes throughout their lifecycle, for security, reliability. Release Support Policies MsQuic support lifecycle is governed by the Windows Server servicing channels: LTSC and SAC LTSC indicates official release branches to be serviced for 5 years mainstream and 5 years extended. SAC indicates official release branches to be serviced for 18 months. PRE indicates prerelease branches (not officially supported). TBD indicates release branches that are set to be classified as one of the above. Important Main is not considered officially supported. It is under active development (i.e. not stable), however it does receive security and bug fixes. End of support End of support refers to the date when Microsoft no longer provides fixes, updates, or online technical assistance for your product. As this date nears, make sure you have the latest available update installed. Without Microsoft support, you will no longer receive security updates that can help protect your machine from harmful viruses, spyware, and other malicious software that can steal your personal information. Releases A release branch will be created (forked) for each release of MsQuic. Official release branches will then go through a several month stabilization process before it is then finalized. Once finalized, offical release branches will only be serviced with security and bug fixes throughout its lifecycle. MsQuic official releases generally will correspond to Windows releases, but in some cases additional future releases may be created for other major products. Official releases for Windows generally will end support at the same time as the Windows release. This table describes all officially supported MsQuic releases. Type Branch Consumer Fork Date Release Date End of Support Supported Platforms SAC release/2.3 Windows Server 2025 Windows 11 Jan 26 2024 Mar 12 2024 Sept 12 2025 Windows, Linux SAC release/2.4 Windows Server 2025 Windows 11 .NET 9.0 Aug 5 2024 Aug 16 2024 Feb 16 2026 Windows, Linux SAC release/2.5 TBD May 15 2025 TBD TBD Windows, Linux * Future Release Dates are subject to change. ** End of Support dates do not include possible extended support extensions. Platforms We officially support the following operating systems and architectures. OS Architectures Windows x64, arm64 Linux x64, arm64, arm32 MsQuic may work on other platforms, including macOS, iOS, Android, x86, etc. but is not currently officially supported. Publishing a Release Create a New Release Branch Add (via PR) notes above for the new release. Fork main branch to release/X.Y where X is the major version and Y is the minor version. Update (via PR) the minor version for the main branch: Run ./scripts/update-version.ps1 -Part Minor to generate the relavent changes. Also add the new version to the bug_report.yaml issue template file. Servicing a Release Branch Changes first go into the main branch, and then are cherry-picked into the relavent release/X.Y branches. Update (via PR) the patch version for the release branches: Run ./scripts/update-version.ps1 -Part Patch to generate the relavent changes. Publishing a Release Branch Create a new GitHub release along with the corresponding tag. Make sure to pick the correct release/X.Y branch The tag should be the full version number: vX.Y.Z The release title should be MsQuic vX.Y.Z Put relavent information in the notes of the release (see previous releases for examples) Wait for msquic-Official-Tests pipeline to run for the newly created tag. Download the distribution packages from the artifacts and upload them to the GitHub release: msquic_gamecore_console_x64_Release_schannel.zip msquic_linux_x64_Release_quictls.zip msquic_linux_x64_Release_quictls_test.zip msquic_windows_arm64_Release_quictls.zip msquic_windows_arm64_Release_schannel.zip msquic_windows_arm_Release_quictls.zip msquic_windows_arm_Release_schannel.zip msquic_windows_x64_Release_quictls.zip msquic_windows_x64_Release_quictls_test.zip msquic_windows_x64_Release_schannel.zip msquic_windows_x64_Release_schannel_test.zip msquic_windows_x86_Release_quictls.zip msquic_windows_x86_Release_schannel.zip Update (via PR) main branch's test-down-level.yml to point the newly uploaded *_test.zip release binaries. Note - NuGet packages are automatically published to nuget.org by the pipeline. Publishing Linux packages to packages.microsoft.com (PMC) The publishing pipeline automatically uploads packages into PMC when a tag is created. Sometimes the pipeline fails due to PMC infra issues (e.g. the PMC HTTP endpoint returning errors). The publishing pipeline can be run manually to retry. When running manually, please ensure that the right tag is chosen and the right resources (under \"Advanced options\") are chosen. By default, the pipeline picks up the latest resources from the official build pipeline which are not always the right ones. When testing the pipeline, please make sure to comment out the PMC cli commands in upload-linux-packages.sh to avoid accidentally publishing packages into prod. Publishing MsQuic for Alpine Prerequisites: Docker Powershell Checkout to release tag. (e.g. git checkout v2.4.7) Run generate-alpine-packaging-file.ps1 script from the repository root on host computer to create APKBUILD file for the release. (This script can run on any Linux distro, and this script will create a docker alpine container to calculate hash keys in APKBUILD file) If you don't have account for AlpineLinux GitLab. Create an account and configure your SSH. If you didn't fork aports repository yet, Fork https://gitlab.alpinelinux.org/alpine/aports. Clone https://gitlab.alpinelinux.org/<your_username>/aports repository. Navigate to aports/community/libmsquic folder. Replace the APKBUILD file with newly created APKBUILD file. Create a commit using community/libmsquic: upgrade to <version_number> (version_number e.g. 2.5.0 or 2.4.4). Create a merge request using community/libmsquic: upgrade to <version_number> (version_number e.g. 2.5.0 or 2.4.4). Owners of the aports repository will respond to the PR or merge it in couple of days/hours. For future reference: Official documentation Publishing the Rust Crate The following are the complete (manual) steps for publishing the Rust crate. Create a (Linux) GitHub CodeSpace. sudo apt update sudo apt install curl curl https://sh.rustup.rs -sSf | sh Restart bash. cargo login Create an API token on https://crates.io/settings/tokens (with publish-update scope). Paste the token into bash. If doing a beta release, update Cargo.toml to add a # after beta in the version. cargo publish or cargo publish --allow-dirty if beta release Synchronizing with Windows Once the release branch/tag is created, the undock pipeline should run automatically. If for some reason there's a problem, you may need to run the pipline manually by clicking on \"Run Pipeline\" here (MSFT-only access required), scroll down to the resources tab and pick the MsQuic release tag of interest then run the pipeline. Another workaround to force a manual re-run by going here (MSFT-only access required) and deleting the tag, and then waiting for the mirror pipeline (MSFT-only access required) to run automatically re-copy over the tag from GitHub. Once the pipeline passes tests, get the VPACK ID from the \"Create VPACK\" stage, and create a PR to point this file (MSFT-only access required) to the VPACK created by the pipline run. Review and merge the PR to complete the process."
  },
  "docs/Sample.html": {
    "href": "docs/Sample.html",
    "title": "Running Sample MsQuic Server and Client",
    "summary": "Running Sample MsQuic Server and Client Sample provides a very simple MsQuic API sample server and client application. Generate Self Signed Certificate A certificate needs to be available for the server to function. To generate a self-signed certificate, run On Windows New-SelfSignedCertificate -DnsName $env:computername,localhost -FriendlyName MsQuic-Test -KeyUsageProperty Sign -KeyUsage DigitalSignature -CertStoreLocation cert:\\CurrentUser\\My -HashAlgorithm SHA256 -Provider \"Microsoft Software Key Storage Provider\" -KeyExportPolicy Exportable This works for both Schannel and OpenSSL TLS providers, assuming the KeyExportPolicy parameter is set to Exportable. The Thumbprint received from the command is then passed to the sample server at startup. Copy the thumbprint received. On Linux openssl req -nodes -new -x509 -keyout server.key -out server.cert This works with OpenSSL TLS Provider. It can also be used for Windows OpenSSL, however we recommend the certificate store method above for ease of use. Currently key files with password protections are not supported. With these files, they can be passed to the sample server with -cert_file:path/to/server.cert and -key_file path/to/server.key parameters. Start the server Locate the executable quicsample.exe or quicsample under your artifacts/bin directory under repo root. Start the server providing the certificate and key obtained in the previous step. On Windows, certificate hash can be used to load from certficate store: quicsample.exe -server -cert_hash:FAF9B176D64930D67C372CB456BAD38E7E5689F7 On Linux, file paths can be used to load server credential: quicsample -server -cert_file:path/to/server.cert -key_file:path/to/server.key By default, the server listens on port 4567. Start the client Start the client providing the IP address for the server. Here 127.0.0.1 is used as an example. quicsample -client -unsecure -target:127.0.0.1 Troubleshooting with Wireshark When running the client you can set the environment variable SSLKEYLOGFILE to the absolute path of the file that will receive the TLS secrets. Learn how to load such file inside Wireshark and see what is being transmitted on the wire: Using the (Pre)-Master-Secret Console Output Here is what the console output looks like on the server and client sides after connection is established and data flows: Server side [conn][000001C32C29CC10] Connected [strm][000001C32C261000] Peer started [strm][000001C32C261000] Data received [strm][000001C32C261000] Peer shut down [strm][000001C32C261000] Sending data... [strm][000001C32C261000] Data sent [strm][000001C32C261000] All done [conn][000001C32C29CC10] Successfully shut down on idle. [conn][000001C32C29CC10] All done Client side [conn][000001BE9F0C7000] Connecting... [conn][000001BE9F0C7000] Connected [strm][000001BE9F0CADF0] Starting... [strm][000001BE9F0CADF0] Sending data... [strm][000001BE9F0CADF0] Data sent [conn][000001BE9F0C7000] Resumption ticket received (56 bytes): 01000000013100010243E8030245C00404810000000504800100000604800100000704800100000801010E0104C0000000FF03DE1A027E80 [strm][000001BE9F0CADF0] Data received [strm][000001BE9F0CADF0] Peer shut down [strm][000001BE9F0CADF0] All done [conn][000001BE9F0C7000] Successfully shut down on idle. [conn][000001BE9F0C7000] All done Description The quicsample app implements a simple protocol (ALPN \"sample\") where the client connects to the server, opens a single bidirectional stream, sends some data and shuts down the stream in the send direction. On the server side all connections, streams and data are accepted. After the stream is shut down, the server then sends its own data and shuts down its send direction. The connection only shuts down when the 1 second idle timeout triggers."
  },
  "docs/Settings.html": {
    "href": "docs/Settings.html",
    "title": "MsQuic Settings",
    "summary": "MsQuic Settings MsQuic supports a number of configuration knobs (or settings). These settings can either be set dynamically (via the QUIC_SETTINGS structure) or via persistent storage (e.g. registry on Windows). Warning Generally MsQuic already choses the best / most correct default values for all settings. Settings should only be changed after due diligence and A/B testing is performed. MsQuic settings are available on most MsQuic API objects. Here we'll provide an overview of them with links to further details. Windows Registry MsQuic supports most of the settings in the QUIC_SETTINGS struct in the registry to be loaded as defaults when the MsQuic library is loaded in a process. These registry settings only provide the defaults; the application is free to change the settings with a call to SetParam or in QUIC_SETTINGS structs passed into ConfigurationOpen. The default settings are updated automatically in the application when changing the registry, assuming the application hasn't already changed the setting, which overrides the registry value. However, this does not change the settings on Connections which are already established, or Configurations which are already created. Note: MaxWorkerQueueDelay uses milliseconds in the registry, but uses microseconds (us) in the QUIC_SETTINGS struct. The following settings are unique to the registry: Setting Type Registry Name Default Description Max Worker Queue Delay uint32_t MaxWorkerQueueDelayMs 250 The maximum queue delay (in ms) allowed for a worker thread. Max Partition Count uint16_t MaxPartitionCount System CPU count The maximum processor count used for partitioning work in MsQuic. Max 512. Restart is required. The following settings are available via registry as well as via QUIC_SETTINGS: Setting Type Registry Name Default Description Max Bytes per Key uint64_t MaxBytesPerKey 274,877,906,944 Maximum number of bytes to encrypt with a single 1-RTT encryption key before initiating key update. Handshake Idle Timeout uint64_t HandshakeIdleTimeoutMs 10,000 How long a handshake can idle before it is discarded. Idle Timeout uint64_t IdleTimeoutMs 30,000 How long a connection can go idle before it is silently shut down. 0 to disable timeout Max TLS Send Buffer (Client) uint32_t TlsClientMaxSendBuffer 4,096 How much client TLS data to buffer. Max TLS Send Buffer (Server) uint32_t TlsServerMaxSendBuffer 8,192 How much server TLS data to buffer. Stream Receive Window uint32_t StreamRecvWindowDefault 65,536 Initial stream receive window size for all stream types. Stream Receive Window (Bidirectional, locally created) uint32_t StreamRecvWindowBidiLocalDefault - If set, overrides stream receive window size for locally initiated bidirectional streams. Stream Receive Window (Bidirectional, remotely created) uint32_t StreamRecvWindowBidiRemoteDefault - If set, overrides stream receive window size for remote initiated bidirectional streams. Stream Receive Window (Unidirectional) uint32_t StreamRecvWindowUnidiDefault - If set, overrides stream receive window size for remote initiated unidirectional streams. Stream Receive Buffer uint32_t StreamRecvBufferDefault 4,096 Stream initial buffer size. Flow Control Window uint32_t ConnFlowControlWindow 16,777,216 Connection-wide flow control window. Max Stateless Operations uint32_t MaxStatelessOperations 16 The maximum number of stateless operations that may be queued on a worker at any one time. Initial Window uint32_t InitialWindowPackets 10 The size (in packets) of the initial congestion window for a connection. Send Idle Timeout uint32_t SendIdleTimeoutMs 1,000 Reset congestion control after being idle SendIdleTimeoutMs milliseconds. Initial RTT uint32_t InitialRttMs 333 Initial RTT estimate. Max ACK Delay uint32_t MaxAckDelayMs 25 How long to wait after receiving data before sending an ACK. Disconnect Timeout uint32_t DisconnectTimeoutMs 16,000 How long to wait for an ACK before declaring a path dead and disconnecting. Keep Alive Interval uint32_t KeepAliveIntervalMs 0 (disabled) How often to send PING frames to keep a connection alive. Idle Timeout Period Changes DestCid uint32_t DestCidUpdateIdleTimeoutMs 20,000 Idle timeout period after which the destination CID is updated before sending again. Peer Stream Count (Bidirectional) uint16_t PeerBidiStreamCount 0 Number of bidirectional streams to allow the peer to open. Peer Stream Count (Unidirectional) uint16_t PeerUnidiStreamCount 0 Number of unidirectional streams to allow the peer to open. Retry Memory Limit uint16_t RetryMemoryFraction 65 (~0.1%) The percentage of available memory usable for handshake connections before stateless retry is used. Calculated as N/65535. Load Balancing Mode uint16_t LoadBalancingMode 0 (disabled) Global setting, not per-connection/configuration. Max Operations per Drain uint8_t MaxOperationsPerDrain 16 The maximum number of operations to drain per connection quantum. Send Buffering uint8_t SendBufferingEnabled 1 (TRUE) Buffer send data within MsQuic instead of holding application buffers until sent data is acknowledged. Send Pacing uint8_t PacingEnabled 1 (TRUE) Pace sending to avoid overfilling buffers on the path. Client Migration Support uint8_t MigrationEnabled 1 (TRUE) Enable clients to migrate IP addresses and tuples. Requires a cooperative load-balancer, or no load-balancer. Datagram Receive Support uint8_t DatagramReceiveEnabled 0 (FALSE) Advertise support for QUIC datagram extension. Server Resumption Level uint8_t ServerResumptionLevel 0 (No resumption) Server only. Controls resumption tickets and/or 0-RTT server support. Grease Quic Bit Support uint8_t GreaseQuicBitEnabled 0 (FALSE) Advertise support for Grease QUIC Bit extension. Minimum MTU uint16_t MinimumMtu 1288 The minimum MTU supported by a connection. This will be used as the starting MTU. Maximum MTU uint16_t MaximumMtu 1500 The maximum MTU supported by a connection. This will be the maximum probed value. MTU Discovery Search Timeout uint64_t MtuDiscoverySearchCompleteTimeoutUs 600000000 The time in microseconds to wait before reattempting MTU probing if max was not reached. MTU Discovery Missing Probe Count uint8_t MtuDiscoveryMissingProbeCount 3 The number of MTU probes to retry before exiting MTU probing. Max Binding Stateless Operations uint16_t MaxBindingStatelessOperations 100 The maximum number of stateless operations that may be queued on a binding at any one time. Stateless Operation Expiration uint16_t StatelessOperationExpirationMs 100 The time limit between operations for the same endpoint, in milliseconds. Congestion Control Algorithm uint16_t CongestionControlAlgorithm 0 (Cubic) The congestion control algorithm used for the connection. ECN uint8_t EcnEnabled 0 (FALSE) Enable sender-side ECN support. Stream Multi Receive uint8_t StreamMultiReceiveEnabled 0 (FALSE) Enable multi receive support XDP uint8_t XdpEnabled 0 (FALSE) Enable XDP. QTIP uint8_t QTIPEnabled 0 (FALSE) Enable QTIP. XDP must be used. Clients will only send/recv QTIP xor UDP traffic, listeners accept both. More info The types map to registry types as follows: uint64_t is a REG_QWORD. uint32_t, uint16_t, and uint8_t are REG_DWORD. While REG_DWORD can hold values larger than uint16_t, the administrator should ensure they do not exceed the maximum value of 65,535 when configuring a uint16_t setting via the Windows Registry. The following settings are available via registry as well as via QUIC_VERSION_SETTINGS: Setting Type Registry Name Default Description Acceptable Versions List uint32_t[] AcceptableVersions Unset Sets the list of versions that a given server instance will use if a client sends a first flight using them. Offered Versions List uint32_t[] OfferedVersions Unset Sets the list of versions that a given server instance will send in a Version Negotiation packet if it receives a first flight from an unknown version. This list will most often be equal to the Acceptable Versions list. Fully-Deployed Versions List uint32_t[] FullyDeployedVersions Unset Sets the list of QUIC versions that is supported and negotiated by every single QUIC server instance in this deployment. Used to generate the AvailableVersions list in the Version Negotiation Extension Transport Parameter. Version Negotiation Ext. Enabled uint32_t VersionNegotiationExtEnabled 0 (FALSE) Enables the Version Negotiation Extension. The uint32_t[] type is a REG_BINARY blob of the versions list, with each version in little-endian format. All restrictions and effects on the versions mentioned in QUIC_VERSION_SETTINGS apply to the registry-set versions as well. Particularly, on server, these must be set GLOBALLY if you want them to take effect for servers. The following settings are available via registry as well as via QUIC_STATELESS_RETRY_CONFIG: Setting Type Registry Name Default Description Stateless Retry Key Rotation interval uint32_t RetryKeyRotationMs 30000 The interval stateless retry keys are rotated on. A token is valid for 2x this interval. Stateless Retry Key Algorithm uint32_t RetryKeyAlgorithm QUIC_AEAD_ALGORITHM_AES_256_GCM The algorithm used to protect the stateless retry token. Stateless Retry Key Secret uint8_t[] RetryKeySecret Randomly Generated The secret material used to generate the stateless retry keys. MUST be secure randomness! The uint8_t[] type is a REG_BINARY blob of the secret material, and must be the same length (in bytes) as the algorithm's key. These settings only take effect in the global registry location. When changing the stateless retry configuration via registry, admins MUST delete the existing RetryKeyRotationMs, RetryKeyAlgorithm, and RetryKeySecret registry values (if present) before writing the new values. This prevents a split state from occurring while applying settings. For consistency when configuring Stateless Retry via the registry, values MUST be written in the following order: RetryKeyRotationMs RetryKeyAlgorithm RetryKeySecret See QUIC_STATELESS_RETRY_CONFIG for more information. QUIC_SETTINGS A QUIC_SETTINGS struct is used to configure settings on a Configuration handle, Connection handle, or globally. For more details see QUIC_SETTINGS. API Object Parameters MsQuic API Objects have a number of settings, or parameters, which can be queried via GetParam, or can be set/modifed via SetParam. Global Parameters These parameters are accessed by calling GetParam or SetParam with QUIC_PARAM_GLOBAL_* and a NULL object handle. Setting Type Get/Set Description QUIC_PARAM_GLOBAL_RETRY_MEMORY_PERCENT 0 uint16_t Both The percentage of available memory usable for handshake connections before stateless retry is used. QUIC_PARAM_GLOBAL_SUPPORTED_VERSIONS 1 uint32_t[] Get-only List of QUIC protocol versions supported in network byte order. QUIC_PARAM_GLOBAL_LOAD_BALACING_MODE 2 uint16_t Both Must be a QUIC_LOAD_BALANCING_MODE. QUIC_PARAM_GLOBAL_PERF_COUNTERS 3 uint64_t[] Get-only Array size is QUIC_PERF_COUNTER_MAX. QUIC_PARAM_GLOBAL_LIBRARY_VERSION 4 uint32_t[4] Get-only MsQuic API version. QUIC_PARAM_GLOBAL_SETTINGS 5 QUIC_SETTINGS Both Globally change settings for all subsequent connections. QUIC_PARAM_GLOBAL_GLOBAL_SETTINGS 6 QUIC_GLOBAL_SETTINGS Both Globally change global only settings. QUIC_PARAM_GLOBAL_VERSION_SETTINGS 7 QUIC_VERSIONS_SETTINGS Both Globally change version settings for all subsequent connections. QUIC_PARAM_GLOBAL_LIBRARY_GIT_HASH 8 char[64] Get-only Git hash used to build MsQuic (null terminated string) QUIC_PARAM_GLOBAL_EXECUTION_CONFIG 9 (preview) QUIC_GLOBAL_EXECUTION_CONFIG Both Globally configure the execution model used for QUIC. Must be set before opening registration. QUIC_PARAM_GLOBAL_TLS_PROVIDER 10 QUIC_TLS_PROVIDER Get-Only The TLS provider being used by MsQuic for the TLS handshake. QUIC_PARAM_GLOBAL_STATELESS_RESET_KEY 11 uint8_t[] Set-Only Globally change the stateless reset key for all subsequent connections. QUIC_PARAM_GLOBAL_STATISTICS_V2_SIZES 12 uint32_t[] Get-only Array of well-known sizes for each version of the QUIC_STATISTICS_V2 struct. The output array length is variable; pass a buffer of uint32_t and check BufferLength for the number of sizes returned. See GetParam documentation for usage details. QUIC_PARAM_GLOBAL_VERSION_NEGOTIATION_ENABLED (preview) uint8_t (BOOLEAN) Both Globally enable the version negotiation extension for all client and server connections. QUIC_PARAM_GLOBAL_STATELESS_RETRY_CONFIG 13 QUIC_STATELESS_RETRY_CONFIG Set-Only Configure the stateless retry token secret, key algorithm, and key rotation interval. The secret length must match the AEAD algorithm key length. Registration Parameters These parameters are accessed by calling GetParam or SetParam with QUIC_PARAM_REGISTRATION_* and a Registration object handle. Setting Type Get/Set Description Configuration Parameters These parameters are accessed by calling GetParam or SetParam with QUIC_PARAM_CONFIGURATION_* and a Configuration object handle. Setting Type Get/Set Description QUIC_PARAM_CONFIGURATION_SETTINGS 0 QUIC_SETTINGS Both Settings to use for all connections sharing this Configuration. See QUIC_SETTINGS. QUIC_PARAM_CONFIGURATION_TICKET_KEYS 1 QUIC_TICKET_KEY_CONFIG[] Set-only Resumption ticket encryption keys. Server-side only. QUIC_PARAM_CONFIGURATION_VERSION_SETTINGS 2 QUIC_VERSIONS_SETTINGS Both Change version settings for all connections on the configuration. QUIC_PARAM_CONFIGURATION_SCHANNEL_CREDENTIAL_ATTRIBUTE_W 3 QUIC_SCHANNEL_CREDENTIAL_ATTRIBUTE_W Set-only Calls SetCredentialsAttributesW with the supplied attribute and buffer on the credential handle. Schannel-only. Only valid once the credential has been loaded. QUIC_PARAM_CONFIGURATION_VERSION_NEG_ENABLED (preview) uint8_t (BOOLEAN) Both Enables the version negotiation extension for all client connections on the configuration. Listener Parameters These parameters are accessed by calling GetParam or SetParam with QUIC_PARAM_LISTENER_* and a Listener object handle. Setting Type Get/Set Description QUIC_PARAM_LISTENER_LOCAL_ADDRESS 0 QUIC_ADDR Get-only Get the full address tuple the server is listening on. QUIC_PARAM_LISTENER_STATS 1 QUIC_LISTENER_STATISTICS Get-only Get statistics specific to this Listener instance. QUIC_PARAM_LISTENER_CIBIR_ID 2 uint8_t[] Both The CIBIR well-known idenfitier. QUIC_PARAM_DOS_MODE_EVENTS 2 BOOLEAN Both The Listener opted in for DoS Mode event. QUIC_PARAM_LISTENER_PARTITION_INDEX (preview) uint16_t Both The partition to use for listener callback events and incoming connections. Connection Parameters These parameters are accessed by calling GetParam or SetParam with QUIC_PARAM_CONNECTION_* and a Connection object handle. Setting Type Get/Set Description QUIC_PARAM_CONN_QUIC_VERSION 0 uint32_t Get-only Negotiated QUIC protocol version QUIC_PARAM_CONN_LOCAL_ADDRESS 1 QUIC_ADDR Both Set on client only. Must be set before start or after handshake confirmed. QUIC_PARAM_CONN_REMOTE_ADDRESS 2 QUIC_ADDR Both Set on client only. Must be set before start. QUIC_PARAM_CONN_IDEAL_PROCESSOR 3 uint16_t Get-only Ideal processor for the app to send from. QUIC_PARAM_CONN_SETTINGS 4 QUIC_SETTINGS Both Connection settings. See QUIC_SETTINGS QUIC_PARAM_CONN_STATISTICS 5 QUIC_STATISTICS Get-only Connection-level statistics. QUIC_PARAM_CONN_STATISTICS_PLAT 6 QUIC_STATISTICS Get-only Connection-level statistics with platform-specific time format. QUIC_PARAM_CONN_SHARE_UDP_BINDING 7 uint8_t (BOOLEAN) Both Set on client only. Must be called before start. QUIC_PARAM_CONN_LOCAL_BIDI_STREAM_COUNT 8 uint16_t Get-only Number of bidirectional streams available. QUIC_PARAM_CONN_LOCAL_UNIDI_STREAM_COUNT 9 uint16_t Get-only Number of unidirectional streams available. QUIC_PARAM_CONN_MAX_STREAM_IDS 10 uint64_t[4] Get-only Array of number of client and server, bidirectional and unidirectional streams. QUIC_PARAM_CONN_CLOSE_REASON_PHRASE 11 char[] Both Max length 512 chars. QUIC_PARAM_CONN_STREAM_SCHEDULING_SCHEME 12 QUIC_STREAM_SCHEDULING_SCHEME Both Whether to use FIFO or round-robin stream scheduling. QUIC_PARAM_CONN_DATAGRAM_RECEIVE_ENABLED 13 uint8_t (BOOLEAN) Both Indicate/query support for QUIC datagram extension. Must be set before start. QUIC_PARAM_CONN_DATAGRAM_SEND_ENABLED 14 uint8_t (BOOLEAN) Get-only Indicates peer advertised support for QUIC datagram extension. Call after connected. QUIC_PARAM_CONN_DISABLE_1RTT_ENCRYPTION 15 uint8_t (BOOLEAN) Both Application must #define QUIC_API_ENABLE_INSECURE_FEATURES before including msquic.h. QUIC_PARAM_CONN_RESUMPTION_TICKET 16 uint8_t[] Set-only Must be set on client before starting connection. QUIC_PARAM_CONN_PEER_CERTIFICATE_VALID 17 uint8_t (BOOLEAN) Set-only Used for asynchronous custom certificate validation. Deprecated soon. Replaced by ConnectionCertificateValidationComplete QUIC_PARAM_CONN_LOCAL_INTERFACE 18 uint32_t Set-only The local interface index to bind to. QUIC_PARAM_CONN_TLS_SECRETS 19 QUIC_TLS_SECRETS Set-only The TLS secrets struct to be populated by MsQuic. QUIC_PARAM_CONN_VERSION_SETTINGS 20 QUIC_VERSION_SETTINGS Both The desired QUIC versions for the connection. QUIC_PARAM_CONN_CIBIR_ID 21 uint8_t[] Set-only The CIBIR well-known identifier. QUIC_PARAM_CONN_STATISTICS_V2 22 QUIC_STATISTICS_V2 Get-only Connection-level statistics, version 2. QUIC_PARAM_CONN_STATISTICS_V2_PLAT 23 QUIC_STATISTICS_V2 Get-only Connection-level statistics with platform-specific time format, version 2. QUIC_PARAM_CONN_ORIG_DEST_CID 24 uint8_t[] Get-only The original destination connection ID used by the client to connect to the server. QUIC_PARAM_CONN_SEND_DSCP 25 uint8_t Both The DiffServ Code Point put in the DiffServ field (formerly TypeOfService/TrafficClass) on packets sent from this connection. QUIC_PARAM_CONN_NETWORK_STATISTICS 32 QUIC_NETWORK_STATISTICS Get-only Returns Connection level network statistics QUIC_PARAM_CONN_CLOSE_ASYNC 26 uint8_t (BOOLEAN) Both The desired connection close behavior. Defaults to false (synchronous). QUIC_PARAM_CONN_STATISTICS_V2 Querying the QUIC_STATISTICS_V2 struct via QUIC_PARAM_CONN_STATISTICS_V2 or QUIC_PARAM_CONN_STATISTICS_V2_PLAT should be aware of possible changes in the size of the struct, depending on the version of MsQuic the app using at runtime, not just what it was compiled against. The minimum size of the struct will always be QUIC_STATISTICS_V2_SIZE_1. Future version of MsQuic will append new fields to the end of the struct, so the maximum possible size will increase. When an app queries for the statistics, it must always supply an input buffer of length at least QUIC_STATISTICS_V2_SIZE_1, but sizeof(QUIC_STATISTICS_V2) will always work as well. MsQuic will support older callers that supply at least that buffer size, even if the maximum size of the struct has grown in a future version of MsQuic. MsQuic will only write the fields that can completely fit in the buffer supplied by the app. TLS Parameters These parameters are accessed by calling GetParam or SetParam with QUIC_PARAM_TLS_* and a Connection object handle. Setting Type Get/Set Description QUIC_PARAM_TLS_HANDSHAKE_INFO 0 QUIC_HANDSHAKE_INFO Get-only Called in the QUIC_CONNECTION_EVENT_CONNECTED event to get the cryptographic parameters negotiated in the handshake. QUIC_PARAM_TLS_NEGOTIATED_ALPN 1 uint8_t[] (max 255 bytes) Get-only Called in the QUIC_CONNECTION_EVENT_CONNECTED event to get the negotiated ALPN. Schannel-only TLS Parameters These parameters are access by calling GetParam or SetParam with QUIC_PARAM_TLS_SCHANNEL_* and a Connection object handle. Setting Type Get/Set Description QUIC_PARAM_TLS_SCHANNEL_CONTEXT_ATTRIBUTE_W 0 QUIC_SCHANNEL_CONTEXT_ATTRIBUTE_W Get-only Calls QueryContextAttributesW for the given attribute and buffer. Only valid until the QUIC_CONNECTION_EVENT_CONNECTED event, or when TLS is cleaned up. QUIC_PARAM_TLS_SCHANNEL_CONTEXT_ATTRIBUTE_EX_W 1 QUIC_SCHANNEL_CONTEXT_ATTRIBUTE_EX_W Get-only Calls QueryContextAttributesExW for the given attribute and buffer. Only valid until the QUIC_CONNECTION_EVENT_CONNECTED event, or when TLS is cleaned up. QUIC_PARAM_TLS_SCHANNEL_SECURITY_CONTEXT_TOKEN 2 HANDLE Get-only Calls QuerySecurityContextToken on the Schannel handle. Only valid until the QUIC_CONNECTION_EVENT_CONNECTED event, or when TLS is cleaned up. Stream Parameters These parameters are access by calling GetParam or SetParam with QUIC_PARAM_STREAM_* and a Stream object handle. Setting Type Get/Set Description QUIC_PARAM_STREAM_ID 0 QUIC_UINT62 Get-only Must be called on a stream after StreamStart is called. QUIC_PARAM_STREAM_0RTT_LENGTH 1 uint64_t Get-only Length of 0-RTT data received from peer. QUIC_PARAM_STREAM_IDEAL_SEND_BUFFER_SIZE 2 uint64_t - bytes Get-only Ideal buffer size to queue to the stream. Assumes only one stream sends steadily. QUIC_PARAM_STREAM_PRIORITY 3 uint16_t Get/Set A value from 0x0 to 0xFFFF that indicates the Stream priority. 0xFFFF is highest priority. Data on higher priority stream get sent first. All streams start with priority 0x7FFF by default. QUIC_PARAM_STREAM_STATISTICS 4 QUIC_STREAM_STATISTICS Get-only Stream-level statistics. QUIC_PARAM_STREAM_RELIABLE_OFFSET 5 uint64_t Get/Set Part of the new Reliable Reset preview feature. Sets/Gets the number of bytes a sender must send before closing SEND path. See Also QUIC_SETTINGS GetParam SetParam"
  },
  "docs/Streams.html": {
    "href": "docs/Streams.html",
    "title": "Using Streams",
    "summary": "Using Streams Streams are the primary mechanism apps use to reliably exchange data with their peer. Streams can be opened by either peer (client or server) and can be unidirectional (can only send) or bidirectional (can send and receive). So, there are 4 types of streams: Client initiated, unidirectional stream Server initiated, unidirectional stream Client initiated, bidirectional stream Server initiated, bidirectional stream Stream ID Flow Control The QUIC protocol allows a maximum number of streams equal to 2 ^ 62. As there are 4 unique stream types, the maximum number of streams is 2 ^ 60, per stream type. No app would likely need to have this many streams open at any point. For this reason, each app controls the number of streams that the peer is allowed to open. The concept is similar to flow control of the actual data on a stream. The app tells the peer how many streams it's willing to accept at any point. Instead of a buffer size, it's a stream count. The protocol for synchronizing the maximum stream count is complicated, but MsQuic simplifies it by requiring the app to specify a number of simultaneous streams to allow the peer to open at any time. MsQuic then takes care of updating the maximum stream count for the peer as old streams get shut down. The app can configure the unidirectional and bidirectional limits separately. The default value for these is 0. If the app wants to allow the peer to open any streams, it must set a value. To set the limit on a connection, the app must configure the PeerBidiStreamCount and/or PeerUnidiStreamCount fields in QUIC_SETTINGS and apply them using SetParam with QUIC_PARAM_CONN_SETTINGS, or provide them to ConfigurationOpen. MsQuic currently restricts this count to a maximum of 65,535. Opening and Starting Streams An app calls StreamOpen to allocate a new stream. The stream object returned from StreamOpen is locally usable. The app can call any other stream API on the object, but until the stream is started all operations are essentially queued. While in this state the stream has no ID and generates no \"on-wire\" changes. If a stream is closed (StreamClose) before being successfully started, the app essentially abandons the stream. No on-wire changes will ever result from that stream. To start using the stream on-wire, the app calls StreamStart. On success, all queued operations (i.e. sends or shutdown) will immediately trigger, and the stream can start receiving QUIC_STREAM_EVENT_RECEIVE events. When calling StreamStart the app passes a set of QUIC_STREAM_START_FLAGS flags to control the behavior. Starting the stream always results in a QUIC_STREAM_EVENT_START_COMPLETE event, regardless of success/fail or synchronous/asynchronous flags. For peer initiated streams, the app gets a QUIC_CONNECTION_EVENT_PEER_STREAM_STARTED event on the connection. A stream is officially started when this event or the QUIC_STREAM_EVENT_START_COMPLETE event is received. Sending An app can send on any locally initiated stream or a peer initiated bidirectional stream. The app uses the StreamSend API to send data. MsQuic takes ownership of any buffers successfully queued via StreamSend. Buffer ownership is returned to the application via the QUIC_STREAM_EVENT_SEND_COMPLETE event. The application must not free, reuse or otherwise access a buffer provided to StreamSend until the matching QUIC_STREAM_EVENT_SEND_COMPLETE event. ![Note] QUIC_STREAM_EVENT_SEND_COMPLETE does not mean the data has been received by the peer application layer. It only means that MsQuic no longer needs the app send buffer and give the owernship back to the application. The app should not assume the data has been successfully transmitted based on this notification. Send Buffering By default, MsQuic buffers the stream data internally when StreamSend is called by an app. As long as there is room to buffer the data, MsQuic will copy the data locally and then immediately complete the send back to the app, via the QUIC_STREAM_EVENT_SEND_COMPLETE event. If there is no room to copy the data, then MsQuic will hold onto the buffer until there is room. With this mode, the app can easily \"keep the pipe full\" using only a single outstanding send: It continually keeps a single send pending on the stream. As soon as the send is completed, the app immediately queues a new send again with any new data it needs to transmit. This is seen by many as the simplest design for apps, and it allows great performances by ensuring MsQuic send path never runs idle. However, internal buffering introduces an additional copy in the data path, which can be a performance draw back for some application. MsQuic also supports another buffering mode that requires no internal copy of the data: MsQuic holds onto the app buffers until all the data has been acknowledged by the peer. To fill the pipe in this mode, the app is responsible for keeping enough sends pending at all times to ensure the connection doesn't go idle. MsQuic indicates the amount of data the app should keep pending in the QUIC_STREAM_EVENT_IDEAL_SEND_BUFFER_SIZE event. The app should always have at least two sends pending at a time: If only a single send is used, the connection will go idle for the interval of time between when a send is completed and a new send is queued. To disable internal send buffering and use the second mode, the app must set SendBufferingEnabled to FALSE through MsQuic settings. Send Shutdown The send direction can be shut down in three different ways: Graceful - The sender can gracefully shut down the send direction by calling StreamShutdown with the QUIC_STREAM_SHUTDOWN_FLAG_GRACEFUL flag or by including the QUIC_SEND_FLAG_FIN flag on the last StreamSend call. In this scenario all data will first be delivered to the peer, then the peer is informed the stream has been gracefully shut down. Sender Abort - The sender can abortively shut down the send direction by calling StreamShutdown with the QUIC_STREAM_SHUTDOWN_FLAG_ABORT_SEND flag. In this scenario, all outstanding sends are immediately canceled and are not delivered to the peer. The peer is immediately informed of the abort. Receiver Abort - The receiver can abortively shut down their peer's send direction. When this happens the sender will get a QUIC_STREAM_EVENT_PEER_RECEIVE_ABORTED event. When the send has been completely shut down the app will get a QUIC_STREAM_EVENT_SEND_SHUTDOWN_COMPLETE event. This will happen immediately on an abortive send or after a graceful send has been acknowledged by the peer. 0-RTT An app can opt in to sending stream data with 0-RTT keys (if available) by including the QUIC_SEND_FLAG_ALLOW_0_RTT flag on StreamSend call. MsQuic doesn't make any guarantees that the data will actually be sent with 0-RTT keys. There are several reasons it may not happen, such as keys not being available, packet loss, flow control, etc. Cancel On Loss In case it is desirable to cancel a stream when packet loss is deteced instead of retransmitting the affected packets, the QUIC_SEND_FLAG_CANCEL_ON_LOSS can be supplied on a StreamSend call. Doing so will irreversibly switch the associated stream to this behavior. This includes every subsequent send call on the same stream, even if the call itself does not include the above flag. If a stream gets canceled because it is in 'cancel on loss' mode, a QUIC_STREAM_EVENT_CANCEL_ON_LOSS event will get emitted. The event allows the app to provide an error code that is communicated to the peer via a QUIC_STREAM_EVENT_PEER_SEND_ABORTED event. Receiving Data is received and delivered to apps via the QUIC_STREAM_EVENT_RECEIVE event. The event indicates zero, one or more contiguous buffers up to the application. When using default settings, the buffer count is 1 the majority of the time, which means that most events will include a single buffer containing the received data. The application can optimize its processing for that case but should be ready to handle any number of QUIC_BUFFERs. When the buffer count is 0, it signifies the reception of a QUIC frame with empty data, which also indicates the end of stream data. Summary - Common handling of receive data events Here is a quick overview of receiving data in some common scenarios. If the application... processes all the received data synchronously in the stream event handler, QUIC_STREAM_EVENT.RECEIVE.TotalBufferLength parameter must be left unchanged and QUIC_STATUS_SUCCESS must be returned from the handler. could process only part of the received buffer synchronously in the stream event handler call and wants to process the remaining data in a subsequent event handler call, it must be indicated to MsQuic by setting this parameter to the byte count processed and returning QUIC_STATUS_CONTINUE from this call. desires to process the received data asynchronously, it should return QUIC_STATUS_PENDING from the event handler call. Read on further for details on all possible scenarios of receiving data using the MsQuic library. Handling a receive event The app then may respond to the event in a number of ways: Synchronous vs Asynchronous The app has the option of either processing the received data in the callback (synchronous) or queuing the work to a separate thread (asynchronous). If the app processes the data synchronously it must do so in a timely manner. Any significant delays will delay other QUIC processing (such as sending acknowledgments), which can cause protocol issues (dropped connections). If the app wants to queue the data to a separate thread, the app must return QUIC_STATUS_PENDING from the receive callback. This informs MsQuic that the app still has an outstanding reference on the buffers, and it will not modify or free them. Once the app is done with the buffers it must call StreamReceiveComplete. The lifetime of the QUIC_BUFFERs themselves is limited to the scope of the callback: when handling the received data asynchronously, the QUIC_BUFFERs must be copied. Partial Data Acceptance Whenever the app gets the QUIC_STREAM_EVENT_RECEIVE event, it can partially accept/consume the received data. For synchronous receives, the app indicates how much of the data it accepted via the TotalBufferLength variable in the payload of the QUIC_STREAM_EVENT_RECEIVE event. On input, that variable indicates the total amount of data being indicated. On output (return from the callback), the variable is taken as how much data the app consumed. By default, if the variable is left unmodified, then all data is assumed to be accepted. For asynchronous receives, the app indicates how much of the data it accepted via the BufferLength parameter passed into the StreamReceiveComplete API. Any value less than or equal to the initial TotalBufferLength value is allowed, including zero. Whenever a receive isn't fully accepted by the app, additional receive events are immediately disabled. The app is assumed to be at capacity and not able to consume more until further indication. To re-enable receive callbacks, the app must call StreamReceiveSetEnabled. There are cases where an app may want to partially accept the current data, but still immediately get a callback with the rest of the data. To do this (only works in the synchronous flow) the app must return QUIC_STATUS_CONTINUE. Receive Modes Options can be used to alter MsQuic default receive notification behavior: Multi-Receive Mode Multi-receive mode is a connection wide option allowing multiple receive notification to be pending simultaneously. It is enabled by setting StreamMultiReceiveEnabled in connection parameters. For streams created when the connection is in Multi-mode receive, MsQuic can keep indicating QUIC_STREAM_EVENT_RECEIVE before the application completes the previous one. This means that the application must be able to handle a new QUIC_STREAM_EVENT_RECEIVE even if it returned QUIC_STATUS_PENDING previously and has not called StreamReceiveComplete yet. MsQuic will also keep indicating receive notifications when the application accepts the data partially. The bytes that have not been accepted by the application won't be indicated again: the application must call StreamReceiveComplete in the future to accept them. To handle multi-receive mode properly, the application must keep track of the total number of bytes received on the stream (the sum of all TotalBufferLength). The number of calls to StreamReceiveComplete does not need to be equal to the number of receive notification, but the total number of bytes completed must eventually be equal to the total number of bytes received. Multi-receive mode manages its internal receive buffer differently and is more efficient for continuous receiving with asynchronous processing. App-Owned Buffer Mode App-owned buffer mode is a per-stream option allowing the application to provide its own receive memory buffers. Enabling app-owned mode is done differently depending on whether the stream is created locally or from the peer and is discussed below. When in app-owned mode, the application can call StreamProvideReceiveBuffers to provide a list of memory buffers to MsQuic. StreamProvideReceiveBuffers can be called at any time on a valid stream in app-owned mode, potentially inline from a notification handler. If called several times, the buffer provided through subsequent calls are added to the list. MsQuic will fill the provided buffer(s) with received data, in the order they have been provided. Receive notifications will be emitted as normal, indicating a list of QUIC_BUFFERs pointing to the application provided buffer(s). Note that up to the number of buffers the application provided can be indicated at once, and that only part of a buffer can be indicated. There is no guarantee the QUIC_BUFFERs indicated in a receive notification will match the ones the application provided. The application is responsible for tracking the amount of data received and when a buffer it provided has been fully used. The application regains full ownership of a buffer after it get a receive notification for all bytes in the buffer and accept them by calling StreamReceiveComplete. If the application accepts all the buffer's bytes inline from the receive notification, by returning QUIC_STATUS_SUCCESS and setting TotalBufferLength appropriately, it can free or reuse the buffer while in the notification handler. If more data is received on the stream than buffer space was provided by the application, MsQuic will emit a QUIC_STREAM_EVENT_RECEIVE_BUFFER_NEEDED notification. When receiving this notification, the app can: provide a sufficient amount of buffer space inline from the callback using StreamProvideReceiveBuffers shutdown the stream receive direction of the stream inline by calling StreamShutdown with the QUIC_STREAM_SHUTDOWN_FLAG_INLINE flag When the callback returns, if the stream has not been shutdown and a sufficient amount of memory is not available, the connection is closed abortively. Providing memory in reaction to QUIC_STREAM_EVENT_RECEIVE_BUFFER_NEEDED can impact performances negatively. For an application, providing receive buffers can improve performances by saving a copy: MsQuic places data directly in its final destination. However, it comes with a large complexity overhead for the application, both in term of memory management and in term of flow control: an application providing too much or too little buffer space could negatively impact performances. Because of this, app-owned mode should be considered an advanced feature and used with caution. Note: As of now, app-owned buffer mode is not compatible with multi-receive mode. If multi-receive mode is enabled for the connection and app-owned mode is enabled on a stream, that specific stream will behave as if multi-receive mode was disabled. This may change in the future. Locally Initiated Streams To use app-owned buffers on a locally created stream, the flag QUIC_STREAM_OPEN_FLAG_APP_OWNED_BUFFERS must be provided to the StreamOpen. Before starting the stream with StreamStart, the application should call StreamProvideReceiveBuffers to provide some initial buffers. Note: This is only relevant for a bidirectional stream, since a locally created unidirectional stream cannot receive data. Peer Initiated Streams To use app-owned buffers on a peer initiated stream, the application must call StreamProvideReceiveBuffers inline when handling the QUIC_CONNECTION_EVENT_PEER_STREAM_STARTED notification. When called inline while handling QUIC_CONNECTION_EVENT_PEER_STREAM_STARTED, StreamProvideReceiveBuffers enables app-owned buffers and provides some initial buffers. This is the only situation where it is allowed to call StreamProvideReceiveBuffers on a stream that is not already in app-owned buffers mode. After this initial call, StreamProvideReceiveBuffers can be called at any time to provide more buffer space, until the stream is closed. Initial Buffer Space As part of the connection establishment, QUIC exchanges initial stream flow control limit as part of the transport parameters, defining the amount of data that each peer will be allowed to send on a newly created stream. An application can define these limits through StreamRecvWindowBidiLocalDefault, StreamRecvWindowBidiRemoteDefault and StreamRecvWindowUnidiDefault in QUIC_SETTINGS. When using a stream in app-owned mode, the application should generally provide enough buffer space to fully contain the initial receive window, since a peer could imediately send that amount of data. MsQuic does not enforce it, and it is legal for an application to provide less buffer space than the initial receive window if it is confident that the amount of buffer provided is large enough to handle all the data sent by the peer. However, if more data is received than can be stored in the buffers provided by the application, the entire connection will be terminated. After the initial receive window is full, flow control will ensure that the peer does not send more data than there is buffer space available. However, the application should still provide enough buffer space to keep flow control from impacting performances. Receive Shutdown The receiver can abortively shutdown a stream receive direction by calling StreamShutdown with the QUIC_STREAM_SHUTDOWN_FLAG_ABORT_RECEIVE option. Closing a Stream Once a stream has been shutdown (in both direction for a bi-directional stream), the application receives a QUIC_STREAM_EVENT_SHUTDOWN_COMPLETE event. The application must then close the stream using StreamClose, and can release its context pointer safely once the call returns. If the app closes a stream before it is shutdown, the stream will be shutdown abortively with an error code of 0. This should be avoided; instead the app should abortively shutdown the stream first with a meaningful error code. It is possible for an application to abortively shutdown a stream and immediately close it from the same thread, without waiting for the QUIC_STREAM_EVENT_SHUTDOWN_COMPLETE event."
  },
  "docs/TEST.html": {
    "href": "docs/TEST.html",
    "title": "Testing MsQuic",
    "summary": "Testing MsQuic Running the Tests First build. If you are trying to run the tests on a different machine from the one where you are building msquic, you can copy artifacts and scripts folders after building msquic over to that machine and run the below steps from there. Running kernel mode msquic and QUIC over XDP tests requires test signing enabled on the machine. It's also more convenient to be done on a machine/VM that's dedicated for testing in case something bugchecks the machine. Prepare the machine: .\\scripts\\prepare-machine.ps1 -ForTest Then all the tests can be run with: ./scripts/test.ps1 Note On Windows, schannel is the default TLS provider, but requires the latest Windows OS versions (Windows Server 2022 or Insider Preview) to function. If you don't have schannel use openssl to build and test. ./scripts/test.ps1 -Tls openssl Windows XDP datapath can be used unless a test explicitly specify loopback address by ./scripts/test.ps1 -UseXdp By default this will run all tests in series, with no log collection. To include log collection for failed tests, run: ./scripts/test.ps1 -LogProfile Full.Light Note On Windows, you will need to run Powershell as Administrator to get the logs. If there are any failed tests, this will generate a directory for each failed test that includes the console output from running the test and any logs collected. Example Output (Windows) PS F:\\msquic> .\\scripts\\test.ps1 [05/24/2021 08:17:35] F:\\msquic\\artifacts\\bin\\windows\\x64_Debug_schannel\\msquiccoretest.exe (208 test case(s)) ... [05/24/2021 08:17:48] 208 test(s) run. [05/24/2021 08:17:48] F:\\msquic\\artifacts\\bin\\windows\\x64_Debug_schannel\\msquicplatformtest.exe (66 test case(s)) ... [05/24/2021 08:17:55] 66 test(s) run. [05/24/2021 08:17:56] F:\\msquic\\artifacts\\bin\\windows\\x64_Debug_schannel\\msquictest.exe (1681 test case(s)) ... [05/24/2021 08:26:58] 1681 test(s) run. [05/24/2021 08:26:58] Output can be found in F:\\msquic\\artifacts\\logs\\msquictest.exe\\05.24.2021.08.17.55 Write-Error: 4 test(s) failed. PowerShell Script Arguments There are a number of other useful arguments for test.ps1. Config <Debug/Release> - The build configuration (default: debug) to test. Must have been built first. Arch <x86/x64/arm/arm64> - The CPU architecture (default: x64) to test. Must have been built first. Tls <openssl/schannel> - The TLS provider to use (Windows default: schannel, Posix default: openssl) to test. Must have been built first. Filter <GoogleTest filter> - A filter for which tests to run. More details here on the syntax. ListTestCases - Lists all the (optionally filtered) tests instead of running them. NoProgress - Don't display progress during test execution. LogProfile <profile> - The profile to use for logging. TODO - Add more here. KeepOutputOnSuccess - Keep logs even if tests pass. Debugger - Run with the debugger attached. InitialBreak - Break in the debugger on initial attach/start. BreakOnFailure - Break into the debugger for any test failures."
  },
  "docs/TLS.html": {
    "href": "docs/TLS.html",
    "title": "MsQuic TLS Abstraction Layer",
    "summary": "MsQuic TLS Abstraction Layer MsQuic includes TLS in the general \"Platform Abstraction Layer\" or PAL. This interface provides all the functionality required of TLS by the QUIC protocol, as defined by the IETF QUIC-TLS spec. High-Level Overview At the TLS abstraction layer there is only one core interface/function that does most all the work: CxPlatTlsProcessData. The ProcessData function takes a number of parameters on input and then provides all the necessary output. The execution of this function drives the TLS state machine. This function executes very similarly to many existing (non-QUIC) TLS APIs with the following exceptions: The TLS record layer is not included. TLS exposes the encryption key material to QUIC to secure its own packets. Generally, the calling pattern for the function starts with the client calling ProcessData with a null input. It then takes the output data, encrypts it accordingly and sends it to the server. The server decrypts it and passes the data to TLS (via its own ProcesData call) and then gets its own output. This goes back and forth until the handshake is complete, and TLS has no other data it needs to exchange. Input The TLS context pointer. The CRYPTO buffer received from the peer. This is null/empty for the client's initial call. Output Any CRYPTO buffer to send to the peer. This may be null/empty. The associated encryption level at which the CRYPTO buffer must be secured. Any new read or write encryption key material. Any other state or meta information, such as negotiated ALPN, handshake completion, session resumption, alerts, etc. Additional Functionality Beyond the core functionality described above, there are a few other functions: QUIC Transport Parameters QUIC has a custom TLS extension it uses on client and server to exchange QUIC specific configuration. The TLS library must support setting and retrieving this information. Session Resumption Tickets When a TLS session is resumed, QUIC is required to use the same QUIC layer configuration previously exchanged in the Transport Parameters. This allows QUIC to do things like apply the appropriate flow control limits to 0-RTT data. In order for this functionality to be achieved at the QUIC layer, the TLS library must allow for QUIC to embed QUIC information in the session resumption ticket (NST) and recall it on session resumption. Implementations MsQuic has a number of implementations for the TLS abstraction layer to support out various platforms and scenarios. Schannel Schannel is officially supported for Windows user mode and Windows kernel mode. It requires the latest Windows versions (Windows Server 2022 or Insider Preview) to function. Only the newest versions support TLS 1.3 and the necessary APIs for QUIC functionality. Currently, 0-RTT is not supported, and resumption is only partially supported. OpenSSL OpenSSL is the primary TLS library by MsQuic on Linux. It is also works on Windows, but Schannel is preferred if supported by your OS build. Important - Currently, OpenSSL doesn't officially have QUIC API support (hopefully coming soon), so MsQuic temporarily relies on a fork of OpenSSL that is purely a fork + a set of (unapproved by OMC) changes to expose some QUIC functionality. This fork is only a stopgap solution until OpenSSL officially supports QUIC, at which MsQuic will immediately switch to it. Detailed Design TO-DO"
  },
  "docs/TaskManagement.html": {
    "href": "docs/TaskManagement.html",
    "title": "MsQuic Task management",
    "summary": "MsQuic Task management Work item states State Mark Other Details Query Example Triage Needed Not in any other state is:issue state:open no:project -label:\"help wanted\" Non-prioritized Work Not in DPT project, help wanted Type, Area is:issue state:open label:\"help wanted\" Backlog In DPT project, no status Type, Area, Priority, T-Shirt size Backlog - DPT Iteration Tracker Current Work In DPT project, Planned/In Progress Type, Area, Priority, T-Shirt size, Iteration, Assignee Breakdown - DPT Iteration Tracker Closed Closed Reason label if not completed (e.g., Cut: NotRepro) Triage Needed Every newly created work items must be triaged to evaluate whether it should be worked on and with which priority. A work item is in the “Triage needed” state by default until it is assigned to another state. Work items are triaged in a regular team triage meeting: the work item is moved to one of the category below common metadata is added: Type (Bug / Task / Feature), Area label (Area: *), Priority (P0 to P3), T-Shirt size (XS to XL)... Help wanted Some work items, while interesting, are not aligned with our priorities. These work items are labeled with help wanted and are not added in the \"DPT Iteration Tracker\" project nor prioritized. If there is interest about addressing these work items, a contribution would be welcome. During triage, these work item should be labeled with help wanted, and receive a type and area labels (Area: *). Backlog The work items the team plans to work on in the future, prioritized and roughly sized. During triage, these work items should be added to the “DPT Iteration tracker” project without a status, and get a type, a priority (P0 to P3), a T-Shirt size (XS to XL), and an area label (Area: *). If relevant, a partner label (Partner: *) should also be added. Current work Work items that have been picked up by the team to be worked on during a specific iteration. During triage/planning, they should get the “Planned” status, an iteration and be assigned to a dev, in addition to what is set to backlog items. When working on the item, the assignee should change the state to “In Progress”, then “Done” to reflect progress. Closed Work items that don’t require additional work are closed. They can be completed or cut. If the work item was not completed, it should be labeled with Cut: * (NotRepro / WontFix/ Duplicate...)."
  },
  "docs/ThreatModel.html": {
    "href": "docs/ThreatModel.html",
    "title": "Threat Model",
    "summary": "Threat Model Overview MsQuic is a library that provides a set of APIs for applications to use for networking based on the QUIC protocol. It operates in the same process as the application and uses UDP sockets and TLS for communication. Threat Surface Bottom Edge (UDP sockets and TLS) MsQuic uses UDP sockets for transport and TLS for security. The threats at this level include: Packet sniffing: An attacker could potentially intercept the packets being sent over the network. Packet tampering or injection: An attacker could potentially modify the packets being sent over the network. Denial of Service (DoS): An attacker could potentially flood the network with traffic, causing legitimate requests to be dropped. Mitigations for the protocol threats include using TLS for encryption to protect against packet sniffing and tampering/injection, and protocol features to protect against DoS attacks. Additionally, to ensure that MsQuic is secure and reliable, we leverage many different types of tests (function, stress and fuzzing) that are regularly run (every commit) in automation. We also leverage static analysis tools and ASAN on both Windows and Linux. Top Edge (In-proc of the calling application) MsQuic runs in the same process as the calling application, for user mode. In the case of kernel mode clients, we also execute in kernel mode. The threats at this level include: Code injection: An attacker could potentially inject malicious code into the process. Data tampering: An attacker could potentially modify the data being sent or received by the application. These are not actually threats to MsQuic, but rather to the application using MsQuic. We are no more priviliged than the calling application. The application should implement its own security measures to protect against these threats, including using the most up-to-date version of MsQuic to keep up with the latest security fixes. Conclusion Because MsQuic is an in-proc library, it does not create any additional attack surfaces that don't already exist in the application. The primary threats are at the network level, and the QUIC protocol uses TLS to mitigate these threats. MsQuic leverages many different types of tests (function, stress and fuzzing) to ensure that it is secure and reliable."
  },
  "docs/TroubleshootingGuide.html": {
    "href": "docs/TroubleshootingGuide.html",
    "title": "Trouble Shooting Guide",
    "summary": "Trouble Shooting Guide This document is meant to be a step-by-step guide for trouble shooting any issues while using MsQuic. What kind of Issue are you having? I am debugging a crash. Something is not functionally working as I expect. Performance is not what I expect it to be. Debugging a Crash TODO Trouble Shooting a Functional Issue MsQuic logging? I am getting an error code I don't understand. The connection is unexpectedly shutting down. The stream is aborted No application (stream) data seems to be flowing. Why is this API failing? An MsQuic API is hanging. I am having problems with SMB over QUIC. No credentials when loading a server certificate from PEM with Schannel. TLS handshake fails in Chrome and Edge for HTTP/3 (including WebTransport) even though HTTP/1.1 and HTTP/2 work. I need to get a packet capture. Logging See Tracing Linux XDP logging? For XDP layer, enable DEBUG flag in src/platform/CMakeLists.txt. You can see incomming packets information by sudo cat /sys/kernel/debug/tracing/trace_pipe. Your workload must become too slow. msquictest-3797496 [005] ..s1. 2079546.776875: bpf_trace_printk: ========> To ifacename : [duo2], RxQueueID:0 msquictest-3797496 [005] ..s1. 2079546.776875: bpf_trace_printk: Eth[244] SRC: 00:00:00:00:00:00 => DST:22:22:22:22:00:02 msquictest-3797496 [005] ..s1. 2079546.776876: bpf_trace_printk: Ipv4 TotalLen:[230] Src: 192.168.1.11 => Dst: 192.168.1.12 msquictest-3797496 [005] ..s1. 2079546.776877: bpf_trace_printk: UDP[202]: SRC: 43829 DST:58141 msquictest-3797496 [005] ..s1. 2079546.776877: bpf_trace_printk: [ec 00 00 00 01 00 09 c0 30 3d 49 a2] msquictest-3797496 [005] ..s1. 2079546.776878: bpf_trace_printk: Redirect to QUIC service. IpMatch:1, PortMatch:1, SocketExists:1, Redirection:4 msquictest-3797496 [005] ..s1. 2079546.777235: bpf_trace_printk: ========> To ifacename : [duo1], RxQueueID:0 msquictest-3797496 [005] ..s1. 2079546.777310: bpf_trace_printk: Eth[1262] SRC: 00:00:00:00:00:00 => DST:22:22:22:22:00:01 msquictest-3797496 [005] ..s1. 2079546.777323: bpf_trace_printk: Ipv4 TotalLen:[1248] Src: 192.168.1.12 => Dst: 192.168.1.11 msquictest-3797496 [005] ..s1. 2079546.777323: bpf_trace_printk: UDP[1220]: SRC: 58141 DST:43829 msquictest-3797496 [005] ..s1. 2079546.777324: bpf_trace_printk: [c0 00 00 00 01 09 c0 30 3d 49 a2 56] msquictest-3797496 [005] ..s1. 2079546.777325: bpf_trace_printk: Redirect to QUIC service. IpMatch:1, PortMatch:1, SocketExists:1, Redirection:4 Understanding Error Codes Some error codes are MsQuic specific (QUIC_STATUS_*), and some are simply a passthrough from the platform. You can find the MsQuic specific error codes in the platform specific header (msquic_posix.h, msquic_winkernel.h, or msquic_winuser.h). From msquic_winuser.h: #define QUIC_STATUS_ADDRESS_IN_USE HRESULT_FROM_WIN32(WSAEADDRINUSE) // 0x80072740 #define QUIC_STATUS_CONNECTION_TIMEOUT ERROR_QUIC_CONNECTION_TIMEOUT // 0x80410006 #define QUIC_STATUS_CONNECTION_IDLE ERROR_QUIC_CONNECTION_IDLE // 0x80410005 #define QUIC_STATUS_UNREACHABLE HRESULT_FROM_WIN32(ERROR_HOST_UNREACHABLE) // 0x800704d0 #define QUIC_STATUS_INTERNAL_ERROR ERROR_QUIC_INTERNAL_ERROR // 0x80410003 For more info, see the Well Known Status Codes. Linux File Handle Limit Too Small In many Linux setups, the default per-process file handle limit is relatively small (~1024). In scenarios where lots of (usually client) connection are opened, a large number of sockets (a type of file handle) are created. Eventually the handle limit is reached and connections start failing (error codes 0x16 or 0xbebc202) because new sockets cannot be created. To fix this, you will need to increase the handle limit. To query the maximum limit you may set: ulimit -Hn To set a new limit (up to the max): ulimit -n newValue Why is the connection shutting down? What does this QUIC_CONNECTION_EVENT_SHUTDOWN_INITIATED_BY_TRANSPORT event mean? What does this QUIC_CONNECTION_EVENT_SHUTDOWN_INITIATED_BY_PEER event mean? Understanding shutdown by Transport. There are two ways for a connection to be shutdown, either by the application layer or by the transport layer (i.e. the QUIC layer). The QUIC_CONNECTION_EVENT_SHUTDOWN_INITIATED_BY_TRANSPORT event occurs when the transport shuts the connection down. Generally, the transport shuts down the connection either when there's some kind of error or if the negotiated idle period has elapsed. [2]6F30.34B0::2021/04/13-09:22:48.297449100 [Microsoft-Quic][conn][0x1CF25AC46B0] Transport Shutdown: 18446744071566327813 (Remote=0) (QS=1) Above is an example event collected during an attempt to connect to a non-existent server. Eventually the connection failed and the transport indicated the event with the appropriate error code. This error code (18446744071566327813) maps to 0xFFFFFFFF80410005, which specifically refers to the QUIC_STATUS (indicated by QS=1) for 0x80410005; which indicates ERROR_QUIC_CONNECTION_IDLE. For more details for understanding error codes see here. Understanding shutdown by Peer. As indicated in Understanding shutdown by Transport, there are two ways for connections to be shutdown. The QUIC_CONNECTION_EVENT_SHUTDOWN_INITIATED_BY_PEER event occurs when the peer application has explicitly shut down the connection. In MsQuic API terms, this would mean the app called ConnectionShutdown. TODO - Add an example event The error code indicated in this event is completely application defined (type of QUIC_UINT62). The transport has no understanding of the meaning of this value. It never generates these error codes itself. So, to map these values to some meaning will require the application protocol documentation. The stream is aborted. Stream abortion is stream terminated abruptly. Remote Stream is aborted by my side? symptom: Peer complains starting stream is failed due to remote abortion. The remote stream maybe aborted locally by Local calls the StreamShutdown with abortive flags Local calls the StreamClose Local calls the ConnectionShutdown Connection callback handler returns the value other than QUIC_STATUS_SUCCESS for event: QUIC_CONNECTION_EVENT_PEER_STREAM_STARTED Why isn't application data flowing? Application data is exchanged via Streams and queued by the app via StreamSend. The act of queuing data doesn't mean it will be immediately sent to the peer. There are a number of things that can block or delay the exchange. The QUIC_FLOW_BLOCK_REASON enum in quic_trace.h contains the full list of reasons that data may be blocked. Below is a short explanation of each: Value Meaning QUIC_FLOW_BLOCKED_SCHEDULING 1 The cross-connection scheduling logic has determined that too much work is queued on the connection to be processed all at once. Generally, this means we are CPU-bound. QUIC_FLOW_BLOCKED_PACING 2 Data burst sizes into the network are being limited and periodically sent into the network based on the congestion control's pacing logic. QUIC_FLOW_BLOCKED_AMPLIFICATION_PROT 4 The peer has not proved ownership of their IP address and therefore we are locally limiting the amount of data to send to it. QUIC_FLOW_BLOCKED_CONGESTION_CONTROL 8 Congestion control has determined that the network cannot handle any more data currently. QUIC_FLOW_BLOCKED_CONN_FLOW_CONTROL 16 The connection-wide limit for the amount of data that can be buffered or accepted by the peer at this time has been reached. QUIC_FLOW_BLOCKED_STREAM_ID_FLOW_CONTROL 32 The limit on the number of streams the peer can accept has been reached. QUIC_FLOW_BLOCKED_STREAM_FLOW_CONTROL 64 The limit on the amount of data that can be buffered or accepted by the peer for this stream has been reached. QUIC_FLOW_BLOCKED_APP 128 All data queued by the application on this stream has been sent. No more data is available to send. Internally, MsQuic tracks these flags at all times for every connection and stream. Whenever any of them change, MsQuic logs an event. For example: [0]0004.0F54::2021/05/14-10:30:22.541024000 [Microsoft-Quic][strm][0xC16BA610] Send Blocked Flags: 128 This event indicates that stream C16BA610 only has the QUIC_FLOW_BLOCKED_APP flag, so it is currently blocked because there is no more application data queued to be sent. The QUIC WPA plugin also supports visualizing these blocked states via the QUIC TX Blocked State graph. It allows you to see what flags are blocking the connection as a whole (shown as stream 0) and what is blocking each individual stream, over the lifetime of the whole connection. For instance, in the image above, you can see the stream (1) is blocked most of the time because there is no application data. Beyond that, the connection (\"stream\" 0) alternated between pacing and congestion control as the blocked reasons. Why is this API Failing? The simplest way to determine exactly why a particular API is failing is via tracing. Collect the traces for the repro and convert them to text and open them in your favorite text editor (try TextAnalysisTool!). MsQuic logs every API entry and exit. Depending on the platform and tool used to decode the traces to text, you may either have the number or an enum represented as the API type (see QUIC_TRACE_API_TYPE in quic_trace.h), but all events look something like this: [cpu][process.thread][time][ api] Enter <API Type> (<pointer>) [cpu][process.thread][time][ api] Exit [optional status code] A TextAnalysisTool filter (api.tat) is also included in ./docs/tat to help quickly find all failed API calls. Example (ListenerStart failing with QUIC_STATUS_INVALID_STATE) In a recent example, we wanted to know why an app occasionally received QUIC_STATUS_INVALID_STATE when it called ListenerStart. We took the following steps to diagnose it. Collected traces for the repro. Converted to text and opened them in TextAnalysisTool. Added a filter for all API enter events for QUIC_TRACE_API_LISTENER_START (10). Looked for the following [ api] Exit event after each enter event on the same [process.thread]. This quickly resulted in the following pair of events. They show the app called ListenerStart for the listener pointer 7f30ac0dcff0 at 09:54:03.528362 in process 2e73 on thread 2e8b (CPU 1). Shortly after, MsQuic returned with status 200000002 (QUIC_STATUS_INVALID_STATE on Posix platforms). [1][2e73.2e8b][09:54:03.528362][ api] Enter 10 (0x7f30ac0dcff0). [1][2e73.2e8b][09:54:03.528913][ api] Exit 200000002 From here, we simply went backwards from the exit event to find any errors; and came up with the full set of important traces: [1][2e73.2e8b][09:54:03.528362][ api] Enter 10 (0x7f30ac0dcff0). [1][2e73.2e8b][09:54:03.528902][bind][0x7f30b80394e0] Listener (0x7f30ac076d90) already registered on ALPN [1][2e73.2e8b][09:54:03.528903][list][0x7f30ac0dcff0] ERROR, \"Register with binding\". [1][2e73.2e8b][09:54:03.528913][ api] Exit 200000002 This clearly shows that listener 7f30ac0dcff0 failed to register with the binding (i.e. UDP socket abstraction) because listener 7f30ac076d90 was already registered for the same ALPN. MsQuic only allows a single listener to be registered for a given ALPN on a local IP address and port. Why is the API hanging or deadlocking? First, a bit of background. The MsQuic API has two types of APIs: Blocking / Synchronous - These APIs run to completion and only return once finished. When running in the Windows kernel, these MUST NOT be called at DISPATCH_LEVEL. They are denoted by the _IRQL_requires_max_(PASSIVE_LEVEL) annotation. For example, ConnectionClose. Nonblocking / Asynchronous - These APIs merely queue work and return immediately. When running in the Windows kernel, these may be called at DISPATCH_LEVEL. They are denoted by the _IRQL_requires_max_(DISPATCH_LEVEL) annotation. For example, StreamSend. Additional documentation on the MsQuic execution model is available here. Now, back to the problem. The app is calling into an MsQuic API and it is hanging and likely deadlocked. This can only happen for synchronous APIs. What do you do next? Generally, this is because the app is breaking one of the following rules: Do not block the MsQuic thread/callback for any length of time. You may acquire a lock/mutex, but you must guarantee very quick execution. Do not grab a lock that you also hold (on a different thread) when calling back into MsQuic. Do not call MsQuic APIs cross-object on MsQuic the thread/callbacks. For instance, if you're in a callback for Connection A, do not call ConnectionClose for Connection B. To verify exactly what is happening, Collect the traces and open then up in a text editor (ideally TextAnalysisTool). The simplest way forward from here is to filter the logs based on the pointer of the object you are calling the API on. For instance, if you are calling ConnectionClose on 0x7fd36c0019c0, then add a filter for 7fd36c0019c0. Here is an example (filtered) log for just such a case: [0][53805.5381b][11:22:52.896762][ api] Enter 13 (0x7fd36c0019c0). [0][53805.53815][11:22:52.896796][conn][0x7fd36c0019c0] Scheduling: 2 [0][53805.53815][11:22:52.896797][conn][0x7fd36c0019c0] Execute: 1 [0][53805.53815][11:22:52.896797][conn][0x7fd36c0019c0] Recv 1 UDP datagrams [0][53805.53815][11:22:52.896825][conn][0x7fd36c0019c0] IN: BytesRecv=2901 [0][53805.53815][11:22:52.896826][conn][0x7fd36c0019c0] Batch Recv 1 UDP datagrams [0][53805.53815][11:22:52.896854][strm][0x7fd378028360] Created, Conn=0x7fd36c0019c0 ID=0 IsLocal=0 [0][53805.53815][11:22:52.896856][conn][0x7fd36c0019c0] Indicating QUIC_CONNECTION_EVENT_PEER_STREAM_STARTED [0x7fd378028360, 0x0] [1][53805.53813][11:22:53.142398][conn][0x7fd36c0019c0] Queuing 1 UDP datagrams [1][53805.53813][11:22:53.392819][conn][0x7fd36c0019c0] Queuing 1 UDP datagrams [1][53805.53813][11:22:53.644259][conn][0x7fd36c0019c0] Queuing 1 UDP datagrams You will notice 3 different threads (seen in [0][53805.X]): 5381b - The app thread that is calling in to close the connection. 53815 - The MsQuic worker thread that drives execution for the connection. 53813 - The MsQuic UDP thread that is processing received packets and queuing them on the connection. As you can see, the last event/log on the MsQuic worker thread was an indication of a QUIC_CONNECTION_EVENT_PEER_STREAM_STARTED event to the app. There are no further events on this thread (easily verified by adding an additional filter for [53805.53815]). So, the app must be blocking this thread. The most likely scenario is that the app is holding a lock while calling ConnectionClose on thread 5381b and then in thread 53815, the app is trying to acquire the same lock. The solution here is that the app must not hold the lock when it calls into the blocking API, if that lock may also be acquired on the MsQuic thread. Trouble Shooting SMB over QUIC issues To troubleshoot any SMB over QUIC issues on windows platforms, the best way is to collect SMB and QUIC traces and sharing it with SMB developers. Following are the steps: Copy msquic/scripts/t.cmd to a local folder. For SMB Client (a.k.a. RDR) WPP traces t.cmd clion // repro and get the relevant error. t.cmd off For SMB Server WPP traces t.cmd srvon // repro and get the relevant error. t.cmd off Share the generated cab file with SMB developers. Convert PEM to PKCS#12 for Schannel When using Schannel, a certificate imported by X509Certificate2.CreateFromPem() in .NET needs to be exported to a byte[] in PKCS#12 (aka PFX) format and re-imported to be used as a server certificate. static X509Certificate2 CreatePkcs12FromPem(string certPem, string keyPem) { using var cert = X509Certificate2.CreateFromPem(certPem, keyPem); return new(cert.Export(X509ContentType.Pkcs12)); } Using a self-signed certificate for HTTP/3 Chromium-based browsers requires the server certificate to be trusted by a default CA for QUIC (e.g. HTTP/3 and WebTransport), even though the same certificate may already be trusted for HTTP/1.1 and HTTP/2. To use a self-signed certificate or a certificate that is not ultimately issued by one of the default CAs, you need to whitelist its SHA-256 hash via the serverCertificateHashes option and follow stricter requirements. See FlyByWireless.CustomCertificate.Generate() on how to generate such a certificate. Collecting a Packet Capture Linux Packet Capture # Capture from any interface, all the udp traffic on the host and write it to the msquic.pcap file tcpdump -i any udp -w msquic.pcap # wireshark to view it. (You need load SSLKEYLOGFILE for the session key to decrypt the session) wireshark ./msquic.pcap Window Packet Capture On Windows, Packet Monitor (pktmon) is the best way to collect a packet capture. The (optional) first step is usually to find the interface you want to collect the capture on. Do this by first running pktmon list: > pktmon list Network Adapters: Id MAC Address Name -- ----------- ---- 9 40-8D-5C-B5-46-51 Intel(R) Ethernet Connection (2) I219-V #2 104 00-15-5D-D1-5A-30 433db3ea-0acd-457a-9c86-55bb7fa27391 80 00-15-5D-AD-8B-40 433db3ea-0acd-457a-9c86-55bb7fa27391 Note If you don't do this and use it to filter to a specific component, you will get a packet capture at every layer, which will include many duplicates of each packet. Once you find the interface you want, take note of the Id. For instance, in the example above, I want to use the Ethernet adapter, so I need 9. Then, to collect the capture for your scenario (example below uses port 443), run the following: pktmon filter remove pktmon filter add -c 9 -t UDP -p 443 pktmon start --capture --pkt-size 0 <run scenario> pktmon stop pktmon etl2pcap pktmon.etl This produced pktmon.pcapng in your current directory that can then be opened by Wireshark. If you want to be able to decrypt the QUIC packets, you will need to get/export the TLS secrets from your code (todo: add link/instructions). Note If you don't specify the component in the filter step, you can specify it at the etl2pcap step: pktmon etl2pcap pktmon.etl -c 9 and it will produce the same final output pcapng file. Trouble Shooting a Performance Issue Is it a problem with just a single (or very few) connection? Is it a problem multiple (lots) of connections? Why is Performance bad for my Connection? Where is the CPU being spent for my connection? What is limiting throughput for my connection? Why is the network limiting throughput for my connection? Analyzing CPU Usage Important - The following is specific to Windows OS. It's extremely common that everything may be functional, but not just as fast as expected. So the normal next step is then to grab a performance trace for the scenario and then dive into the details to analyze what exactly is happening. When you're explicitly looking for where the CPU is spending its time in the scenario, you will need to collect CPU traces. One way to do this is to use WPR (with Stacks.Light profile). Once you have the ETL, open it in WPA (MsQuic plugin is unnecessary). Then, go to the Graph Explorer, expand Computation, expand CPU Usage (Sampled) and open up Utilization by Process, Thread, Stack. The following is an example of a CPU trace a server in a client upload scenario: The next step is to filter things down to only the important information. First, select the relavent time period: click and drag over the area, right click, select Zoom. Then eliminate any unrelated \"noise\". The easiest way is to select all the Processes that have very little weight; then right click, and select Filter Out Selection. Another important thing to filter is the [Idle] stack under the Idle (0) process. Expact the Thread ID column for Idle (0), right click the [Idle] row and then select Filter Out Selection. You should then be left with only the relavent CPU usage. The current view now shows the CPU usage as a fraction of the total available CPU resources. Generally, the total available resources will include multiple (possibly many) different CPUs. So, it's a lot more helpful to get a per-CPU view. To see this, right click the table header (for instance, on Process), expand More Columns ..., and select CPU. Next, drag the CPU column to the front, before Process. Initially, nothing will most likely show up in the graph view. You will need to manually enable the relavent CPUs. In this particular example, only CPUs 4 and 36 have any significant usage (as seen by Count or Weight columns). In the Series list in the graph view, click the boxes next to each relavent CPU series to enable it. You may also chose to explicitly filter out the CPUs that are irrelevant. Now, you could use this view to dig into the various stacks by expanding the rows under the Stack column, but a better way is to change the view to a Flame Graph. Click the icon at the top to Select chart type and change it to Flame. Additionally, check the Enable box under it to enable filtering. You can then slide the filter slider to change the level of filtering. In this example, after resizing the window some, it looks like this: As you will immediately see, <Symbols disabled> shows up everywhere because symbols haven't been loaded. To load them, you will first need to configure the symbol path. You can do this by clicking on Trace in the top and then Configure Symbol Path. Then add any relavent paths to the list and close the window (hit Ok). Next you can load the symbols; Trace -> Load Symbols. This example has just the msquic.dll and secnetperf.exe symbols loaded. You can then drill down to various various part of the flame, and zoom into them by right clicking on them and selecting Filter To Flame. Also, remember you can change the Flame filter slider at any time as well. For example, the following is what filtering to the msquic.dll!QuicWorkerThread flame. Since this flame was essentially all of CPU 4, whatever is taking the most significant CPU resources here can be blamed as the most significant cost of CPU resources. Practically, this comes down to bcrypt.dll. From experience, since this happens in QuicConnRecvDecryptAndAuthenticate this is the work related to decrypting the packet payloads (over 71% of the CPU!). Finding Throughput Bottlenecks TODO Why is Performance bad across all my Connections? UDP receive offload is not working. The work load isn't spreading evenly across cores. Diagnosing Software UDP Receive Offload Issues Important - The following is specific to Windows OS. Software UDP Receive Offload (URO) is an importance performance feature. To check if URO is working correctly, you can follow this guide and use Full.Verbose profile to collect TCPIP traces. In the converted text file, if you see this event, URO is working. The below event indicates UDP layer saw a UDP packet coalesced from 5 UDP packets each with 1000 byte payload. [Microsoft-Windows-TCPIP]UDP: endpoint 0xFFFFA4033FC652C0: URO SCU received. SegCount = 5, SegSize = 1000, DataLength = 5000. If you are not seeing the above event at all, there are several things that can break URO functionality. Global URO Knob URO can be administratively turned off system-wide from a netsh knob. Check by running netsh int udp show global. If Receive Offload State is displayed as disabled, then URO has been administratively disabled. Incompatible Miniport or Medium Take a look at the IP interface rundown traces. Software RSC/URO applicable must be TRUE for URO to work. If it is FALSE, it means the underlying miniport driver is using NDIS 5 or the interface medium is not compatible (e.g. KDNic). [Microsoft-Windows-TCPIP]Framing: interface rundown: Interface = 8, Luid = 0x6008000000000, Address family = 2(IPV4), Compartment = 1, Isolation mode = 0(None), Isolation ID = 0, DL address = 0x00155D563406, Interface type = 6, Physical medium type = 19(NdisPhysicalMediumOther), SW RSC/URO applicable = 0(FALSE), SW RSC enabled = 0(FALSE), Alias = Ethernet (Kernel Debugger). Incompatible Software Component We also have a rundown trace for URO global disabled mask. The mask must be zero for URO to work. It's common that the mask is 2 (0b000010), which means some incompatible WFP callouts have disabled URO. If you see this on a freshly installed machine, try disabling real-time protection from Microsoft Defender settings. It's also possible the mask is 48 (0b110000), which means some incompatible IPSNPI clients have disabled URO. These (winnat or FSE) can automatically get enabled when WSL or Hyper-V are enabled on a machine. [Microsoft-Windows-TCPIP]TCP software RSC global disabled mask = 0, UDP software URO global disabled mask = 0. Incompatible Hardware Feature (PTP Timestamps) Another reason that UDP packets by design will not be coalesced if they carry different PTP timestamps. PTP timestamp is a feature for accurately synchronizing time supported by some NICs and it should be off by default. You can turn off PTP timestamps in NIC properties. Diagnosing RSS Issues Important - The following is specific to Windows OS. For scenarios with lots of parallel connections, generally the work should be spread across all the available processors. But if there are issues with the work not spreading there are a few things you can do. First off, here's an example where the RPS tests were run to a server that should be able to handle near 1 million requests per second: > secnetperf.exe -test:RPS -target:quic-server -conns:250 -requests:7500 -request:0 -response:4096 -runtime:20000 All Connected! Waiting for idle. Start sending request... Started! Result: 25869 RPS, Min: 944, Max: 888078, 50th: 281889.000000, 90th: 369965.000000, 99th: 490582.000000, 99.9th: 574533.000000, 99.99th: 797810.000000, 99.999th: 884055.000000, 99.9999th: 888078.000000, StdErr: 91.224221 App Main returning status 0 As you can see from the output of secnetperf.exe the resulting 25869 RPS is nowhere near what it should be. The next step is to grab a performance trace to see what is going on. For these type of issues the best way to collect the traces would be to use WPR (with Scheduling.Verbose or Performance.Verbose profiles). Once you have the ETL, open it in WPA using the MsQuic plugin. First thing after opening, let's take a look at the QUIC Worker utilization. In the Graph Explorer, under Computation, expand QUIC Workers and open the one labeled Utilization by Worker. For the example above (server-side trace), here is what the output looks like: You can immediately see that only 2 different workers are being used, with worker 2 being used primarily. In depth details - MsQuic always uses at least two workers on the server side for per connection. The first worker is a global, shared worker that is used to do initial validation of the connection request. Its job is to figure out which app the incoming connection belongs to. Once that's complete, the connection will be handed off to that app (and its worker thread(s)). So, this is why you only see usage of worker 1 at the beginning of the trace. The first usage spikes are from the RPS test initially connecting all its (250) parallel connections. There is a bit of back and forth to do the handshakes for these connections. Then there is an idle period while the test waits for things to die down. Finally, the actual RPS tests commense and that is where you see the solid usage of worker 2. Ideally, RPS tests should generate work that is spread across many different workers. The fact that only 1 worker is being used is definitely the source of the low RPS numbers that were measured and indicated in the tool output above. Since MsQuic picks which workers to use based on how the UDP datagrams are received, the next step is to look into the UDP receive layer. One way to do this is by using the Generic Events table (under System Activity in the Graph Explorer). Open that up, and then filter to just MsQuic (also shows up as ff15e657-4f26-570e-88ab-0796b258d11c some times) Provider Name (Right Click -> Filter To Selection). Next, we're looking for specifically the datapath receive events, which are Id 9218. Filter to just those and we see something like this: Now, what we're really interested in is what CPU these events are coming in on. So, add the CPU column to the left of the yellow bar. It doesn't really show a much different picture, but you can clearly see that all events happen on CPU 0. Now, we can clearly see that all our receive events are happening on the same CPU. This definitely not supposed to happen in an environment where RSS should be spreading all the different incoming UDP flows/tuples to different processors. The next step is to take a look at the RSS configuration on the machine to ensure things are properly configured. Run Get-NetAdapterRss to get an output like this: Name : Slot0A x8 InterfaceDescription : Mellanox ConnectX-3 Pro Ethernet Adapter Enabled : True NumberOfReceiveQueues : 8 Profile : Closest BaseProcessor: [Group:Number] : 0:0 MaxProcessor: [Group:Number] : 1:38 MaxProcessors : 8 RssProcessorArray: [Group:Number/NUMA Distance] : 0:0/0 0:2/0 0:4/0 0:6/0 0:8/0 0:10/0 0:12/0 0:14/0 0:16/0 0:18/0 0:20/0 0:22/0 0:24/0 0:26/0 0:28/0 0:30/0 0:32/0 0:34/0 0:36/0 0:38/0 1:0/32767 1:2/32767 1:4/32767 1:6/32767 1:8/32767 1:10/32767 1:12/32767 1:14/32767 1:16/32767 1:18/32767 1:20/32767 1:22/32767 1:24/32767 1:26/32767 1:28/32767 1:30/32767 1:32/32767 1:34/32767 1:36/32767 1:38/32767 IndirectionTable: [Group:Number] : 0:0 0:2 0:4 0:6 0:8 0:10 0:12 0:14 0:0 0:2 0:4 0:6 0:8 0:10 0:12 0:14 0:0 0:2 0:4 0:6 0:8 0:10 0:12 0:14 0:0 0:2 0:4 0:6 0:8 0:10 0:12 0:14 0:0 0:2 0:4 0:6 0:8 0:10 0:12 0:14 0:0 0:2 0:4 0:6 0:8 0:10 0:12 0:14 0:0 0:2 0:4 0:6 0:8 0:10 0:12 0:14 0:0 0:2 0:4 0:6 0:8 0:10 0:12 0:14 0:0 0:2 0:4 0:6 0:8 0:10 0:12 0:14 0:0 0:2 0:4 0:6 0:8 0:10 0:12 0:14 0:0 0:2 0:4 0:6 0:8 0:10 0:12 0:14 0:0 0:2 0:4 0:6 0:8 0:10 0:12 0:14 0:0 0:2 0:4 0:6 0:8 0:10 0:12 0:14 0:0 0:2 0:4 0:6 0:8 0:10 0:12 0:14 0:0 0:2 0:4 0:6 0:8 0:10 0:12 0:14 0:0 0:2 0:4 0:6 0:8 0:10 0:12 0:14 The output above indicates RSS is configured with 8 queues, so there should be spreading of the incoming flows to 8 different CPUs (and then passed to 8 different workers) instead of just the 1 that we are seeing. So, finally, in cases where everything seems to be configured correctly, but things still aren't working, that usually indicates a problem with the network card driver. Make sure the driver is up to date with the latest version available. If that still doesn't fix the problem, you will likely need to contact support from the network card vendor. Analyzing Network Issues TODO Drops on the Receiver Sometimes the issue can actually be the receiver itself, and not the network in between. The problem is that the sender generally cannot distinguish between network drops and receiver drops; even the receiving QUIC layer cannot necessarily identify these drops on its own. On Windows, the OS has a number of performance counters (some seen below) that can be used to analyze packet drops or discards at various layers. TODO - How to use ETW logs to collect even more detailed info on drops by the OS networking stack. TODO - How can you get similar info for Linux? Network Card Discards In some high throughput scenarios, the default number of NIC receive buffers might not be enough to handle spikes in network traffic. When a spike is too large for the NIC to handle, it has to drop the excess packets, resulting in Packet Received Discarded counter increases. When this happens, usually the best way to handle this it to increase the Receive Buffers value in the NIC's Advanced settings (seen below)."
  },
  "docs/Versions.html": {
    "href": "docs/Versions.html",
    "title": "QUIC Versions and Version Negotiation",
    "summary": "QUIC Versions and Version Negotiation The QUIC protocol features a Version field to enable the protocol to evolve and have future versions, multiple of which may be supported by a given implementation. MsQuic is no exception and currently supports Draft-29 and Version 1 of the QUIC protocol. By default, MsQuic clients start all connections with Version 1. MsQuic servers support Version 1 and Draft-29. The Version Negotiation Extension is supported in MsQuic and is keeping pace with changes in the standard. It is enabled by default on both MsQuic client and server. Configuring QUIC Versions on MsQuic Clients An application may decide that it needs a specific feature only availble in one version of QUIC. The application may also wish to change the order of preference of supported version in MsQuic. Both scenarios are supported via the QUIC_VERSION_SETTINGS struct. Since there are three different version lists, the client MUST set all three to be the same. The first version in the list of FullyDeployedVersions will always be the initial version MsQuic starts the connection with. Warning A client may only set a version that MsQuic supports. Any other value will cause SetParam to fail. Use the following code snippet to change the default initial version, and only support a single QUIC version. It must be used before ConnectionStart is called: QUIC_VERSION_SETTINGS Settings = { 0 }; const uint32_t SupportedVersion = 0xff00001dU; // This is the Draft-29 version in HOST byte order. If the server does not support this, the connection will fail. Settings.AcceptableVersionsList = &SupportedVersion; Settings.AcceptableVersionsListLength = 1; Settings.OfferedVersionsList = &SupportedVersion; Settings.OfferedVersionsListLength = 1; Settings.FullyDeployedVersionsList = &SupportedVersion; Settings.FullyDeployedVersionsListLength = 1; MsQuic->SetParam( Connection, QUIC_PARAM_CONN_VERSION_SETTINGS, sizeof(Settings), &Settings); Changing the order of supported versions is the same as above, with the following change: QUIC_VERSION_SETTINGS Settings = { 0 }; const uint32_t SupportedVersions[2] = { 0xff00001dU, // This is the Draft-29 version in HOST byte order. It will be used first. 0x00000001U // QUIC version 1 in HOST byte order. It will be used if a VN packet is received. }; Settings.AcceptableVersionsList = SupportedVersions; Settings.AcceptableVersionsListLength = 2; Settings.OfferedVersionsList = SupportedVersions; Settings.OfferedVersionsListLength = 2; Settings.FullyDeployedVersionsList = SupportedVersions; Settings.FullyDeployedVersionsListLength = 2; The QUIC_VERSION_SETTINGS can be set on a single QUIC_CONNECTION, as well as a QUIC_CONFIGURATION with SetParam. Configuring QUIC Versions on MsQuic Servers A server application may also want to restrict the QUIC versions it supports to ensure a specific feature is available, or to prevent older versions of QUIC from being used. Configuring the QUIC versions on a MsQuic server is similar to configuring them on a client, however, the setting for server MUST be set globally, and not on the QUIC_CONFIGURATION used for the QUIC_LISTENER or QUIC_CONNECTION. If a server is not in a fleet, or the operator/application does not ever need to change QUIC versions, then all three lists in QUIC_VERSION_SETTINGS MUST be the same. If a server is deployed in a fleet, and the server operator wishes to change the supported QUIC versions, the Version Negotiation specification details how that should be done, quoted here: When adding support for a new version: The first step is to progressively add support for the new version to all server instances. This step updates the Acceptable Versions but not the Offered Versions nor the Fully-Deployed Versions. Once all server instances have been updated, operators wait for at least one MSL to allow any in-flight Version Negotiation packets to arrive. Then, the second step is to progressively add the new version to Offered Versions on all server instances. Once complete, operators wait for at least another MSL. Finally, the third step is to progressively add the new version to Fully-Deployed Versions on all server instances. When removing support for a version: The first step is to progressively remove the version from Fully-Deployed Versions on all server instances. Once it has been removed on all server instances, operators wait for at least one MSL to allow any in-flight Version Negotiation packets to arrive. Then, the second step is to progressively remove the version from Offered Versions on all server instances. Once complete, operators wait for at least another MSL. Finally, the third step is to progressively remove support for the version from all server instances. That step updates the Acceptable Versions. Note that this opens connections to version downgrades (but only for partially-deployed versions) during the update window, since those could be due to clients communicating with both updated and non-updated server instances. Configuring Versions via code This snippet should execute before the server's QUIC_CONFIGURATION is created: QUIC_VERSION_SETTINGS Settings = { 0 }; const uint32_t SupportedVersions[2] = { 0xff00001dU, // This is the Draft-29 version in HOST byte order. It will be preferred over Version 1. 0x00000001U // QUIC version 1 in HOST byte order. It will be used if a client starts with Version 1, instead of Draft-29. }; Settings.AcceptableVersionsList = SupportedVersion; Settings.AcceptableVersionsListLength = 2; Settings.OfferedVersionsList = SupportedVersion; Settings.OfferedVersionsListLength = 2; Settings.FullyDeployedVersionsList = SupportedVersion; Settings.FullyDeployedVersionsListLength = 2; MsQuic->SetParam( NULL, QUIC_PARAM_GLOBAL_VERSION_SETTINGS, sizeof(Settings), &Settings); Configuring Versions via Windows Registry MsQuic supports setting the Acceptable Versions, Offered Versions, and Fully-Deployed Versions lists via the Windows registry. These settings are global for all servers and clients on the machine. The registry settings are overridden by settings specified in the code. The registry values must be created under the HKLM\\System\\CurrentControlSet\\Services\\MsQuic\\Parameters key. Each list is stored in the registry as a REG_BINARY type, with the version numbers in little-endian (host) order. The registry value for Acceptable Versions must be named AcceptableVersions. The registry value for Offered Versions must be named OfferedVersions. The registry value for Fully-Deployed Versions must be named FullyDeployedVersions. Here's a sample .reg file that creates all three lists with QUIC version 2 first and QUIC version 1 after, in little endian order, and enables version negotiation: Windows Registry Editor Version 5.00 [HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\MsQuic\\Parameters] \"AcceptableVersions\"=hex:cf,43,33,6b,01,00,00,00 \"OfferedVersions\"=hex:cf,43,33,6b,01,00,00,00 \"FullyDeployedVersions\"=hex:cf,43,33,6b,01,00,00,00 \"VersionNegotiationExtEnabled\"=dword:00000001 QUIC Version Negotiation Extension The Version Negotiation Extension is off by default in our officially-released binaries, but can be enabled via registry or Settings. The Version Negotiated Extension has been standardized and is present in MsQuic since version 2.3. Enabling Version Negotiation Extension on MsQuic Client The Version Negotiation Extension is enabled on client when QUIC_VERSION_SETTINGS are set on the QUIC_CONFIGURATION or QUIC_CONNECTION via SetParam. This setting MUST be set before ConnectionStart to take effect. Enabling Version Negotiation Extension on MsQuic Server Enabling the Version Negotiation Extension on server follows the same restrictions as setting the QUIC version on server, i.e. it MUST be set globally, using SetParam before the QUIC_CONFIGURATION is opened for the server. It is set automatically when QUIC_VERSION_SETTINGS are set, except via registry."
  },
  "docs/api/ConfigurationClose.html": {
    "href": "docs/api/ConfigurationClose.html",
    "title": "ConfigurationClose function",
    "summary": "ConfigurationClose function Deletes an existing security configuration. Syntax typedef _IRQL_requires_max_(PASSIVE_LEVEL) void (QUIC_API * QUIC_CONFIGURATION_CLOSE_FN)( _In_ _Pre_defensive_ __drv_freesMem(Mem) HQUIC Configuration ); Parameters Configuration The valid handle to an open configuration object. Remarks This function releases the configuration object. ConfigurationClose is equivalent to free and MUST be the final call on a configuration handle. Any API calls using a configuration handle after ConfigurationClose has been called is a use-after-free error! See Also ConfigurationOpen ConfigurationLoadCredential"
  },
  "docs/api/ConfigurationLoadCredential.html": {
    "href": "docs/api/ConfigurationLoadCredential.html",
    "title": "ConfigurationLoadCredential function",
    "summary": "ConfigurationLoadCredential function Loads the specified credential configuration for the configuration object. Syntax typedef _IRQL_requires_max_(PASSIVE_LEVEL) QUIC_STATUS (QUIC_API * QUIC_CONFIGURATION_LOAD_CREDENTIAL_FN)( _In_ _Pre_defensive_ HQUIC Configuration, _In_ _Pre_defensive_ const QUIC_CREDENTIAL_CONFIG* CredConfig ); Parameters Configuration The valid handle to an open configuration object. CredConfig The QUIC_CREDENTIAL_CONFIG that describes the security configuration to load for the configuration. Remarks This function loads the security configuration and credentials for the configuration. Depending on the Flags field in the CredConfig (and platform support) the load may be synchronous or asynchronous. If asynchronous, completion is indicated via a callback to the AsyncHandler set on the CredConfig. Once the configuration has been successfully loaded, it can be used for a connection; ConnectionStart on client; ConnectionSetConfiguration on server. See Also ConfigurationOpen ConfigurationClose"
  },
  "docs/api/ConfigurationOpen.html": {
    "href": "docs/api/ConfigurationOpen.html",
    "title": "ConfigurationOpen function",
    "summary": "ConfigurationOpen function Creates a new configuration. Syntax typedef _IRQL_requires_max_(PASSIVE_LEVEL) QUIC_STATUS (QUIC_API * QUIC_CONFIGURATION_OPEN_FN)( _In_ _Pre_defensive_ HQUIC Registration, _In_reads_(AlpnBufferCount) _Pre_defensive_ const QUIC_BUFFER* const AlpnBuffers, _In_range_(>, 0) uint32_t AlpnBufferCount, _In_reads_bytes_opt_(SettingsSize) const QUIC_SETTINGS* Settings, _In_ uint32_t SettingsSize, _In_opt_ void* Context, _Outptr_ _At_(*Configuration, __drv_allocatesMem(Mem)) _Pre_defensive_ HQUIC* Configuration ); Parameters Registration The valid handle to an open registration object. AlpnBuffers An array of QUIC_BUFFER structs that each contain a pointer and length to a different Application Layer Protocol Negotiation (ALPN) buffer. AlpnBufferCount The number of QUIC_BUFFER structs in the AlpnBuffers array. Settings An optional pointer to a QUIC_SETTINGS struct that defines the initial parameters for this configuration. SettingSize The size (in bytes) of the Settings parameter. Context The application context pointer (possibly null) to be associated with the configuration object. Configuration On success, returns a handle to the newly opened configuration object. Return Value The function returns a QUIC_STATUS. The app may use QUIC_FAILED or QUIC_SUCCEEDED to determine if the function failed or succeeded. Remarks On success, ConfigurationOpen creates a new configuration object. A configuration object abstracts all connection settings and security configuration. Once the configuration is loaded (via ConfigurationLoadCredential) it can be used for a connection; ConnectionStart on client; ConnectionSetConfiguration on server. The configuration must be cleaned up via ConfigurationClose when the application is done with it. See Also ConfigurationClose ConfigurationLoadCredential ConnectionSetConfiguration ConnectionStart"
  },
  "docs/api/ConnectionCertificateValidationComplete.html": {
    "href": "docs/api/ConnectionCertificateValidationComplete.html",
    "title": "ConnectionCertificateValidationComplete function",
    "summary": "ConnectionCertificateValidationComplete function Uses the QUIC handle to complete certificate validation. This must be called after the app receives QUIC_CONNECTION_EVENT_PEER_CERTIFICATE_RECEIVED and returns QUIC_STATUS_PENDING. The app should complete certificate validation and call this before the idle timeout and disconnect timeouts occur. Syntax typedef _IRQL_requires_max_(DISPATCH_LEVEL) QUIC_STATUS (QUIC_API * QUIC_CONNECTION_COMP_CERT_FN)( _In_ _Pre_defensive_ HQUIC Connection, _In_ BOOLEAN Result, _In_ QUIC_TLS_ALERT_CODES TlsAlert ); Parameters Connection The valid handle to an open connection object. Result Certificate validation result. Return Value The function returns a QUIC_STATUS. The app may use QUIC_FAILED or QUIC_SUCCEEDED to determine if the function failed or succeeded. Remarks Available from v2.2 See Also ConnectionOpen ConnectionClose ConnectionShutdown"
  },
  "docs/api/ConnectionClose.html": {
    "href": "docs/api/ConnectionClose.html",
    "title": "ConnectionClose function",
    "summary": "ConnectionClose function Closes an existing connection. Syntax typedef _IRQL_requires_max_(PASSIVE_LEVEL) void (QUIC_API * QUIC_CONNECTION_CLOSE_FN)( _In_ _Pre_defensive_ __drv_freesMem(Mem) HQUIC Connection ); Parameters Connection The valid handle to an open connection object. Remarks ConnectionClose cleans up and frees all resources allocated for the connection in ConnectionOpen. A caller should shutdown an active connection via ConnectionShutdown before calling ConnectionClose. Calling ConnectionClose without ConnectionShutdown will abortively and silently shutdown the connection as well as all associated streams through an implicit call to ConnectionShutdown with the QUIC_CONNECTION_SHUTDOWN_FLAG_SILENT flag. A server application MUST NOT call ConnectionClose within the QUIC_LISTENER_EVENT_NEW_CONNECTION callback when returning failure, to reject a connection. This will result in a double-free in release builds, and an assert in debug builds. It's acceptable to call ConnectionClose within the QUIC_LISTENER_EVENT_NEW_CONNECTION callback if returning QUIC_STATUS_SUCCESS, or QUIC_STATUS_PENDING, since the server application owns the connection object then. ConnectionClose is equivalent to free and MUST be the final call on a connection handle. Any API calls using a connection handle after ConnectionClose has been called is a use-after-free error! See Also ConnectionOpen ConnectionShutdown ConnectionStart"
  },
  "docs/api/ConnectionOpen.html": {
    "href": "docs/api/ConnectionOpen.html",
    "title": "ConnectionOpen function",
    "summary": "ConnectionOpen function Creates a new connection. Syntax typedef _IRQL_requires_max_(DISPATCH_LEVEL) QUIC_STATUS (QUIC_API * QUIC_CONNECTION_OPEN_FN)( _In_ _Pre_defensive_ HQUIC Registration, _In_ _Pre_defensive_ QUIC_CONNECTION_CALLBACK_HANDLER Handler, _In_opt_ void* Context, _Outptr_ _At_(*Connection, __drv_allocatesMem(Mem)) _Pre_defensive_ HQUIC* Connection ); Parameters Registration The valid handle to an open registration object. Handler A pointer to the app's callback handler to be invoked for all connection events. Context The app context pointer (possibly null) to be associated with the connection object. Connection On success, returns a handle to the newly opened connection object. Return Value The function returns a QUIC_STATUS. The app may use QUIC_FAILED or QUIC_SUCCEEDED to determine if the function failed or succeeded. Remarks ConnectionOpen is used to create a connection in the client application. In server applications, ListenerOpen and ListenerStart must be called to listen for incoming connection attempts, and the server side Connection is created in the QUIC_LISTENER_EVENT_NEW_CONNECTION event. 'ConnectionOpen' only allocates the resources for the connection, it does not start the connection. To start the connect, the application must call ConnectionStart. Once ConnectionOpen completes successfully, the application may create streams, and queue data for sending. This is when 0-RTT streams and data MUST be created and queued. See StreamOpen, and StreamStart. Once the connection has been shutdown, it must be cleaned up with a call to ConnectionClose. See Also ConnectionOpenInPartition ConnectionClose ConnectionShutdown ConnectionStart QUIC_CONNECTION_CALLBACK QUIC_CONNECTION_EVENT"
  },
  "docs/api/ConnectionOpenInPartition.html": {
    "href": "docs/api/ConnectionOpenInPartition.html",
    "title": "ConnectionOpenInPartition function",
    "summary": "ConnectionOpenInPartition function Creates a new connection in a specific partition. Syntax typedef _IRQL_requires_max_(DISPATCH_LEVEL) QUIC_STATUS (QUIC_API * QUIC_CONNECTION_OPEN_IN_PARTITION_FN)( _In_ _Pre_defensive_ HQUIC Registration, _In_ uint16_t PartitionIndex, _In_ _Pre_defensive_ QUIC_CONNECTION_CALLBACK_HANDLER Handler, _In_opt_ void* Context, _Outptr_ _At_(*Connection, __drv_allocatesMem(Mem)) _Pre_defensive_ HQUIC* Connection ); Parameters Registration The valid handle to an open registration object. PartitionIndex An index into the global partition set. Handler A pointer to the app's callback handler to be invoked for all connection events. Context The app context pointer (possibly null) to be associated with the connection object. Connection On success, returns a handle to the newly opened connection object. Return Value The function returns a QUIC_STATUS. The app may use QUIC_FAILED or QUIC_SUCCEEDED to determine if the function failed or succeeded. Remarks See ConnectionOpen for more remarks. This function is the same as ConnectionOpen with the exception that this puts the connection in an explicit partition instead of inferring it based on the calling thread's current processor. See Also ConnectionOpen ConnectionClose ConnectionShutdown ConnectionStart QUIC_CONNECTION_CALLBACK QUIC_CONNECTION_EVENT"
  },
  "docs/api/ConnectionPoolCreate.html": {
    "href": "docs/api/ConnectionPoolCreate.html",
    "title": "ConnectionPoolCreate function",
    "summary": "ConnectionPoolCreate function Creates a pool of connections spread across RSS cores. Warning This API is still in preview and may change in the future! Important Currently only supported on Windows with XDP. Syntax typedef _IRQL_requires_max_(PASSIVE_LEVEL) _Check_return_ QUIC_STATUS (QUIC_API * QUIC_CONN_POOL_CREATE_FN)( _In_ QUIC_CONNECTION_POOL_CONFIG* Config, _Out_writes_(Config->NumberOfConnections) HQUIC* ConnectionPool ); Parameters Config The configuration parameters for creating the connection pool. See QUIC_CONNECTION_POOL_CONFIG for details. ConnectionPool A pointer to an array that will receive all the connection handles. Must be large enough to hold NumberOfConnections connection handles (HQUICs). Return Value The function returns a QUIC_STATUS. The app may use QUIC_FAILED or QUIC_SUCCEEDED to determine if the function failed or succeeded. Any failure return value could mean the connection pool is partially created. If the flag QUIC_CONNECTION_POOL_FLAG_CLOSE_CONNECTIONS_ON_FAILURE is not set, the caller will need to go through the ConnectionPool array and ConnectionClose() all non-NULL handles. Remarks MsQuic is designed such that a given connection is only processed on a single CPU. Some scenarios need more performance than a single CPU can deliver, and this API is for those scenarios. It creates NumberOfConnections connections and distributes them evenly across the configured RSS CPUs. This ensures received traffic can be processed in parallel as long as the NumberOfConnections is less than the number of configured RSS CPUs. The API accomplishes this in a few steps: Quering the hardware for the RSS configuration information, including the RSS secret key and indirection table. Resolving the ServerName to an address and connecting a socket to acquire a local address and starting port to use in the RSS hashing calculation. Computing the Toeplitz hash of the source/destination addresses and ports using the RSS secret key, to determine which CPU will process a connection. By varying the source port, the API can control which CPU processes a connection. Creating a connection using that local address and port, and starting the connection. If the address+port is in use, find a new port that hashes to the same CPU and try again. The API depends on retrieving the RSS configuration from hardware, which depends on XDP support at this time. An application that can't use this API can perform the same steps as above and achieve the same result. See Also ConnectionOpen ConnectionStart ConnectionShutdown ConnectionClose QUIC_CONNECTION_CALLBACK QUIC_CONNECTION_EVENT QUIC_SETTINGS QUIC_CONNECTION_POOL_CONFIG"
  },
  "docs/api/ConnectionResumptionTicketValidationComplete.html": {
    "href": "docs/api/ConnectionResumptionTicketValidationComplete.html",
    "title": "ConnectionResumptionTicketValidationComplete function",
    "summary": "ConnectionResumptionTicketValidationComplete function Uses the QUIC (server) handle to complete resumption ticket validation. This must be called after server app handles ticket validation and then return QUIC_STATUS_PENDING. Syntax typedef _IRQL_requires_max_(DISPATCH_LEVEL) QUIC_STATUS (QUIC_API * QUIC_CONNECTION_COMP_RESUMPTION_FN)( _In_ _Pre_defensive_ HQUIC Connection, _In_ BOOLEAN Result ); Parameters Connection The valid handle to an open connection object. Result Ticket validation result. Return Value The function returns a QUIC_STATUS. The app may use QUIC_FAILED or QUIC_SUCCEEDED to determine if the function failed or succeeded. Remarks Schannel doesn't support this feature. Available from v2.2 See Also ConnectionOpen ConnectionClose ConnectionShutdown"
  },
  "docs/api/ConnectionSendResumptionTicket.html": {
    "href": "docs/api/ConnectionSendResumptionTicket.html",
    "title": "ConnectionSendResumptionTicket function",
    "summary": "ConnectionSendResumptionTicket function Uses the QUIC (server) handle to send a resumption ticket to the remote client, optionally with app-specific data useful during resumption. Syntax typedef _IRQL_requires_max_(DISPATCH_LEVEL) QUIC_STATUS (QUIC_API * QUIC_CONNECTION_SEND_RESUMPTION_FN)( _In_ _Pre_defensive_ HQUIC Connection, _In_ QUIC_SEND_RESUMPTION_FLAGS Flags, _In_ uint16_t DataLength, _In_reads_bytes_opt_(DataLength) const uint8_t* ResumptionData ); Parameters Connection The valid handle to an open connection object. Flags TODO DataLength TODO ResumptionData TODO Return Value The function returns a QUIC_STATUS. The app may use QUIC_FAILED or QUIC_SUCCEEDED to determine if the function failed or succeeded. Remarks TODO See Also ConnectionOpen ConnectionClose ConnectionShutdown"
  },
  "docs/api/ConnectionSetConfiguration.html": {
    "href": "docs/api/ConnectionSetConfiguration.html",
    "title": "ConnectionSetConfiguration function",
    "summary": "ConnectionSetConfiguration function Sets the (server-side) configuration handle for the connection. This must be called on an accepted connection in order to proceed with the QUIC handshake. Syntax typedef _IRQL_requires_max_(DISPATCH_LEVEL) QUIC_STATUS (QUIC_API * QUIC_CONNECTION_SET_CONFIGURATION_FN)( _In_ _Pre_defensive_ HQUIC Connection, _In_ _Pre_defensive_ HQUIC Configuration ); Parameters Connection The valid handle to an open connection object. Configuration The valid handle to an open and loaded configuration object. Return Value The function returns a QUIC_STATUS. The app may use QUIC_FAILED or QUIC_SUCCEEDED to determine if the function failed or succeeded. Remarks ConnectionSetConfiguration can be called in the QUIC_LISTENER_EVENT_NEW_CONNECTION callback, or outside of it if the connection was accepted. It's generally recommended to call ConnectionSetConfiguration in the QUIC_LISTENER_EVENT_NEW_CONNECTION callback unless the server application needs to do asynchronous processing to decide which configuration to use on a connection. You can use this function to set the ALPN list for the server connection. See Also ConnectionOpen ConnectionClose ConnectionShutdown"
  },
  "docs/api/ConnectionShutdown.html": {
    "href": "docs/api/ConnectionShutdown.html",
    "title": "ConnectionShutdown function",
    "summary": "ConnectionShutdown function Starts the shutdown process on a connection. Syntax typedef _IRQL_requires_max_(DISPATCH_LEVEL) void (QUIC_API * QUIC_CONNECTION_SHUTDOWN_FN)( _In_ _Pre_defensive_ HQUIC Connection, _In_ QUIC_CONNECTION_SHUTDOWN_FLAGS Flags, _In_ _Pre_defensive_ QUIC_UINT62 ErrorCode // Application defined error code ); Parameters Connection The valid handle to an open connection object. Flags The flags that control the behavior of the shutdown. Value Meaning QUIC_CONNECTION_SHUTDOWN_FLAG_NONE 0 The connection is shutdown gracefully and informs the peer. QUIC_CONNECTION_SHUTDOWN_FLAG_SILENT 1 The connection is immediately shutdown without informing the peer. ErrorCode The 62-bit error code to indicate to the peer as the reason for the shutdown. Remarks A client or server application may call ConnectionShutdown on any connections that have successfully called ConnectionStart to shut down the connection. ConnectionShutdown implicitly shuts down any streams that have not already shutdown, but it does not send stop_sending or reset_stream frames for them individually, and only sends a connection_close frame. Stream shutdown events are always delivered to the application for the streams which were implicitly shutdown. ConnectionShutdown is guaranteed to work in low-memory scenarios, though it may be unable to inform the peer if it cannot allocate memory for the final packet containing the connection_close frame. Using the QUIC_CONNECTION_SHUTDOWN_FLAG_SILENT flag instructs MsQuic to tear down the local connection state, but because the peer is not informed, packets may still arrive from the peer until connection idle timeout. These packets are ignored locally, however they may still show up in packet captures. See Also ConnectionOpen ConnectionClose ConnectionStart"
  },
  "docs/api/ConnectionStart.html": {
    "href": "docs/api/ConnectionStart.html",
    "title": "ConnectionStart function",
    "summary": "ConnectionStart function Starts connecting to the server. Syntax typedef _IRQL_requires_max_(PASSIVE_LEVEL) QUIC_STATUS (QUIC_API * QUIC_CONNECTION_START_FN)( _In_ _Pre_defensive_ HQUIC Connection, _In_ _Pre_defensive_ HQUIC Configuration, _In_ QUIC_ADDRESS_FAMILY Family, _In_reads_or_z_opt_(QUIC_MAX_SNI_LENGTH) const char* ServerName, _In_ uint16_t ServerPort // Host byte order ); Parameters Connection The valid handle to an open connection object. Configuration The valid handle to an open and loaded configuration object. Family The address family to use for resolving the IP address of the ServerName parameter. Supported values definitions are supported (The values are platform specific): Value Meaning QUIC_ADDRESS_FAMILY_UNSPEC Unspecified address family. QUIC_ADDRESS_FAMILY_INET Version 4 IP address family. QUIC_ADDRESS_FAMILY_INET6 Version 6 IP address family. ServerName The name of the server to connect to. It may also be an IP literal. ServerPort The UDP port, in host byte order, to connect to on the server. Return Value The function returns a QUIC_STATUS. The app may use QUIC_FAILED or QUIC_SUCCEEDED to determine if the function failed or succeeded. Remarks ConnectionStart initiates the connection from the client application. A server application doesn't start its side of the connection until it returns QUIC_STATUS_SUCCESS from the QUIC_LISTENER_EVENT_NEW_CONNECTION event. No packets are sent until ConnectionStart is called, which starts the handshake, generates the initial cryptographic keys, frames 0-RTT data if present, and then sends the initial flight of packets to the server. Since 0-RTT data is opportunistically sent during the connection handshake, it should be queued for send BEFORE calling ConnectionStart otherwise it may be sent after the handshake. Queueing 0-RTT data after calling ConnectionStart will race with the creation of the inital flight of packets and may not consistently be sent as 0-RTT data. Some settings on the Configuration, and on the Connection, only take effect if set before ConnectionStart is called. See ConfigurationOpen and SetParam for more details about settings. See Also ConnectionOpen ConnectionClose ConnectionShutdown"
  },
  "docs/api/DatagramSend.html": {
    "href": "docs/api/DatagramSend.html",
    "title": "DatagramSend function",
    "summary": "DatagramSend function Queues app data to be sent unreliably in a datagram. Syntax typedef _IRQL_requires_max_(DISPATCH_LEVEL) QUIC_STATUS (QUIC_API * QUIC_DATAGRAM_SEND_FN)( _In_ _Pre_defensive_ HQUIC Connection, _In_reads_(BufferCount) _Pre_defensive_ const QUIC_BUFFER* const Buffers, _In_ uint32_t BufferCount, _In_ QUIC_SEND_FLAGS Flags, _In_opt_ void* ClientSendContext ); Parameters Connection The current established connection. Buffers An array of QUIC_BUFFER structs that each contain a pointer and length to app data to send on the stream. This may be NULL only if BufferCount is zero. BufferCount The number of QUIC_BUFFER structs in the Buffers array. This may be zero. Flags The set of flags that controls the behavior of DatagramSend: Value Meaning QUIC_SEND_FLAG_NONE 0 No special behavior. Data is not allowed in 0-RTT by default. QUIC_SEND_FLAG_ALLOW_0_RTT 1 Indicates that the data is allowed to be sent in 0-RTT (if available). Makes no guarantee the data will be sent in 0-RTT. Additionally, even if 0-RTT keys are available the data may end up being sent in 1-RTT for multiple reasons. QUIC_SEND_FLAG_START 2 Unused and ignored for DatagramSend QUIC_SEND_FLAG_FIN 4 Unused and ignored for DatagramSend QUIC_SEND_FLAG_DGRAM_PRIORITY 8 Sets a priority to ensure a datagram is sent before others. QUIC_SEND_FLAG_DELAY_SEND 16 Unused and ignored for DatagramSend QUIC_SEND_FLAG_CANCEL_ON_LOSS 32 Unused and ignored for DatagramSend QUIC_SEND_FLAG_CANCEL_ON_BLOCKED 64 Allows MsQuic to drop frames when all the data that could be sent has been flushed out, but there are still some frames remaining in the queue. ClientSendContext The app context pointer (possibly null) to be associated with the send. Return Value The function returns a QUIC_STATUS. The app may use QUIC_FAILED or QUIC_SUCCEEDED to determine if the function failed or succeeded. Remarks TODO"
  },
  "docs/api/GetContext.html": {
    "href": "docs/api/GetContext.html",
    "title": "GetContext function",
    "summary": "GetContext function Gets the application context from the API object. Syntax typedef _IRQL_requires_max_(DISPATCH_LEVEL) void* (QUIC_API * QUIC_GET_CONTEXT_FN)( _In_ _Pre_defensive_ HQUIC Handle ); Parameters Handle The valid handle to any API object. This includes handles to registration, configuration, listener, connection and stream objects. Return Value The function returns the previously set application context for the object. Remarks This function allows the app to query the application context it has previously set on the object. Important There is no internal synchronization for this context. If the app calls GetContext, SetContext and/or SetCallbackHandler on different threads, it must provide for the necessary synchronization mechanisms. See Also SetContext SetCallbackHandler"
  },
  "docs/api/GetParam.html": {
    "href": "docs/api/GetParam.html",
    "title": "GetParam function",
    "summary": "GetParam function Gets a parameter from an API object. Syntax typedef _IRQL_requires_max_(PASSIVE_LEVEL) QUIC_STATUS (QUIC_API * QUIC_GET_PARAM_FN)( _When_(QUIC_PARAM_IS_GLOBAL(Param), _Reserved_) _When_(!QUIC_PARAM_IS_GLOBAL(Param), _In_ _Pre_defensive_) HQUIC Handle, _In_ uint32_t Param, _Inout_ _Pre_defensive_ uint32_t* BufferLength, _Out_writes_bytes_opt_(*BufferLength) void* Buffer ); Parameters Handle The valid handle to any API object. This includes handles to registration, configuration, listener, connection and stream objects. For global parameters, this parameter must be NULL. Param The parameter for which the value is to be set (for example, QUIC_PARAM_CONN_IDLE_TIMEOUT). BufferLength The size, in bytes, of the buffer pointed to by the Buffer parameter. Buffer A pointer to the buffer in which the value for the requested parameter is specified. Return Value The function returns a QUIC_STATUS. The app may use QUIC_FAILED or QUIC_SUCCEEDED to determine if the function failed or succeeded. Remarks While many parameters are staticly-sized, some are dynamically-sized and will require the application to do a double call to GetParam: the first to find out the amount of memory needed to allocate, placed in BufferLength, and the second call to actually retrieve the parameter's value. For example, after setting a QUIC_VERSION_SETTINGS on a QUIC_CONFIGURATION, retrieving the settings from the same API object will require a double call to allocate enough storage for the QUIC_VERSION_SETTINGS lists. Sample of double-call: uint32_t SettingsSize = 0; QUIC_VERSION_SETTINGS* Settings = NULL; if (QUIC_STATUS_BUFFER_TOO_SMALL == MsQuic->GetParam( Configuration, QUIC_PARAM_CONFIGURATION_VERSION_SETTINGS, &SettingsSize, Settings)) { Settings = (QUIC_VERSION_SETTINGS*)malloc(SettingsSize); if (QUIC_FAILED( MsQuic->GetParam( Configuration, QUIC_PARAM_CONFIGURATION_VERSION_SETTINGS, &SettingsSize, Settings))) { // Error. } } Special Parameters QUIC_PARAM_GLOBAL_STATISTICS_V2_SIZES Returns an array of well-known sizes (in bytes) for each version of the QUIC_STATISTICS_V2 struct. This allows applications to determine the correct buffer size for statistics queries, even as new versions are added in future MsQuic releases. Note - Most applications should not leverage this and instead directly call to query the QUIC_STATISTICS_V2. This API is only necessary for layers on top of MsQuic that need to pass through this information to additional layers on top of them. Type: uint32_t[] (array of struct sizes) Get-only Variable-length: The number of sizes returned may change in future versions. The caller should pass a buffer of uint32_t and use the double-call pattern to determine the required buffer size. Sample usage: uint32_t Sizes[8]; // Large enough for future growth uint32_t BufferLength = sizeof(Sizes); QUIC_STATUS Status = MsQuic->GetParam( NULL, QUIC_PARAM_GLOBAL_STATISTICS_V2_SIZES, &BufferLength, Sizes); if (Status == QUIC_STATUS_BUFFER_TOO_SMALL) { // BufferLength is set to required size (in bytes) // Allocate a larger buffer and call again } uint32_t NumSizes = BufferLength / sizeof(uint32_t); // Sizes[0..NumSizes-1] now contains the struct sizes for each version See also: Settings.md See Also Settings SetParam"
  },
  "docs/api/ListenerClose.html": {
    "href": "docs/api/ListenerClose.html",
    "title": "ListenerClose function",
    "summary": "ListenerClose function Closes an existing listener. Syntax typedef _IRQL_requires_max_(PASSIVE_LEVEL) void (QUIC_API * QUIC_LISTENER_CLOSE_FN)( _In_ _Pre_defensive_ __drv_freesMem(Mem) HQUIC Listener ); Parameters Listener A valid handle to an open listener object. Remarks ListenerClose frees all allocated resources associated with the listener handle. If a listener has not had ListenerStop called on it at the time ListenerClose is called, ListenerStop is invoked internally. A call to ListenerClose is blocking: a server application MUST NOT call ListenerClose within any callback, unless it received the QUIC_LISTENER_EVENT_STOP_COMPLETE event, previously or as the current event. Calling ListenerClose in a callback before the QUIC_LISTENER_EVENT_STOP_COMPLETE event may cause a deadlock. ListenerClose is equivalent to free and MUST be the final call on a listener handle. Any API calls using a listener handle after ListenerClose has been called is a use-after-free error! See Also ListenerOpen ListenerStart ListenerStop"
  },
  "docs/api/ListenerOpen.html": {
    "href": "docs/api/ListenerOpen.html",
    "title": "ListenerOpen function",
    "summary": "ListenerOpen function Creates a new listener. Syntax typedef _IRQL_requires_max_(PASSIVE_LEVEL) QUIC_STATUS (QUIC_API * QUIC_LISTENER_OPEN_FN)( _In_ _Pre_defensive_ HQUIC Registration, _In_ _Pre_defensive_ QUIC_LISTENER_CALLBACK_HANDLER Handler, _In_opt_ void* Context, _Outptr_ _At_(*Listener, __drv_allocatesMem(Mem)) _Pre_defensive_ HQUIC* Listener ); Parameters Registration The valid handle to an open registration object. Handler A pointer to the app's callback handler to be invoked for all listener events. Context The app context pointer (possibly null) to be associated with the listener object. Listener On success, returns a handle to the newly opened listener object. Return Value The function returns a QUIC_STATUS. The app may use QUIC_FAILED or QUIC_SUCCEEDED to determine if the function failed or succeeded. Remarks ListenerOpen is used to allocate resources for a server application to listen for QUIC connections. The server doesn't start listening for connection attempts until ListenerStart is successfully called. For a client application, ConnectionOpen is called to create a new connection, and ConnectionStart to start that new connection. The application may call ListenerStart and ListenerStop multiple times over the lifetime of a listener object, if it needs to start and stop listening for connections. Most server applications will call ListenerStart once at start up, and then ListenerStop at shutdown. Every listener created with a call to ListenerOpen MUST be cleaned up with a call to ListenerClose, otherwise a memory leak will occur. See Also ListenerClose ListenerStart ListenerStop"
  },
  "docs/api/ListenerStart.html": {
    "href": "docs/api/ListenerStart.html",
    "title": "ListenerStart function",
    "summary": "ListenerStart function Starts listening for incoming connection requests. Syntax typedef _IRQL_requires_max_(PASSIVE_LEVEL) QUIC_STATUS (QUIC_API * QUIC_LISTENER_START_FN)( _In_ _Pre_defensive_ HQUIC Listener, _In_reads_(AlpnBufferCount) _Pre_defensive_ const QUIC_BUFFER* const AlpnBuffers, _In_range_(>, 0) uint32_t AlpnBufferCount, _In_opt_ const QUIC_ADDR* LocalAddress ); Parameters Listener A valid handle to an open listener object. AlpnBuffers An array of QUIC_BUFFER structs that each contain a pointer and length to a different Application Layer Protocol Negotiation (ALPN) buffer, in order of preference, to be negotiated by the incoming connections. AlpnBufferCount The number of QUIC_BUFFER structs in AlpnBuffers. LocalAddress Optional pointer to a QUIC_ADDR to indicate the address and/or port to listen for connections on. May be NULL to let the networking stack choose. Return Value The function returns a QUIC_STATUS. The app may use QUIC_FAILED or QUIC_SUCCEEDED to determine if the function failed or succeeded. Remarks ListenerStart starts listening for incoming connections and callbacks on the listener may begin before the function call returns. Connection attempts that are received are indicated via QUIC_LISTENER_EVENT_NEW_CONNECTION event to the server application. The server application indicates acceptance of the connection attempt by calling SetCallbackHandler on the connection object, and returning QUIC_STATUS_SUCCESS from the QUIC_LISTENER_EVENT_NEW_CONNECTION callback. The server application must call ConnectionSetConfiguration on the connection, either before returning from the QUIC_LISTENER_EVENT_NEW_CONNECTION callback, or on its own after returning from the callback, otherwise the connection handshake will stall and timeout. After returning QUIC_STATUS_SUCCESS from the QUIC_LISTENER_EVENT_NEW_CONNECTION callback, the server application owns the connection object and must eventually call ConnectionClose on it, otherwise a memory leak will occur. The server application MUST NOT call ConnectionClose within the QUIC_LISTENER_EVENT_NEW_CONNECTION callback when returning failure, to reject a connection. This will result in a double-free in release builds, and an assert in debug builds. It's acceptable to call ConnectionClose within the QUIC_LISTENER_EVENT_NEW_CONNECTION callback if returning QUIC_STATUS_SUCCESS, or QUIC_STATUS_PENDING, since the server application owns the connection object then. ALPNs specified in AlpnBuffers must be less than 255 bytes in length. The server application may set any combination of local address and/or port number in the QUIC_ADDR pointed to by LocalAddress. If no port number is given, then the networking stack will choose an available port number, which can be queried by GetParam with QUIC_PARAM_LISTENER_LOCAL_ADDRESS. MsQuic listens on dual-mode wildcard sockets for each unique port number, and performs address filtering, if necessary, within the QUIC layer. Due to the use of per processor sockets for performance reasons, 2 distinct processes listening on the same port will not result in the 2nd instance failing to start. The behavior in this case is undefined, and different per platform, but will result in each app not getting the receives it expects. There is potential for a future workaround for this on Windows, but no currently known solution on Posix-based platforms. This quirk does not apply if a process using UDP without MsQuic is already bound to the port, as long as that process is not using per processor sockets. On Posix-based platforms, 2 distinct processes using wildcard port numbers can potentially receive the same port number, resulting in the above behavior. This behavior does not exist on Windows. See Also ListenerOpen ListenerClose ListenerStop"
  },
  "docs/api/ListenerStop.html": {
    "href": "docs/api/ListenerStop.html",
    "title": "ListenerStop function",
    "summary": "ListenerStop function Stops listening for incoming connection requests. Syntax typedef _IRQL_requires_max_(PASSIVE_LEVEL) void (QUIC_API * QUIC_LISTENER_STOP_FN)( _In_ _Pre_defensive_ HQUIC Listener ); Parameters Listener A valid handle to an open, and started, listener object. Remarks ListenerStop is called when the server application wants to stop receiving new incoming connections. It is an asynchronous call. When the stop operation is complete the QUIC_LISTENER_EVENT_STOP_COMPLETE event will be delivered to the application. The server may call ListenerStop in any callback. If the server application wishes to resume receiving new connections, it may call ListenerStart on the same listener, again. See Also ListenerOpen ListenerClose ListenerStart"
  },
  "docs/api/MsQuicClose.html": {
    "href": "docs/api/MsQuicClose.html",
    "title": "MsQuicClose function",
    "summary": "MsQuicClose function Closes an existing handle to the MsQuic library, releasing the reference on the library and freeing the function table. Syntax _IRQL_requires_max_(PASSIVE_LEVEL) _Pre_defensive_ void QUIC_API MsQuicClose( _In_ const void* QuicApi ); Parameters QuicApi The function table from a previous call to MsQuicOpenVersion. Remarks This function must be called when the app is done with the MsQuic library. MsQuicClose and MsQuicOpenVersion are not thread-safe if the caller is statically linking MsQuic, and therefore must not be called in parallel. See Also MsQuicOpenVersion"
  },
  "docs/api/MsQuicOpen2.html": {
    "href": "docs/api/MsQuicOpen2.html",
    "title": "MsQuicOpen2 function",
    "summary": "MsQuicOpen2 function A simple helper inline function (or macro in C on Linux) that wraps MsQuicOpenVersion to open a version 2 API table."
  },
  "docs/api/MsQuicOpenVersion.html": {
    "href": "docs/api/MsQuicOpenVersion.html",
    "title": "MsQuicOpenVersion function",
    "summary": "MsQuicOpenVersion function Opens a new handle to the MsQuic library and returns a version specific API table. Syntax _IRQL_requires_max_(PASSIVE_LEVEL) _Pre_defensive_ QUIC_STATUS QUIC_API MsQuicOpenVersion( _In_ uint32_t Version, _Out_ const QUIC_API_TABLE** QuicApi ); Parameters Version The API Version to use. QuicApi On success, returns a pointer to the API function table. Return Value The function returns a QUIC_STATUS. The app may use QUIC_FAILED or QUIC_SUCCEEDED to determine if the function failed or succeeded. Remarks This function is the entry point for the MsQuic API. This function may be called multiple times to get multiple new function tables, but this is generally unnecessary. An app should only need call this once. A single QuicApi may be shared and safely used by multiple callers on parallel threads. For every successful call to MsQuicOpenVersion the app must call MsQuicClose, passing in the function table from QuicApi when the app is done with it. Calls to MsQuicOpenVersion and MsQuicClose increment and decrement reference counts on the library. The addition of the first reference count initializes the global state and the removal of the last reference count cleans up the global state. Since both of these operations are not light weight it's highly recommended that an app does not open and close very frequently. MsQuicOpenVersion may dynamically load other dependencies, so it must not be called from DllMain on Windows. MsQuicOpenVersion takes a version number to indicate which version of the API to use. Newer versions of the library will support older versions of the API for binary compatibility. The MsQuicOpen2 definition in msquic.h now forwards to MsQuicOpenVersion MsQuicOpenVersion and MsQuicClose are not thread-safe if the caller is statically linking MsQuic, and therefore must not be called in parallel. See Also MsQuicClose QUIC_API_TABLE"
  },
  "docs/api/QUIC_API_TABLE.html": {
    "href": "docs/api/QUIC_API_TABLE.html",
    "title": "QUIC_API_TABLE structure",
    "summary": "QUIC_API_TABLE structure The function table for all MsQuic APIs. Syntax typedef struct QUIC_API_TABLE { QUIC_SET_CONTEXT_FN SetContext; QUIC_GET_CONTEXT_FN GetContext; QUIC_SET_CALLBACK_HANDLER_FN SetCallbackHandler; QUIC_SET_PARAM_FN SetParam; QUIC_GET_PARAM_FN GetParam; QUIC_REGISTRATION_OPEN_FN RegistrationOpen; QUIC_REGISTRATION_CLOSE_FN RegistrationClose; QUIC_REGISTRATION_SHUTDOWN_FN RegistrationShutdown; QUIC_CONFIGURATION_OPEN_FN ConfigurationOpen; QUIC_CONFIGURATION_CLOSE_FN ConfigurationClose; QUIC_CONFIGURATION_LOAD_CREDENTIAL_FN ConfigurationLoadCredential; QUIC_LISTENER_OPEN_FN ListenerOpen; QUIC_LISTENER_CLOSE_FN ListenerClose; QUIC_LISTENER_START_FN ListenerStart; QUIC_LISTENER_STOP_FN ListenerStop; QUIC_CONNECTION_OPEN_FN ConnectionOpen; QUIC_CONNECTION_CLOSE_FN ConnectionClose; QUIC_CONNECTION_SHUTDOWN_FN ConnectionShutdown; QUIC_CONNECTION_START_FN ConnectionStart; QUIC_CONNECTION_SET_CONFIGURATION_FN ConnectionSetConfiguration; QUIC_CONNECTION_SEND_RESUMPTION_FN ConnectionSendResumptionTicket; QUIC_STREAM_OPEN_FN StreamOpen; QUIC_STREAM_CLOSE_FN StreamClose; QUIC_STREAM_START_FN StreamStart; QUIC_STREAM_SHUTDOWN_FN StreamShutdown; QUIC_STREAM_SEND_FN StreamSend; QUIC_STREAM_RECEIVE_COMPLETE_FN StreamReceiveComplete; QUIC_STREAM_RECEIVE_SET_ENABLED_FN StreamReceiveSetEnabled; QUIC_DATAGRAM_SEND_FN DatagramSend; } QUIC_API_TABLE; Members SetContext See SetContext GetContext See GetContext SetCallbackHandler See SetCallbackHandler SetParam See SetParam GetParam See GetParam RegistrationOpen See RegistrationOpen RegistrationClose See RegistrationClose RegistrationClose2 See (Preview) RegistrationClose2 RegistrationShutdown See RegistrationShutdown ConfigurationOpen See ConfigurationOpen ConfigurationClose See ConfigurationClose ConfigurationLoadCredential See ConfigurationLoadCredential ListenerOpen See ListenerOpen ListenerClose See ListenerClose ListenerStart See ListenerStart ListenerStop See ListenerStop ConnectionOpen See ConnectionOpen ConnectionClose See ConnectionClose ConnectionShutdown See ConnectionShutdown ConnectionStart See ConnectionStart ConnectionSetConfiguration See ConnectionSetConfiguration ConnectionSendResumptionTicket See ConnectionSendResumptionTicket StreamOpen See StreamOpen StreamClose See StreamClose StreamStart See StreamStart StreamShutdown See StreamShutdown StreamSend See StreamSend StreamReceiveComplete See StreamReceiveComplete StreamReceiveSetEnabled See StreamReceiveSetEnabled DatagramSend See DatagramSend See Also MsQuicOpen2"
  },
  "docs/api/QUIC_CONNECTION_CALLBACK.html": {
    "href": "docs/api/QUIC_CONNECTION_CALLBACK.html",
    "title": "QUIC_CONNECTION_CALLBACK function pointer",
    "summary": "QUIC_CONNECTION_CALLBACK function pointer Handles connection events. Syntax typedef _IRQL_requires_max_(PASSIVE_LEVEL) _Function_class_(QUIC_CONNECTION_CALLBACK) QUIC_STATUS (QUIC_API QUIC_CONNECTION_CALLBACK)( _In_ HQUIC Connection, _In_opt_ void* Context, _Inout_ QUIC_CONNECTION_EVENT* Event ); Parameters Connection The valid handle to the connection object this event is for. Context The application callback context (optionally) supplied in ConnectionOpen, SetCallbackHandler or SetContext. Event A pointer to the QUIC_CONNECTION_EVENT payload. Remarks This function pointer handles callbacks from MsQuic for connection events. Apps are expected to keep any execution time in the callback to a minimum. See Also ConnectionOpen QUIC_CONNECTION_EVENT SetCallbackHandler SetContext"
  },
  "docs/api/QUIC_CONNECTION_EVENT.html": {
    "href": "docs/api/QUIC_CONNECTION_EVENT.html",
    "title": "QUIC_CONNECTION_EVENT structure",
    "summary": "QUIC_CONNECTION_EVENT structure QUIC connection events and the corresponding payload Syntax typedef enum QUIC_CONNECTION_EVENT_TYPE { QUIC_CONNECTION_EVENT_CONNECTED = 0, QUIC_CONNECTION_EVENT_SHUTDOWN_INITIATED_BY_TRANSPORT = 1, // The transport started the shutdown process. QUIC_CONNECTION_EVENT_SHUTDOWN_INITIATED_BY_PEER = 2, // The peer application started the shutdown process. QUIC_CONNECTION_EVENT_SHUTDOWN_COMPLETE = 3, // Ready for the handle to be closed. QUIC_CONNECTION_EVENT_LOCAL_ADDRESS_CHANGED = 4, QUIC_CONNECTION_EVENT_PEER_ADDRESS_CHANGED = 5, QUIC_CONNECTION_EVENT_PEER_STREAM_STARTED = 6, QUIC_CONNECTION_EVENT_STREAMS_AVAILABLE = 7, QUIC_CONNECTION_EVENT_PEER_NEEDS_STREAMS = 8, QUIC_CONNECTION_EVENT_IDEAL_PROCESSOR_CHANGED = 9, QUIC_CONNECTION_EVENT_DATAGRAM_STATE_CHANGED = 10, QUIC_CONNECTION_EVENT_DATAGRAM_RECEIVED = 11, QUIC_CONNECTION_EVENT_DATAGRAM_SEND_STATE_CHANGED = 12, QUIC_CONNECTION_EVENT_RESUMED = 13, // Server-only; provides resumption data, if any. QUIC_CONNECTION_EVENT_RESUMPTION_TICKET_RECEIVED = 14, // Client-only; provides ticket to persist, if any. QUIC_CONNECTION_EVENT_PEER_CERTIFICATE_RECEIVED = 15 // Only with QUIC_CREDENTIAL_FLAG_INDICATE_CERTIFICATE_RECEIVED set #ifdef QUIC_API_ENABLE_PREVIEW_FEATURES QUIC_CONNECTION_EVENT_RELIABLE_RESET_NEGOTIATED = 16, // Only indicated if QUIC_SETTINGS.ReliableResetEnabled is TRUE. QUIC_CONNECTION_EVENT_ONE_WAY_DELAY_NEGOTIATED = 17, // Only indicated if QUIC_SETTINGS.OneWayDelayEnabled is TRUE. QUIC_CONNECTION_EVENT_NETWORK_STATISTICS = 18, // Only indicated if QUIC_SETTINGS.EnableNetStatsEvent is TRUE. #endif } QUIC_CONNECTION_EVENT_TYPE; The payload for QUIC connection events. typedef struct QUIC_CONNECTION_EVENT { QUIC_CONNECTION_EVENT_TYPE Type; union { struct { BOOLEAN SessionResumed; _Field_range_(>, 0) uint8_t NegotiatedAlpnLength; _Field_size_(NegotiatedAlpnLength) const uint8_t* NegotiatedAlpn; } CONNECTED; struct { QUIC_STATUS Status; QUIC_UINT62 ErrorCode; // Wire format error code. } SHUTDOWN_INITIATED_BY_TRANSPORT; struct { QUIC_UINT62 ErrorCode; } SHUTDOWN_INITIATED_BY_PEER; struct { BOOLEAN HandshakeCompleted : 1; BOOLEAN PeerAcknowledgedShutdown : 1; BOOLEAN AppCloseInProgress : 1; } SHUTDOWN_COMPLETE; struct { const QUIC_ADDR* Address; } LOCAL_ADDRESS_CHANGED; struct { const QUIC_ADDR* Address; } PEER_ADDRESS_CHANGED; struct { HQUIC Stream; QUIC_STREAM_OPEN_FLAGS Flags; } PEER_STREAM_STARTED; struct { uint16_t BidirectionalCount; uint16_t UnidirectionalCount; } STREAMS_AVAILABLE; struct { uint16_t IdealProcessor; } IDEAL_PROCESSOR_CHANGED; struct { BOOLEAN SendEnabled; uint16_t MaxSendLength; } DATAGRAM_STATE_CHANGED; struct { const QUIC_BUFFER* Buffer; QUIC_RECEIVE_FLAGS Flags; } DATAGRAM_RECEIVED; struct { /* inout */ void* ClientContext; QUIC_DATAGRAM_SEND_STATE State; } DATAGRAM_SEND_STATE_CHANGED; struct { uint16_t ResumptionStateLength; const uint8_t* ResumptionState; } RESUMED; struct { _Field_range_(>, 0) uint32_t ResumptionTicketLength; _Field_size_(ResumptionTicketLength) const uint8_t* ResumptionTicket; } RESUMPTION_TICKET_RECEIVED; struct { QUIC_CERTIFICATE* Certificate; uint32_t DeferredErrorFlags; QUIC_STATUS DeferredStatus; QUIC_CERTIFICATE_CHAIN* Chain; } PEER_CERTIFICATE_RECEIVED; #ifdef QUIC_API_ENABLE_PREVIEW_FEATURES struct { BOOLEAN IsNegotiated; } RELIABLE_RESET_NEGOTIATED; struct { BOOLEAN SendNegotiated; // TRUE if sending one-way delay timestamps is negotiated. BOOLEAN ReceiveNegotiated; // TRUE if receiving one-way delay timestamps is negotiated. } ONE_WAY_DELAY_NEGOTIATED; QUIC_NETWORK_STATISTICS NETWORK_STATISTICS; #endif }; } QUIC_CONNECTION_EVENT; Parameters Type The QUIC_CONNECTION_EVENT_TYPE that indicates which type of event this is, and which payload to reference (if any) for additional information. Remarks QUIC_CONNECTION_EVENT_CONNECTED This event is delivered when the handshake has completed. This means the peer has been securely authenticated. This happens after one full round trip on the client side. The server side considers the handshake complete once the client responds after this. Connected Additional state can be found in the CONNECTED struct/union. SessionResumed A flag that indicates if a previous TLS session was successfully resumed. NegotiatedAlpnLength The length of the NegotiatedAlpn field. NegotiatedAlpn The buffer (not null terminated) that holds the ALPN that was negotiated during the handshake. QUIC_CONNECTION_EVENT_SHUTDOWN_INITIATED_BY_TRANSPORT This event is delivered whenever the transport (e.g. QUIC layer) determines the connection has been terminated. This can happen for a number of different reasons. Some are as follows. The handshake failed (any number of reasons). The connection was idle for long enough. The connection disconnected (lost contact with peer; no acknowledgments). The connection encountered a protocol violation. SHUTDOWN_INITIATED_BY_TRANSPORT Additional status can be found in the SHUTDOWN_INITIATED_BY_TRANSPORT struct/union. Status The platform status code that indicates the reason for the shutdown. ErrorCode The wire format error code that indicates the reason for the shutdown. QUIC_CONNECTION_EVENT_SHUTDOWN_INITIATED_BY_PEER This event is delivered when the peer application has terminated the application, with an application's protocol specific, 62-bit error code. SHUTDOWN_INITIATED_BY_PEER Error code is found in the SHUTDOWN_INITIATED_BY_PEER struct/union. ErrorCode The error code received from the peer for the shutdown. QUIC_CONNECTION_EVENT_SHUTDOWN_COMPLETE This event is the last one delivered to the application, and indicates the connection may now be safely closed. SHUTDOWN_COMPLETE Various state flags are contained in the SHUTDOWN_COMPLETE struct/union. HandshakeCompleted A flag indicating if the QUIC handshake completed before the connection was shutdown. PeerAcknowledgedShutdown A flag indicating if the peer explicitly acknowledged the connection shutdown. AppCloseInProgress A flag indicating that the application called ConnectionClose on this connection. QUIC_CONNECTION_EVENT_LOCAL_ADDRESS_CHANGED This event is delivered when the local address used for the primary/active path communication has changed. LOCAL_ADDRESS_CHANGED New local address is passed in the LOCAL_ADDRESS_CHANGED struct/union. Address The new local IP address. QUIC_CONNECTION_EVENT_PEER_ADDRESS_CHANGED This event is delivered when the remote address used for the primary/active path communication has changed. PEER_ADDRESS_CHANGED New peer ip address is passed in the PEER_ADDRESS_CHANGED struct/union. Address The new peer IP address. QUIC_CONNECTION_EVENT_PEER_STREAM_STARTED This event is delivered when the peer has created a new stream. PEER_STREAM_STARTED Details of the new stream are passed in the PEER_STREAM_STARTED struct/union. Stream A handle to the newly peer-created stream. Flags A set of flags indicating describing the newly opened stream: Value Meaning QUIC_STREAM_OPEN_FLAG_NONE 0 No special behavior. Defaults to bidirectional stream. QUIC_STREAM_OPEN_FLAG_UNIDIRECTIONAL 1 A unidirectional stream. QUIC_STREAM_OPEN_FLAG_0_RTT 2 The stream was received in 0-RTT. If a server wishes to use QUIC_STREAM_OPEN_FLAG_DELAY_ID_FC_UPDATES for the newly started stream, it may append this flag to Flags before it returns from the callback. QUIC_CONNECTION_EVENT_STREAMS_AVAILABLE This event indicates the number of streams the peer is willing to accept has changed. STREAMS_AVAILABLE New stream counts are passed in the STREAMS_AVAILABLE struct/union. BidirectionalCount The number of bidirectional streams the peer is willing to accept. UnidirectionalCount The number of unidirectional streams the peer is willing to accept. QUIC_CONNECTION_EVENT_PEER_NEEDS_STREAMS This event indicates the peer is currently blocked on the number of parallel streams the app has configured it is willing to accept. QUIC_CONNECTION_EVENT_IDEAL_PROCESSOR_CHANGED This event indicates the processor or CPU that MsQuic has determined would be the best for processing the given connection. IDEAL_PROCESSOR_CHANGED The new processor number is passed in the IDEAL_PROCESSOR_CHANGED struct/union. IdealProcessor The processor number that should be ideally used for processing the connection. QUIC_CONNECTION_EVENT_DATAGRAM_STATE_CHANGED This event indicates the current state for sending unreliable datagrams has changed. DATAGRAM_STATE_CHANGED New datagram state is passed in the DATAGRAM_STATE_CHANGED struct/union. SendEnabled A flag that indicates datagrams are allowed to be sent. MaxSendLength When enabled, indicates the maximum length of a single datagram that can fit in a packet. QUIC_CONNECTION_EVENT_DATAGRAM_RECEIVED This event indicates a received unreliable datagram from the peer. DATAGRAM_RECEIVED Unreliable datagram buffer and metadata are passed in the DATAGRAM_RECEIVED struct/union. Buffer Contains a pointer to the received data along with the length of the data. Flags A set of flags indicating describing the received datagram data: Value Meaning QUIC_RECEIVE_FLAG_NONE 0 No special behavior. QUIC_RECEIVE_FLAG_0_RTT 1 The data was received in 0-RTT. QUIC_RECEIVE_FLAG_FIN 2 N/A. Only used for Stream data. Unused for datagrams. QUIC_CONNECTION_EVENT_DATAGRAM_SEND_STATE_CHANGED This event indicates a state change for a previous unreliable datagram send via DatagramSend. SEND_STATE_CHANGED Unreliable datagram send state is passed in the SEND_STATE_CHANGED struct/union. ClientContext The context pointer passed into DatagramSend as ClientSendContext. State The latest state for the sent datagram. Value Meaning QUIC_DATAGRAM_SEND_SENT 1 Indicates the datagram has now been sent out on the network. This is the earliest the app may free the Buffers passed into DatagramSend. QUIC_DATAGRAM_SEND_LOST_SUSPECT 2 The sent datagram is suspected to be lost. If desired, the app could retransmit the data now. QUIC_DATAGRAM_SEND_LOST_DISCARDED 3 The sent datagram is lost and no longer tracked by MsQuic. QUIC_DATAGRAM_SEND_ACKNOWLEDGED 4 The sent datagram has been acknowledged. QUIC_DATAGRAM_SEND_ACKNOWLEDGED_SPURIOUS 5 The sent datagram has been acknowledged after previously being suspected as lost. QUIC_DATAGRAM_SEND_CANCELED 6 The queued datagram was canceled; either because the connection was shutdown or the peer did not negotiate the feature. QUIC_CONNECTION_EVENT_RESUMED This event indicates that a previous session has been successfully resumed at the TLS layer. This event is delivered for the server side only. The server app must indicate acceptance or rejection of the resumption ticket by returning a successful or failure status code from the event. If rejected by the server app, then resumption is rejected and a normal handshake will be performed. RESUMED Connection resumption state is passed in the Resumed struct/union. ResumptionStateLength The length of the ResumptionState buffer. ResumptionState The resumption ticket data previously sent to the client via ConnectionSendResumptionTicket. QUIC_CONNECTION_EVENT_RESUMPTION_TICKET_RECEIVED This event indicates to the client that a TLS resumption ticket has been received from the server. RESUMPTION_TICKET_RECEIVED Resumption ticket state is passed in the RESUMPTION_TICKET_RECEIVED struct/union. ResumptionTicketLength The length of the ResumptionTicket buffer. ResumptionTicket The resumption ticket data received from the server. For a client to later resume the session in a new connection, it must pass this data to the new connection via the QUIC_PARAM_CONN_RESUMPTION_TICKET parameter. QUIC_CONNECTION_EVENT_PEER_CERTIFICATE_RECEIVED This event indicates a certificate has been received from the peer. PEER_CERTIFICATE_RECEIVED The peer certificate and related data is passed in the PEER_CERTIFICATE_RECEIVED struct/union. Certificate Pointer to a platform/TLS specific certificate. Valid only during the callback. If QUIC_CREDENTIAL_FLAG_USE_PORTABLE_CERTIFICATES was specified in the QUIC_CREDENTIAL_CONFIG, this will be a QUIC_BUFFER containing the DER (binary) encoded remote X.509 certificate. DeferredErrorFlags Bit flag of errors encountered when doing deferring validation of the certificate. Valid only with QUIC_CREDENTIAL_FLAG_DEFER_CERTIFICATE_VALIDATION flag specified upfront. Only supported with Schannel currently. DeferredStatus Most severe error status when doing deferred validation of the certificate. Valid only with QUIC_CREDENTIAL_FLAG_DEFER_CERTIFICATE_VALIDATION flag specified upfront. Chain Pointer to a platform/TLS specific certificate chain. Valid only during the callback. If QUIC_CREDENTIAL_FLAG_USE_PORTABLE_CERTIFICATES was specified in the QUIC_CREDENTIAL_CONFIG, this will be a QUIC_BUFFER containing the PKCS #7 DER (binary) encoded certificate chain. QUIC_CONNECTION_EVENT_RELIABLE_RESET_NEGOTIATED Preview feature: This event is in preview. It should be considered unstable and can be subject to breaking changes. This event indicates the result of reliable reset negotiation. This is only indicated if QUIC_SETTINGS.ReliableResetEnabled is TRUE. RELIABLE_RESET_NEGOTIATED Result of reliable reset negotiation is passed in the RELIABLE_RESET_NEGOTIATED struct/union. IsNegotiated If TRUE, reliable reset has been negotiated. QUIC_CONNECTION_EVENT_ONE_WAY_DELAY_NEGOTIATED Preview feature: This event is in preview. It should be considered unstable and can be subject to breaking changes. This event indicates the result of one way delay negotiation. This is only indicated if QUIC_SETTINGS.OneWayDelayEnabled is TRUE. ONE_WAY_DELAY_NEGOTIATED Details of the one way delay negotiation are passed in the ONE_WAY_DELAY_NEGOTIATED struct/union. SendNegotiated If TRUE, sending one-way delay timestamps has been negotiated. ReceiveNegotiated If TRUE, receiving one-way delay timestamps has been negotiated. QUIC_CONNECTION_EVENT_NETWORK_STATISTICS Preview feature: This event is in preview. It should be considered unstable and can be subject to breaking changes. This event is only indicated if QUIC_SETTINGS.EnableNetStatsEvent is TRUE. This event indicates the latest network statistics generated during the QUIC protocol handling in the MsQuic library. NETWORK_STATISTICS Detailed networking statistics are passed in the QUIC_NETWORK_STATISTICS struct/union. BytesInFlight Bytes that were sent on the wire, but not yet acked PostedBytes Total bytes queued, but not yet acked. These may contain sent bytes that may have portentially lost too. IdealBytes Ideal number of bytes required to be available to avoid limiting throughput. SmoothedRTT Smoothed RTT value CongestionWindow Congestion Window Bandwidth Estimated bandwidth See Also ConnectionOpen QUIC_CONNECTION_CALLBACK SetCallbackHandler SetContext QUIC_CREDENTIAL_CONFIG Preview Features"
  },
  "docs/api/QUIC_CONNECTION_POOL_CONFIG.html": {
    "href": "docs/api/QUIC_CONNECTION_POOL_CONFIG.html",
    "title": "QUIC_CONNECTION_POOL_CONFIG structure",
    "summary": "QUIC_CONNECTION_POOL_CONFIG structure The configuration for creating a connection pool. Warning This API is still in preview and may change in the future! Syntax typedef enum QUIC_CONNECTION_POOL_FLAGS { QUIC_CONNECTION_POOL_FLAG_NONE = 0x00000000, QUIC_CONNECTION_POOL_FLAG_CLOSE_CONNECTIONS_ON_FAILURE = 0x00000001, } QUIC_CONNECTION_POOL_FLAGS; typedef struct QUIC_CONNECTION_POOL_CONFIG { HQUIC Registration; HQUIC Configuration; QUIC_CONNECTION_CALLBACK_HANDLER Handler; _Field_size_opt_(NumberOfConnections) void** Context; // Optional _Field_z_ const char* ServerName; const QUIC_ADDR* ServerAddress; // Optional QUIC_ADDRESS_FAMILY Family; uint16_t ServerPort; uint16_t NumberOfConnections; _At_buffer_(_Curr_, _Iter_, NumberOfConnections, _Field_size_(CibirIdLength)) _Field_size_opt_(NumberOfConnections) uint8_t** CibirIds; // Optional uint8_t CibirIdLength; // Zero if not using CIBIR QUIC_CONNECTION_POOL_FLAGS Flags; } QUIC_CONNECTION_POOL_CONFIG; Members Registration The valid handle to an open registration object. Configuration The valid handle to an open and loaded configuration object that is used to create each connection in the pool. Handler A pointer to the app's callback handler to be invoked for all connection events. Context The array of app context pointers (possibly null). The first is associated with the first connection created, the second with the second connection, etc. ServerName The name of the server to connect to. It may also be an IP literal. ServerAddress An optional pointer to a QUIC_ADDR specifying the specific IP address to connect to. Takes precedence over the resolved ServerName address. Family The address family to use for resolving the IP address of the ServerName parameter. Supported values definitions are supported (The values are platform specific): Value Meaning QUIC_ADDRESS_FAMILY_UNSPEC Unspecified address family. QUIC_ADDRESS_FAMILY_INET Version 4 IP address family. QUIC_ADDRESS_FAMILY_INET6 Version 6 IP address family. ServerPort The UDP port, in host byte order, to connect to on the server. NumberOfConnections The number of connections to create in this connection pool. If this number is greater than the number of RSS CPUs configured on the system, then multiple connections will end up on the same CPU, potentially hurting performance. CibirIds An optional pointer to an array of pointers to uint8_ts specifying the CIBIR ID to use for each connection. All CIBIR IDs must be the same length. Not allowed to be non-NULL if CibirIdLength is zero. CibirIdLength The number of bytes in each CIBIR ID. Not allowed to be zero if CibirIds is non-NULL. Flags Flag Effect QUIC_CONNECTION_POOL_FLAG_NONE Nothing QUIC_CONNECTION_POOL_FLAG_CLOSE_CONNECTIONS_ON_FAILURE Tells the API to close all started connections in the pool if an error occurrs while creating the pool. Note: The application must be able to handle having connections suddenly closed. Without this flag, the application is expected to clean up non-NULL connections when an error is returned from ConnectionPoolCreate. See Also ConnectionPoolCreate ConnectionOpen ConnectionStart ConnectionShutdown ConnectionClose QUIC_CONNECTION_CALLBACK QUIC_CONNECTION_EVENT QUIC_SETTINGS"
  },
  "docs/api/QUIC_CREDENTIAL_CONFIG.html": {
    "href": "docs/api/QUIC_CREDENTIAL_CONFIG.html",
    "title": "QUIC_CREDENTIAL_CONFIG structure",
    "summary": "QUIC_CREDENTIAL_CONFIG structure The description for the security configuration to load for a configuration object. Syntax typedef struct QUIC_CREDENTIAL_CONFIG { QUIC_CREDENTIAL_TYPE Type; QUIC_CREDENTIAL_FLAGS Flags; union { QUIC_CERTIFICATE_HASH* CertificateHash; QUIC_CERTIFICATE_HASH_STORE* CertificateHashStore; QUIC_CERTIFICATE* CertificateContext; QUIC_CERTIFICATE_FILE* CertificateFile; QUIC_CERTIFICATE_FILE_PROTECTED* CertificateFileProtected; QUIC_CERTIFICATE_PKCS12* CertificatePkcs12; }; const char* Principal; void* Reserved; // Currently unused QUIC_CREDENTIAL_LOAD_COMPLETE_HANDLER AsyncHandler; // Optional QUIC_ALLOWED_CIPHER_SUITE_FLAGS AllowedCipherSuites;// Optional const char* CaCertificateFile; // Optional } QUIC_CREDENTIAL_CONFIG; Members Type Indicates which type of credential is represented. QUIC_CREDENTIAL_TYPE_NONE Only valid for clients. No client authentication is provided. QUIC_CREDENTIAL_TYPE_CERTIFICATE_HASH Search the Windows Current User (Local Machine for kernel mode) My certificate store for the certificate thumbprint pointed to by the CertificateHash member. Only valid on Windows with Schannel. QUIC_CREDENTIAL_TYPE_CERTIFICATE_HASH_STORE Search the Windows Current User (Local Machine for kernel mode) certificate store for the provided store name and certificate thumbprint pointed to by the CertificateHashStore member. Only valid on Windows with Schannel. QUIC_CREDENTIAL_TYPE_CERTIFICATE_CONTEXT Provide a Windows CAPI CERTIFICATE_CONTEXT with the certificate to use in the CertificateContext member. Only valid on Windows in user mode. QUIC_CREDENTIAL_TYPE_CERTIFICATE_FILE Provide file paths to a private key file in PEM format, and a certificate file in PEM or CER format, pointed to by the CertificateFile member. Only valid for OpenSSL. QUIC_CREDENTIAL_TYPE_CERTIFICATE_FILE_PROTECTED Provide file paths to a protected private key file, and a certificate file, and a password to unprotect the private key, pointed to by the CertificateFileProtected member. Only valid for OpenSSL. QUIC_CREDENTIAL_TYPE_CERTIFICATE_PKCS12 Provide an in-memory ASN.1 blob of a PKCS12 (PFX) certificate and private, with optional private key password, pointed to by the CertificatePkcs12 member. Only valid for OpenSSL. Flags Any combination of the following flags which change the credential behavior. QUIC_CREDENTIAL_FLAG_NONE Used with server in default configuration. QUIC_CREDENTIAL_FLAG_CLIENT Presence of this flag indicates this is a client. Absence indicates server. QUIC_CREDENTIAL_FLAG_LOAD_ASYNCHRONOUS Return QUIC_STATUS_PENDING immediately from ConfigurationLoadCredential and load the credentials asynchronously. Completion is indicated via the AsyncHandler callback. QUIC_CREDENTIAL_FLAG_NO_CERTIFICATE_VALIDATION Indicate to the TLS layer that no server certificate validation is to be performed. THIS IS DANGEROUS; DO NOT USE IN PRODUCTION QUIC_CREDENTIAL_FLAG_ENABLE_OCSP Enable OCSP stapling for this connection. Only valid for Schannel. QUIC_CREDENTIAL_FLAG_INDICATE_CERTIFICATE_RECEIVED Receive QUIC_CONNECTION_EVENT_PEER_CERTIFICATE_RECEIVED events when a certificate is received from the peer (client or server). QUIC_CREDENTIAL_FLAG_DEFER_CERTIFICATE_VALIDATION Request the TLS layer perform validation on the received certificate, and provide results to the application via QUIC_CONNECTION_EVENT_PEER_CERTIFICATE_RECEIVED events, and allow the application to override failed validation. Only supported by Schannel. Requires QUIC_CREDENTIAL_FLAG_INDICATE_CERTIFICATE_RECEIVED to also be set. QUIC_CREDENTIAL_FLAG_REQUIRE_CLIENT_AUTHENTICATION Require clients to provide authentication for the handshake to succeed. Not supported on client. QUIC_CREDENTIAL_FLAG_USE_TLS_BUILTIN_CERTIFICATE_VALIDATION Use the built-in TLS library's certificate validation instead of the platform's certificate validation. This is enabled by default on non-Windows systems, and only has effect on Windows when OpenSSL is used. QUIC_CREDENTIAL_FLAG_REVOCATION_CHECK_END_CERT Only check the leaf certificate for revocation. Only valid on Windows. QUIC_CREDENTIAL_FLAG_REVOCATION_CHECK_CHAIN Check every certificate in the chain for revocation. Only valid on Windows. QUIC_CREDENTIAL_FLAG_REVOCATION_CHECK_CHAIN_EXCLUDE_ROOT Check every certificate in the chain, except the root, for revocation. Only valid on Windows. QUIC_CREDENTIAL_FLAG_IGNORE_NO_REVOCATION_CHECK Ignore errors from no revocation check being performed. Only valid on Windows. QUIC_CREDENTIAL_FLAG_IGNORE_REVOCATION_OFFLINE Ignore revocation offline failures. Only valid on Windows. QUIC_CREDENTIAL_FLAG_SET_ALLOWED_CIPHER_SUITES Enables which cipher suites are available for negotiation via the AllowedCipherSuites member. QUIC_CREDENTIAL_FLAG_USE_PORTABLE_CERTIFICATES Provide the remote X.509 certificate as a DER (binary) blob and entire certificate chain to the application as a PKCS #7 DER blob in the QUIC_CONNECTION_EVENT_PEER_CERTIFICATE_RECEIVED event. Not supported in kernel mode. QUIC_CREDENTIAL_FLAG_USE_SUPPLIED_CREDENTIALS Tells the TLS layer (currently only supported by Schannel) to only use the supplied client certificate and not go looking for one on its own if the server asked for a certificate but the client app didn't supply one. More information can be found here. QUIC_CREDENTIAL_FLAG_USE_SYSTEM_MAPPER Tells the TLS layer (only supported by Schannel server) to use the system credential mapper to map the client-supplied credentials to a user account on the system. QUIC_CREDENTIAL_FLAG_CACHE_ONLY_URL_RETRIEVAL Only use certificates already cached when doing URL retrieval to build a certificate chain. Only valid on Windows. QUIC_CREDENTIAL_FLAG_REVOCATION_CHECK_CACHE_ONLY Only use cached revocation information when checking a certificate chain. Only valid on Windows. QUIC_CREDENTIAL_FLAG_INPROC_PEER_CERTIFICATE Obtain the peer certificate using a faster in-process API call. Only available on Schannel in the latest Windows 11 builds. QUIC_CREDENTIAL_FLAG_SET_CA_CERTIFICATE_FILE Enable CA certificate file provided in the CaCertificateFile member. QUIC_CREDENTIAL_FLAG_DISABLE_AIA The following flag can be set to explicitly disable AIA retrievals. Only valid on Windows. CertificateHash Must only use with QUIC_CREDENTIAL_TYPE_CERTIFICATE_HASH type. CertificateHashStore Must only use with QUIC_CREDENTIAL_TYPE_CERTIFICATE_HASH_STORE type. CertificateContext Must only use with QUIC_CREDENTIAL_TYPE_CERTIFICATE_CONTEXT type. CertificateFile Must only use with QUIC_CREDENTIAL_TYPE_CERTIFICATE_FILE type. CertificateFileProtected Must only use with QUIC_CREDENTIAL_TYPE_CERTIFICATE_FILE_PROTECTED type. CertificatePkcs12 Must only use with QUIC_CREDENTIAL_TYPE_CERTIFICATE_PKCS12 type. Principal Principal name string to select certificate by the principal name. Only supported by Schannel. AsyncHandler Optional callback to receive completion of asynchronous credential load. Only used with QUIC_CREDENTIAL_FLAG_LOAD_ASYNCHRONOUS flag. AllowedCipherSuites A set of flags indicating which cipher suites are available to negotiate. Must be used with QUIC_CREDENTIAL_FLAG_SET_ALLOWED_CIPHER_SUITES. CaCertificateFile Optional pointer to CA certificate file that will be used when validating the peer certificate. This allows the use of a private CA. Must be used with QUIC_CREDENTIAL_FLAG_SET_CA_CERTIFICATE_FILE. Remarks TODO typedef _IRQL_requires_max_(PASSIVE_LEVEL) _Function_class_(QUIC_CREDENTIAL_LOAD_COMPLETE) void (QUIC_API QUIC_CREDENTIAL_LOAD_COMPLETE)( _In_ HQUIC Configuration, _In_opt_ void* Context, _In_ QUIC_STATUS Status ); typedef QUIC_CREDENTIAL_LOAD_COMPLETE *QUIC_CREDENTIAL_LOAD_COMPLETE_HANDLER; typedef struct QUIC_CERTIFICATE_HASH { uint8_t ShaHash[20]; } QUIC_CERTIFICATE_HASH; typedef struct QUIC_CERTIFICATE_HASH_STORE { QUIC_CERTIFICATE_HASH_STORE_FLAGS Flags; uint8_t ShaHash[20]; char StoreName[128]; } QUIC_CERTIFICATE_HASH_STORE; typedef struct QUIC_CERTIFICATE_FILE { const char *PrivateKeyFile; const char *CertificateFile; } QUIC_CERTIFICATE_FILE; typedef struct QUIC_CERTIFICATE_FILE_PROTECTED { const char *PrivateKeyFile; const char *CertificateFile; const char *PrivateKeyPassword; } QUIC_CERTIFICATE_FILE_PROTECTED; typedef void QUIC_CERTIFICATE; // Platform specific certificate context object See Also ConfigurationLoadCredential"
  },
  "docs/api/QUIC_HANDSHAKE_INFO.html": {
    "href": "docs/api/QUIC_HANDSHAKE_INFO.html",
    "title": "QUIC_HANDSHAKE_INFO structure",
    "summary": "QUIC_HANDSHAKE_INFO structure Used to return the various algorithms negotiated during the TLS handshake. Syntax typedef struct QUIC_HANDSHAKE_INFO { QUIC_TLS_PROTOCOL_VERSION TlsProtocolVersion; QUIC_CIPHER_ALGORITHM CipherAlgorithm; int32_t CipherStrength; QUIC_HASH_ALGORITHM Hash; int32_t HashStrength; QUIC_KEY_EXCHANGE_ALGORITHM KeyExchangeAlgorithm; int32_t KeyExchangeStrength; QUIC_CIPHER_SUITE CipherSuite; QUIC_TLS_GROUP TlsGroup; // Added in v2.5 } QUIC_HANDSHAKE_INFO; Members TlsProtocolVersion Indicates which version of TLS was negotiated. QUIC_TLS_PROTOCOL_UNKNOWN An unknown or unexpected value was used. QUIC_TLS_PROTOCOL_1_3 Version 1.3 was negotiated. This is currently the only expected value to be returned. CipherAlgorithm The QUIC_CIPHER_ALGORITHM negotiated. CipherStrength TODO Hash The QUIC_HASH_ALGORITHM negotiated. HashStrength TODO KeyExchangeAlgorithm The QUIC_KEY_EXCHANGE_ALGORITHM negotiated. KeyExchangeStrength TODO CipherSuite The QUIC_CIPHER_SUITE negotiated. TlsGroup The QUIC_TLS_GROUP negotiated. Note - This field is not supported before MsQuic version v2.5. Calls to older versions of MsQuic will indicate a final output length not including this field. Additionally, older callers that use the old version of the struct will still work, and MsQuic will not try to write this field. Remarks This may be queries for a connection after the handshake has completed via a call to GetParam by using the QUIC_PARAM_TLS_HANDSHAKE_INFO parameter. See Also GetParam"
  },
  "docs/api/QUIC_LISTENER_CALLBACK.html": {
    "href": "docs/api/QUIC_LISTENER_CALLBACK.html",
    "title": "QUIC_LISTENER_CALLBACK function pointer",
    "summary": "QUIC_LISTENER_CALLBACK function pointer Handles listener events. Syntax typedef _IRQL_requires_max_(PASSIVE_LEVEL) _Function_class_(QUIC_LISTENER_CALLBACK) QUIC_STATUS (QUIC_API QUIC_LISTENER_CALLBACK)( _In_ HQUIC Listener, _In_opt_ void* Context, _Inout_ QUIC_LISTENER_EVENT* Event ); Parameters Listener The valid handle to the listener object this event is for. Context The application callback context (optionally) supplied in ListenerOpen. Event A pointer to the QUIC_LISTENER_EVENT payload. Remarks This function pointer handles callbacks from MsQuic for listener events. Apps are expected to keep any execution time in the callback to a minimum. See Also ListenerOpen QUIC_LISTENER_EVENT SetCallbackHandler SetContext"
  },
  "docs/api/QUIC_LISTENER_EVENT.html": {
    "href": "docs/api/QUIC_LISTENER_EVENT.html",
    "title": "QUIC_LISTENER_EVENT structure",
    "summary": "QUIC_LISTENER_EVENT structure QUIC listener events and the corresponding payload Syntax typedef enum QUIC_LISTENER_EVENT_TYPE { QUIC_LISTENER_EVENT_NEW_CONNECTION = 0, QUIC_LISTENER_EVENT_STOP_COMPLETE = 1, QUIC_LISTENER_EVENT_DOS_MODE_CHANGED = 2, } QUIC_LISTENER_EVENT_TYPE; The payload for QUIC listener events. typedef struct QUIC_LISTENER_EVENT { QUIC_LISTENER_EVENT_TYPE Type; union { struct { const QUIC_NEW_CONNECTION_INFO* Info; HQUIC Connection; const uint8_t* NewNegotiatedAlpn; } NEW_CONNECTION; struct { BOOLEAN AppCloseInProgress : 1; BOOLEAN RESERVED : 7; } STOP_COMPLETE; struct { BOOLEAN DosModeEnabled : 1; BOOLEAN RESERVED : 7; } DOS_MODE_CHANGED; }; } QUIC_LISTENER_EVENT; Parameters Type The QUIC_LISTENER_EVENT_TYPE that indicates which type of event this is, and which payload to reference (if any) for additional information. Remarks QUIC_LISTENER_EVENT_NEW_CONNECTION This event is delivered when a new connection is received by the listener. NEW_CONNECTION Details of the new connection are passed in the NEW_CONNECTION struct/union. Info This field indicates the QUIC_NEW_CONNECTION_INFO structure for the new connection. Connection This field indicates the valid handle to the new incoming connection. QUIC_LISTENER_EVENT_STOP_COMPLETE This event is delivered when server app wants to stop receiving new incoming connections. STOP_COMPLETE Details of the listener stopping are indicated in STOP_COMPLETE struct/union. AppCloseInProgress This flag indicates the server has called ListenerClose. RESERVED This field reserved for future use. Do not use. QUIC_LISTENER_EVENT_DOS_MODE_CHANGED This event indicates an automated change in the DoS mode on the listener object in the MsQuic library. This event is delivered only for listener objects that have opted in for DoS mode change events. Refer to the Listener Parameters documentation for further information. DOS_MODE_CHANGED Details of the DoS mode change is indicated in the DOS_MODE_CHANGED struct/union. DosModeEnabled If TRUE, DoS mode is currently enabled on the listener object, else DoS mode is currently disabled on the listener object. RESERVED This field reserved for future use. Do not use. See Also ListenerOpen ListenerStop QUIC_LISTENER_CALLBACK QUIC_NEW_CONNECTION_INFO SetCallbackHandler SetContext"
  },
  "docs/api/QUIC_NEW_CONNECTION_INFO.html": {
    "href": "docs/api/QUIC_NEW_CONNECTION_INFO.html",
    "title": "QUIC_NEW_CONNECTION_INFO structure",
    "summary": "QUIC_NEW_CONNECTION_INFO structure All available information for new incoming QUIC connection. // // All the available information describing a new incoming connection. // typedef struct QUIC_NEW_CONNECTION_INFO { uint32_t QuicVersion; const QUIC_ADDR* LocalAddress; const QUIC_ADDR* RemoteAddress; uint32_t CryptoBufferLength; uint16_t ClientAlpnListLength; uint16_t ServerNameLength; uint8_t NegotiatedAlpnLength; _Field_size_bytes_(CryptoBufferLength) const uint8_t* CryptoBuffer; _Field_size_bytes_(ClientAlpnListLength) const uint8_t* ClientAlpnList; _Field_size_bytes_(NegotiatedAlpnLength) const uint8_t* NegotiatedAlpn; _Field_size_bytes_opt_(ServerNameLength) const char* ServerName; } QUIC_NEW_CONNECTION_INFO; Parameters QuicVersion The QUIC version negotiated for the new incoming connection. LocalAddress This field indicates the local address of the new incoming connection. RemoteAddress This field indicates the remote address of the new incoming connection. CryptoBufferLength This field indicates the length of the crypto buffer. ClientAlpnListLength This field indicates the total bytes of the client ALPN list. ServerNameLength This field indicates the length of the server name (SNI). NegotiatedAlpnLength This field indicates the length of the negotiated ALPN. CryptoBuffer This pointer indicates the crypto buffer for the new incoming connection. ClientAlpnList This pointer indicates the sent ALPN list from the client via the new incoming connection. NegotiatedAlpn This pointer indicates the negotiated ALPN between server and client. ServerName This pointer indicates the server name (SNI) of the new incoming connection. Note: this buffer comes directly from the TLS ClientHello, and its format is governed by TLS. From RFC 6066: \"HostName\" contains the fully qualified DNS hostname of the server, as understood by the client. The hostname is represented as a byte string using ASCII encoding without a trailing dot. This allows the support of internationalized domain names through the use of A-labels defined in [RFC5890]. DNS hostnames are case-insensitive. The algorithm to compare hostnames is described in [RFC5890, Section 2.3.2.4]. See Also QUIC_LISTENER_CALLBACK QUIC_LISTENER_EVENT"
  },
  "docs/api/QUIC_REGISTRATION_CONFIG.html": {
    "href": "docs/api/QUIC_REGISTRATION_CONFIG.html",
    "title": "QUIC_REGISTRATION_CONFIG structure",
    "summary": "QUIC_REGISTRATION_CONFIG structure The structure used to configure the execution context of a application registration. Syntax typedef struct QUIC_REGISTRATION_CONFIG { const char* AppName; QUIC_EXECUTION_PROFILE ExecutionProfile; } QUIC_REGISTRATION_CONFIG; Members AppName An optional (may be NULL), null-terminated string describing the application that created the registration. This field is primarily used for debugging purposes. ExecutionProfile Provides a hint to MsQuic on how to optimize its thread scheduling operations. Value Meaning QUIC_EXECUTION_PROFILE_LOW_LATENCY 0 Indicates that scheduling should be generally optimized for reducing response latency. The default execution profile. QUIC_EXECUTION_PROFILE_TYPE_MAX_THROUGHPUT 1 Indicates that scheduling should be optimized for maximum single connection throughput. QUIC_EXECUTION_PROFILE_TYPE_SCAVENGER 2 Indicates that minimal responsiveness is required by the scheduling logic. For instance, a background transfer or process. QUIC_EXECUTION_PROFILE_TYPE_REAL_TIME 3 Indicates responsiveness is of paramount importance to the scheduler. See Also RegistrationOpen"
  },
  "docs/api/QUIC_SETTINGS.html": {
    "href": "docs/api/QUIC_SETTINGS.html",
    "title": "QUIC_SETTINGS structure",
    "summary": "QUIC_SETTINGS structure The set of all customizable parameters for the library. Syntax typedef struct QUIC_SETTINGS { union { uint64_t IsSetFlags; struct { uint64_t MaxBytesPerKey : 1; uint64_t HandshakeIdleTimeoutMs : 1; uint64_t IdleTimeoutMs : 1; uint64_t MtuDiscoverySearchCompleteTimeoutUs : 1; uint64_t TlsClientMaxSendBuffer : 1; uint64_t TlsServerMaxSendBuffer : 1; uint64_t StreamRecvWindowDefault : 1; uint64_t StreamRecvBufferDefault : 1; uint64_t ConnFlowControlWindow : 1; uint64_t MaxWorkerQueueDelayUs : 1; uint64_t MaxStatelessOperations : 1; uint64_t InitialWindowPackets : 1; uint64_t SendIdleTimeoutMs : 1; uint64_t InitialRttMs : 1; uint64_t MaxAckDelayMs : 1; uint64_t DisconnectTimeoutMs : 1; uint64_t KeepAliveIntervalMs : 1; uint64_t CongestionControlAlgorithm : 1; uint64_t PeerBidiStreamCount : 1; uint64_t PeerUnidiStreamCount : 1; uint64_t MaxBindingStatelessOperations : 1; uint64_t StatelessOperationExpirationMs : 1; uint64_t MinimumMtu : 1; uint64_t MaximumMtu : 1; uint64_t SendBufferingEnabled : 1; uint64_t PacingEnabled : 1; uint64_t MigrationEnabled : 1; uint64_t DatagramReceiveEnabled : 1; uint64_t ServerResumptionLevel : 1; uint64_t MaxOperationsPerDrain : 1; uint64_t MtuDiscoveryMissingProbeCount : 1; uint64_t DestCidUpdateIdleTimeoutMs : 1; uint64_t GreaseQuicBitEnabled : 1; uint64_t EcnEnabled : 1; uint64_t HyStartEnabled : 1; uint64_t StreamRecvWindowBidiLocalDefault : 1; uint64_t StreamRecvWindowBidiRemoteDefault : 1; uint64_t StreamRecvWindowUnidiDefault : 1; #ifdef QUIC_API_ENABLE_PREVIEW_FEATURES uint64_t EncryptionOffloadAllowed : 1; uint64_t ReliableResetEnabled : 1; uint64_t OneWayDelayEnabled : 1; uint64_t NetStatsEventEnabled : 1; uint64_t StreamMultiReceiveEnabled : 1; uint64_t XdpEnabled : 1; uint64_t QTIPEnabled : 1; uint64_t ReservedRioEnabled : 1; uint64_t RESERVED : 18; #else uint64_t RESERVED : 26; #endif } IsSet; }; uint64_t MaxBytesPerKey; uint64_t HandshakeIdleTimeoutMs; uint64_t IdleTimeoutMs; uint64_t MtuDiscoverySearchCompleteTimeoutUs; uint32_t TlsClientMaxSendBuffer; uint32_t TlsServerMaxSendBuffer; uint32_t StreamRecvWindowDefault; uint32_t StreamRecvBufferDefault; uint32_t ConnFlowControlWindow; uint32_t MaxWorkerQueueDelayUs; uint32_t MaxStatelessOperations; uint32_t InitialWindowPackets; uint32_t SendIdleTimeoutMs; uint32_t InitialRttMs; uint32_t MaxAckDelayMs; uint32_t DisconnectTimeoutMs; uint32_t KeepAliveIntervalMs; uint16_t CongestionControlAlgorithm; // QUIC_CONGESTION_CONTROL_ALGORITHM uint16_t PeerBidiStreamCount; uint16_t PeerUnidiStreamCount; uint16_t MaxBindingStatelessOperations; uint16_t StatelessOperationExpirationMs; uint16_t MinimumMtu; uint16_t MaximumMtu; uint8_t SendBufferingEnabled : 1; uint8_t PacingEnabled : 1; uint8_t MigrationEnabled : 1; uint8_t DatagramReceiveEnabled : 1; uint8_t ServerResumptionLevel : 2; // QUIC_SERVER_RESUMPTION_LEVEL uint8_t GreaseQuicBitEnabled : 1; uint8_t EcnEnabled : 1; uint8_t MaxOperationsPerDrain; uint8_t MtuDiscoveryMissingProbeCount; uint32_t DestCidUpdateIdleTimeoutMs; union { uint64_t Flags; struct { uint64_t HyStartEnabled : 1; #ifdef QUIC_API_ENABLE_PREVIEW_FEATURES uint64_t EncryptionOffloadAllowed : 1; uint64_t ReliableResetEnabled : 1; uint64_t OneWayDelayEnabled : 1; uint64_t NetStatsEventEnabled : 1; uint64_t StreamMultiReceiveEnabled : 1; uint64_t XdpEnabled : 1; uint64_t QTIPEnabled : 1; uint64_t ReservedRioEnabled : 1; uint64_t ReservedFlags : 55; #else uint64_t ReservedFlags : 63; #endif }; }; uint32_t StreamRecvWindowBidiLocalDefault; uint32_t StreamRecvWindowBidiRemoteDefault; uint32_t StreamRecvWindowUnidiDefault; } QUIC_SETTINGS; Members IsSetFlags The set of flags that indicate which other struct members are valid. MaxBytesPerKey Maximum number of bytes to encrypt with a single 1-RTT encryption key before initiating key update. Default value: 274,877,906,944 HandshakeIdleTimeoutMs How long a handshake can idle before it is discarded. Default value: 10,000 IdleTimeoutMs How long a connection can go idle before it is gracefully shut down. 0 to disable timeout. Default value: 30,000 TlsClientMaxSendBuffer How much client TLS data to buffer. If the application expects large client certificates, or long client certificate chains, this value should be increased. Default value: 4,096 TlsServerMaxSendBuffer How much server TLS data to buffer. If the application expects very large server certificates, or long server certificate chains, this value should be increased. Default value: 8,192 StreamRecvWindowDefault Initial stream receive flow control window size. This applies to all stream types. Limits for specific stream types can be set using StreamRecvWindowBidirLocalDefault, StreamRecvWindowBidirRemoteDefault and StreamRecvWindowUnidirDefault. The value must be a power of 2. Default value: 65,536 StreamRecvBufferDefault Stream initial buffer size. Default value: 4,096 ConnFlowControlWindow Connection-wide flow control window. Default value: 16,777,216 MaxWorkerQueueDelayUs The maximum queue delay (in microseconds) allowed for a worker thread. This affects loss detection and probe timeouts. Default value: 250,000 MaxStatelessOperations The maximum number of stateless operations that may be queued on a worker at any one time. Default value: 16 InitialWindowPackets The size (in packets) of the initial congestion window for a connection. Default value: 10 SendIdleTimeoutMs Reset congestion control after being idle SendIdleTimeoutMs milliseconds. Default value: 1,000 InitialRttMs Initial RTT estimate. Default value: 333 MaxAckDelayMs How long to wait after receiving data before sending an ACK. This controls batch sending ACKs, to get higher throughput with less overhead. Too long causes retransmits from the peer, too short wastefully sends ACKs. Default value: 25 DisconnectTimeoutMs How long to wait for an ACK before declaring a path dead and disconnecting. Default value: 16,000 KeepAliveIntervalMs How often to send PING frames to keep a connection alive. This also helps keep NAT table entries from expiring. Default value: 0 (disabled) PeerBidiStreamCount Number of bidirectional streams to allow the peer to open. Must be non-zero to allow the peer to open any streams at all. Default value: 0 PeerUnidiStreamCount Number of unidirectional streams to allow the peer to open. Must be non-zero to allow the peer to open any streams at all. Default value: 0 RetryMemoryLimit The percentage of available memory usable for handshake connections before stateless retry is used. Calculated as N/65535. Global setting, not per-connection/configuration. Default value: 65 (~0.1%) LoadBalancingMode Global setting, not per-connection/configuration. Default value: 0 (disabled) MaxOperationsPerDrain The maximum number of operations to drain per connection quantum. Default value: 16 SendBufferingEnabled Buffer send data within MsQuic instead of holding application buffers until sent data is acknowledged. Default value: 1 (TRUE) PacingEnabled Pace sending to avoid overfilling buffers on the path. Default value: 1 (TRUE) MigrationEnabled Enable clients to migrate IP addresses and tuples. Requires the server to be behind a cooperative load-balancer, or behind no load-balancer. Default value: 1 (TRUE) DatagramReceiveEnabled Advertise support for QUIC datagram extension. Both sides of a connection need to set this to TRUE for DatagramSend to be functional and supported. Default value: 0 (FALSE) ServerResumptionLevel Server only. Controls resumption tickets and/or 0-RTT server support. QUIC_SERVER_RESUME_ONLY enables sending and receiving TLS resumption tickets. The server app must call ConnectionSendResumptionTicket to send a resumption ticket to the client. QUIC_SERVER_RESUME_AND_ZERORTT enables sending and receiving TLS resumption tickets and generating 0-RTT keys and receiving 0-RTT payloads. The server app may decide accept/reject each 0-RTT payload individually. Default value: QUIC_SERVER_NO_RESUME (disabled) MinimumMtu The minimum MTU supported by a connection. This will be used as the starting MTU. Default value: 1248 MaximumMtu The maximum MTU supported by a connection. This will be the maximum probed value. Default value: 1500 MtuDiscoverySearchCompleteTimeoutUs The time in microseconds to wait before reattempting MTU probing if max was not reached. Default value: 600000000 MtuDiscoveryMissingProbeCount The number of MTU probes to retry before exiting MTU probing. Default value: 3 MaxBindingStatelessOperations The maximum number of stateless operations that may be queued on a binding at any one time. Default value: 100 StatelessOperationExpirationMs The time limit between operations for the same endpoint, in milliseconds. Default value: 100 DestCidUpdateIdleTimeoutMs Idle timeout period after which the destination CID is updated before sending again. Default value: 20,000 GreaseQuicBitEnabled Advertise support for QUIC Grease Bit Extension. Both sides of a connection need to set this to TRUE for receiving and sending necessary transport parameter. Default value: 0 (FALSE) EcnEnabled Enable sender-side ECN support. The connection will validate and react to ECN feedback from peer. Default value: 0 (FALSE) StreamRecvWindowBidirLocalDefault Initial stream receive flow control window size for locally initiated bidirectional streams. If set, this value overwrites the StreamRecvWindowDefault. Default value: 0 (no overwrite) StreamRecvWindowBidirRemoteDefault Initial stream receive flow control window size for remotely initiated bidirectional streams. If set, this value overwrites the StreamRecvWindowDefault. Default value: 0 (no overwrite) StreamRecvWindowUnidiDefault Initial stream receive flow control window size for remotely initiated unidirectional streams. If set, this value overwrites the StreamRecvWindowDefault. Default value: 0 (no overwrite) StreamMultiReceiveEnabled Enable multi receive mode. An app can continue receiving stream data without calling StreamReceiveComplete for each QUIC_STREAM_EVENT_RECEIVE indication. Default value: 0 (FALSE) Remarks When setting new values for the settings, the app must set the corresponding .IsSet.* parameter for each actual parameter that is being set or updated. For example: QUIC_SETTINGS Settings {0}; // // Configures the server's idle timeout. // Settings.IdleTimeoutMs = 60000; // 60 seconds Settings.IsSet.IdleTimeoutMs = TRUE; // // Configures the server's resumption level to allow for resumption and 0-RTT. // Settings.ServerResumptionLevel = QUIC_SERVER_RESUME_AND_ZERORTT; Settings.IsSet.ServerResumptionLevel = TRUE; See Also ConfigurationOpen GetParam SetParam"
  },
  "docs/api/QUIC_STATELESS_RETRY_CONFIG.html": {
    "href": "docs/api/QUIC_STATELESS_RETRY_CONFIG.html",
    "title": "QUIC_STATELESS_RETRY_CONFIG structure",
    "summary": "QUIC_STATELESS_RETRY_CONFIG structure The structure used to configure the stateless retry feature. Syntax typedef struct QUIC_STATELESS_RETRY_CONFIG { QUIC_AEAD_ALGORITHM_TYPE Algorithm; uint32_t RotationMs; uint32_t SecretLength; _Field_size_bytes_(SecretLength) const uint8_t* Secret; } QUIC_STATELESS_RETRY_CONFIG; Members Algorithm The AEAD algorithm used for protecting the retry token. Must be one of the following constants: Constant Key Length (bytes) QUIC_AEAD_ALGORITHM_AES_128_GCM 0 16 QUIC_AEAD_ALGORITHM_AES_256_GCM 1 The default 32 RotationMs The interval to rotate the retry key. 30,000ms is the default. A token is valid for twice this interval. Zero is not allowed. SecretLength The length in bytes pointed to by Secret. Must match the key length of the chosen Algorithm. Secret A non-NULL pointer to a buffer containing SecretLength bytes of randomness. Used to generate the keys protecting the retry token. Remarks RotationMs should be kept to a short interval, less than a minute, as retry tokens are returned immediately by clients. Changing RotationMs, Algorithm, or Secret will invalidate all retry tokens issued prior to the change. All servers deployed in a cluster and sharing the secret must have their clocks synchronized within RotationMs of UTC. A server whose clock is ahead of UTC may produce a retry token that other servers in that deployment are unable to validate. See Also Settings"
  },
  "docs/api/QUIC_STATUS.html": {
    "href": "docs/api/QUIC_STATUS.html",
    "title": "QUIC_STATUS type",
    "summary": "QUIC_STATUS type The status type MsQuic uses for all API return codes. Syntax Windows (User Mode) #define QUIC_STATUS HRESULT #define QUIC_FAILED(X) FAILED(X) #define QUIC_SUCCEEDED(X) SUCCEEDED(X) Linux #define QUIC_STATUS unsigned long #define QUIC_FAILED(X) ((int)(X) > 0) #define QUIC_SUCCEEDED(X) ((int)(X) <= 0) Remarks The QUIC_STATUS type is a cross platform abstraction of the current platform's error code space. It allows for both success and failure values, which can be easily determined by the QUIC_SUCCEEDED and QUIC_FAILED macros. The MsQuic headers define a number of different possible values for this (see below) but this list is not exhaustive. The platform specific functionality (for example UDP sockets) may also return platform specific error codes up to the app. Well-Known Status Codes Value Meaning QUIC_STATUS_SUCCESS The operation completed successfully. QUIC_STATUS_PENDING The operation is pending. QUIC_STATUS_CONTINUE The operation will continue. QUIC_STATUS_OUT_OF_MEMORY Allocation of memory failed. QUIC_STATUS_INVALID_PARAMETER An invalid parameter was encountered. QUIC_STATUS_INVALID_STATE The current state was not valid for this operation. QUIC_STATUS_NOT_SUPPORTED The operation was not supported. QUIC_STATUS_NOT_FOUND The object was not found. QUIC_STATUS_BUFFER_TOO_SMALL The buffer was too small for the operation. QUIC_STATUS_HANDSHAKE_FAILURE The connection handshake failed. QUIC_STATUS_ABORTED The connection or stream was aborted. QUIC_STATUS_ADDRESS_IN_USE The local address is already in use. QUIC_STATUS_INVALID_ADDRESS Binding to socket failed, likely caused by a family mismatch between local and remote address. QUIC_STATUS_CONNECTION_TIMEOUT The connection timed out waiting for a response from the peer. QUIC_STATUS_CONNECTION_IDLE The connection timed out from inactivity. QUIC_STATUS_INTERNAL_ERROR An internal error was encountered. QUIC_STATUS_UNREACHABLE The server is currently unreachable. QUIC_STATUS_CONNECTION_REFUSED The server refused the connection. QUIC_STATUS_PROTOCOL_ERROR A protocol error was encountered. QUIC_STATUS_VER_NEG_ERROR A version negotiation error was encountered. QUIC_STATUS_USER_CANCELED The peer app/user canceled the connection during the handshake. QUIC_STATUS_ALPN_NEG_FAILURE The connection handshake failed to negotiate a common ALPN. QUIC_STATUS_STREAM_LIMIT_REACHED A stream failed to start because the peer doesn't allow any more to be open at this time."
  },
  "docs/api/QUIC_STREAM_CALLBACK.html": {
    "href": "docs/api/QUIC_STREAM_CALLBACK.html",
    "title": "QUIC_STREAM_CALLBACK function pointer signature",
    "summary": "QUIC_STREAM_CALLBACK function pointer signature Handles stream events. Syntax typedef _IRQL_requires_max_(PASSIVE_LEVEL) _Function_class_(QUIC_STREAM_CALLBACK) QUIC_STATUS (QUIC_API QUIC_STREAM_CALLBACK)( _In_ HQUIC Stream, _In_opt_ void* Context, _Inout_ QUIC_STREAM_EVENT* Event ); Parameters Stream The valid handle to the stream object this event is for. Context The application callback context (optionally) supplied in StreamOpen, SetCallbackHandler or SetContext. Event A pointer to the QUIC_STREAM_EVENT payload. Remarks This is the signature of the function that handles callbacks from MsQuic for stream events. Apps are expected to keep any execution time in the callback to a minimum. See Also StreamOpen QUIC_STREAM_EVENT SetCallbackHandler SetContext"
  },
  "docs/api/QUIC_STREAM_EVENT.html": {
    "href": "docs/api/QUIC_STREAM_EVENT.html",
    "title": "QUIC_STREAM_EVENT structure",
    "summary": "QUIC_STREAM_EVENT structure QUIC stream events and the corresponding payload Syntax typedef enum QUIC_STREAM_EVENT_TYPE { QUIC_STREAM_EVENT_START_COMPLETE = 0, QUIC_STREAM_EVENT_RECEIVE = 1, QUIC_STREAM_EVENT_SEND_COMPLETE = 2, QUIC_STREAM_EVENT_PEER_SEND_SHUTDOWN = 3, QUIC_STREAM_EVENT_PEER_SEND_ABORTED = 4, QUIC_STREAM_EVENT_PEER_RECEIVE_ABORTED = 5, QUIC_STREAM_EVENT_SEND_SHUTDOWN_COMPLETE = 6, QUIC_STREAM_EVENT_SHUTDOWN_COMPLETE = 7, QUIC_STREAM_EVENT_IDEAL_SEND_BUFFER_SIZE = 8, QUIC_STREAM_EVENT_PEER_ACCEPTED = 9, QUIC_STREAM_EVENT_CANCEL_ON_LOSS = 10, #ifdef QUIC_API_ENABLE_PREVIEW_FEATURES QUIC_STREAM_EVENT_RECEIVE_BUFFER_NEEDED = 11, #endif } QUIC_STREAM_EVENT_TYPE; The payload for QUIC stream events. typedef struct QUIC_STREAM_EVENT { QUIC_STREAM_EVENT_TYPE Type; union { struct { QUIC_STATUS Status; QUIC_UINT62 ID; BOOLEAN PeerAccepted : 1; BOOLEAN RESERVED : 7; } START_COMPLETE; struct { /* in */ uint64_t AbsoluteOffset; /* inout */ uint64_t TotalBufferLength; _Field_size_(BufferCount) /* in */ const QUIC_BUFFER* Buffers; _Field_range_(0, UINT32_MAX) /* in */ uint32_t BufferCount; /* in */ QUIC_RECEIVE_FLAGS Flags; } RECEIVE; struct { BOOLEAN Canceled; void* ClientContext; } SEND_COMPLETE; struct { QUIC_UINT62 ErrorCode; } PEER_SEND_ABORTED; struct { QUIC_UINT62 ErrorCode; } PEER_RECEIVE_ABORTED; struct { BOOLEAN Graceful; } SEND_SHUTDOWN_COMPLETE; struct { BOOLEAN ConnectionShutdown; BOOLEAN AppCloseInProgress : 1; BOOLEAN ConnectionShutdownByApp : 1; BOOLEAN ConnectionClosedRemotely : 1; BOOLEAN RESERVED : 5; QUIC_UINT62 ConnectionErrorCode; QUIC_STATUS ConnectionCloseStatus; } SHUTDOWN_COMPLETE; struct { uint64_t ByteCount; } IDEAL_SEND_BUFFER_SIZE; struct { /* out */ QUIC_UINT62 ErrorCode; } CANCEL_ON_LOSS; #ifdef QUIC_API_ENABLE_PREVIEW_FEATURES struct { /* in */ uint64_t BufferLengthNeeded; } RECEIVE_BUFFER_NEEDED; #endif }; } QUIC_STREAM_EVENT; Parameters Type The QUIC_STREAM_EVENT_TYPE that indicates which type of event this is, and which payload to reference (if any) for additional information. Remarks QUIC_STREAM_EVENT_START_COMPLETE This event is delivered when the StreamStart operation completes. The accompanying payload contains data to indicate whether the operation succeeded or failed. START_COMPLETE Additional state from the StreamStart operation is included in this payload struct/union. Status QUIC_STATUS value to indicate the operation completion code. Check for success using the QUIC_SUCCEEDED macro. ID Stream ID if available. PeerAccepted If TRUE, the peer has accepted the stream. QUIC_STREAM_EVENT_RECEIVE Data received on an open stream is primarily delivered to the application through this event. RECEIVE Received data on the stream is passed in this struct/union. AbsoluteOffset Absolute offset of the current data payload from the start of the receive operation. TotalBufferLength MsQuic indicates the total buffer length of the data in this parameter. Receiving data goes beyond handling of this stream event callback. See Receiving Data On Streams for the various different approaches to receiving data on a stream. Upon successful handling of this event, the event handler should return one of QUIC_STATUS_SUCCESS or QUIC_STATUS_CONTINUE or QUIC_STATUS_PENDING to the MsQuic library, depending on the chosen approach to handling the received data. Buffers An array of QUIC_BUFFERs containing received data. The lifetime of the Buffers array itself is limited to the scope of the callback: if the received data is handled asynchronously (QUIC_STATUS_PENDING), the QUIC_BUFFER array must be copied. BufferCount Count of QUIC_BUFFERs in this payload. Flags A set of flags indicating describing the received data: Value Meaning QUIC_RECEIVE_FLAG_NONE 0 No special behavior. QUIC_RECEIVE_FLAG_0_RTT 1 The data was received in 0-RTT. QUIC_RECEIVE_FLAG_FIN 2 FIN was included with this data. Used only for streamed data. QUIC_STREAM_EVENT_SEND_COMPLETE Indicates that MsQuic has completed a StreamSend operation initated by the application. This is an important event in the asynchronous process of sending data over a stream. More info here: Send Buffering QUIC_BUFFER Handling Note SEND_COMPLETE Data for StreamSend completion is included in this struct/union. Canceled Indicates that the StreamSend operation was canceled. ClientContext Client context to match this event with the original StreamSend operation. QUIC_STREAM_EVENT_PEER_SEND_SHUTDOWN Indicates that the send direction of the stream from the peer has been shutdown and no further data is expected to be received on this stream. QUIC_STREAM_EVENT_PEER_SEND_ABORTED Indicates that the peer has aborted StreamSend operation. SEND_ABORTED Additional details of the send abort event are passed in this struct/union. ErrorCode Application's protocol specific, 62-bit error code. QUIC_STREAM_EVENT_PEER_RECEIVE_ABORTED Indicates that the peer has aborted receiving data. RECEIVE_ABORTED Additional details of the receive abort event are passed in this struct/union. ErrorCode Application's protocol specific, 62-bit error code. QUIC_STREAM_EVENT_SEND_SHUTDOWN_COMPLETE This event is raised when the send direction of the stream to the peer has been shutdown and no further data can be sent on this stream. SEND_SHUTDOWN_COMPLETE Additional details of send shutdown completion are passed in this struct/union. Graceful TRUE if the send shutdown operation was gracefully shutdown, FALSE otherwise. QUIC_STREAM_EVENT_SHUTDOWN_COMPLETE This event indicates that the stream has been completely shutdown. SHUTDOWN_COMPLETE Additional details for the stream shutdown are passed in this struct/union. ConnectionShutdown If TRUE, the Connection corresponding to this stream has been closed locally or remotely. AppCloseInProgress If TRUE, the application is in the process of closing the stream. ConnectionShutdownByApp If TRUE, the application shutdown the Connection corresponding to this stream. ConnectionClosedRemotely If TRUE, the Connection corresponding to this stream has been closed remotely. ConnectionErrorCode 62-bit Connection closure error code, if any. ConnectionCloseStatus QUIC_STATUS value of the connection close operation, if any. QUIC_STREAM_EVENT_IDEAL_SEND_BUFFER_SIZE MsQuic indicates the ideal send buffer size to the application through this event, so as not to idle the connection. IDEAL_SEND_BUFFER_SIZE Ideal send buffer size is indicated in this struct/union. ByteCount Ideal send buffer size in bytes for each StreamSend operation to avoid idling the connection. QUIC_STREAM_EVENT_PEER_ACCEPTED This event is raised when a peer has provided sufficient flow control to accept a new stream. See StreamStart for additional information. QUIC_STREAM_EVENT_CANCEL_ON_LOSS This event is raised when a stream is shutdown due to packet loss. See Cancel on Loss for further details. CANCEL_ON_LOSS The application can supply an error code in this struct to be sent to the peer. ErrorCode The application can set this 62 bit error code to communicate to the peer about the stream shutdown, which is received by the peer as a QUIC_STREAM_EVENT_PEER_SEND_ABORTED event on its stream object. QUIC_STREAM_EVENT_RECEIVE_BUFFER_NEEDED This event is raised when a stream using app-provided receive buffers runs out of receive buffer space. BufferLengthNeeded The number of bytes MsQuic needs to be able to store the received data. When receiving this notification, the app can: provide a sufficient amount of buffer space inline from the callback using StreamProvideReceiveBuffers shutdown the stream receive direction of the stream inline by calling StreamShutdown with the QUIC_STREAM_SHUTDOWN_FLAG_INLINE flag Otherwise, the connection will be closed abortively. See App-Owned Buffer Mode for further details. See Also Streams StreamOpen StreamStart StreamSend StreamShutdown QUIC_STREAM_CALLBACK SetCallbackHandler SetContext"
  },
  "docs/api/RegistrationClose.html": {
    "href": "docs/api/RegistrationClose.html",
    "title": "RegistrationClose function",
    "summary": "RegistrationClose function Closes an existing registration. Syntax typedef _IRQL_requires_max_(PASSIVE_LEVEL) void (QUIC_API * QUIC_REGISTRATION_CLOSE_FN)( _In_ _Pre_defensive_ __drv_freesMem(Mem) HQUIC Registration ); Parameters Registration A registration handle from a previous call to RegistrationOpen. Remarks The application must close/delete all child configurations and connection objects before closing the registration. This call will block on those outstanding objects being cleaned up. Do not call it on any MsQuic event callback or a thread that would otherwise be running an external execution context, or it will deadlock. See Also RegistrationOpen (Preview) RegistrationClose2"
  },
  "docs/api/RegistrationClose2.html": {
    "href": "docs/api/RegistrationClose2.html",
    "title": "RegistrationClose2 function",
    "summary": "RegistrationClose2 function Preview This routine is in preview and is subject to breaking changes. Closes an existing registration asynchronously. Syntax typedef _Function_class_(QUIC_REGISTRATION_CLOSE_CALLBACK) void (QUIC_API QUIC_REGISTRATION_CLOSE_CALLBACK)( _In_opt_ void* Context ); typedef QUIC_REGISTRATION_CLOSE_CALLBACK *QUIC_REGISTRATION_CLOSE_CALLBACK_HANDLER; typedef _IRQL_requires_max_(PASSIVE_LEVEL) void (QUIC_API * QUIC_REGISTRATION_CLOSE2_FN)( _In_ _Pre_defensive_ __drv_freesMem(Mem) HQUIC Registration, _In_ _Pre_defensive_ QUIC_REGISTRATION_CLOSE_CALLBACK_HANDLER Handler, _In_opt_ void* Context ); Parameters Registration A registration handle from a previous call to RegistrationOpen. Handler A registration close completion handler. It will be invoked exactly once upon completion of the registration close request. Context The context to provide to the close completion handler. Remarks Preview This routine is in preview and is subject to breaking changes. The application should close/delete all child configurations and connection objects before closing the registration. This request will not complete until those outstanding objects are cleaned up. See Also RegistrationOpen"
  },
  "docs/api/RegistrationOpen.html": {
    "href": "docs/api/RegistrationOpen.html",
    "title": "RegistrationOpen function",
    "summary": "RegistrationOpen function Creates a new registration. Syntax typedef _IRQL_requires_max_(PASSIVE_LEVEL) QUIC_STATUS (QUIC_API * QUIC_REGISTRATION_OPEN_FN)( _In_opt_ const QUIC_REGISTRATION_CONFIG* Config, _Outptr_ _At_(*Registration, __drv_allocatesMem(Mem)) _Pre_defensive_ HQUIC* Registration ); Parameters Config An optional QUIC_REGISTRATION_CONFIG to specify how to configure the execution context of the registration. Registration On success, returns a handle to the newly created registration. Return Value The function returns a QUIC_STATUS. The app may use QUIC_FAILED or QUIC_SUCCEEDED to determine if the function failed or succeeded. Remarks A registration represents an execution context for the application. This consists of one or more system threads that are used to process the protocol logic for the application's connections. Each execution context is completely independent from another. This allows for different applications in the same process (or kernel space) to execute generally independent. A caveat to this independence is that until a packet or connection can be determined to belong to a particular registration there is shared processing. See Also RegistrationClose (Preview) RegistrationClose2"
  },
  "docs/api/RegistrationShutdown.html": {
    "href": "docs/api/RegistrationShutdown.html",
    "title": "RegistrationShutdown function",
    "summary": "RegistrationShutdown function Starts the shutdown process for all connections in the registration. Syntax typedef _IRQL_requires_max_(DISPATCH_LEVEL) void (QUIC_API * QUIC_REGISTRATION_SHUTDOWN_FN)( _In_ _Pre_defensive_ HQUIC Registration, _In_ QUIC_CONNECTION_SHUTDOWN_FLAGS Flags, _In_ _Pre_defensive_ QUIC_UINT62 ErrorCode // Application defined error code ); Parameters Registration The valid handle to an open registration object. Flags The flags that control the behavior of the shutdown. Value Meaning QUIC_CONNECTION_SHUTDOWN_FLAG_NONE 0 The connection is shutdown gracefully and informs the peer. QUIC_CONNECTION_SHUTDOWN_FLAG_SILENT 1 The connection is immediately shutdown without informing the peer. ErrorCode The 62-bit error code to indicate to the peer as the reason for the shutdown. Remarks TODO See Also RegistrationOpen RegistrationClose ConnectionShutdown (Preview) RegistrationClose2"
  },
  "docs/api/SetCallbackHandler.html": {
    "href": "docs/api/SetCallbackHandler.html",
    "title": "SetCallbackHandler function",
    "summary": "SetCallbackHandler function Sets the application context and callback function pointer for the API object. Syntax typedef _IRQL_requires_max_(DISPATCH_LEVEL) void (QUIC_API * QUIC_SET_CALLBACK_HANDLER_FN)( _In_ _Pre_defensive_ HQUIC Handle, _In_ void* Handler, _In_opt_ void* Context ); Parameters Handle The valid handle to any API object that uses callback handlers. This includes handles to listener, connection and stream objects. Handler A new application callback handler to register with the API object. Context A new application context to register with the API object. Remarks This function allows the app to set the application callback handler and context for the API object. The context can be later retrieved by a call to GetContext. It is also passed into all callback handler events for the object. Important There is no internal synchronization for this callback handler or context. If the app calls GetContext, SetContext and/or SetCallbackHandler on different threads, it must provide for the necessary synchronization mechanisms. See Also GetContext SetContext"
  },
  "docs/api/SetContext.html": {
    "href": "docs/api/SetContext.html",
    "title": "SetContext function",
    "summary": "SetContext function Sets the application context for the API object. Syntax typedef _IRQL_requires_max_(DISPATCH_LEVEL) void (QUIC_API * QUIC_SET_CONTEXT_FN)( _In_ _Pre_defensive_ HQUIC Handle, _In_opt_ void* Context ); Parameters Handle The valid handle to any API object. This includes handles to registration, configuration, listener, connection and stream objects. Context A new application context to register with the API object. Remarks This function allows the app to set the application context for the API object. This context can be later retrieved by a call to GetContext. It is also passed into all callback handler events for the object. Important There is no internal synchronization for this context. If the app calls GetContext, SetContext and/or SetCallbackHandler on different threads, it must provide for the necessary synchronization mechanisms. See Also GetContext SetCallbackHandler"
  },
  "docs/api/SetParam.html": {
    "href": "docs/api/SetParam.html",
    "title": "SetParam function",
    "summary": "SetParam function Sets a parameter on an API object. Syntax typedef _IRQL_requires_max_(PASSIVE_LEVEL) QUIC_STATUS (QUIC_API * QUIC_SET_PARAM_FN)( _When_(QUIC_PARAM_IS_GLOBAL(Param), _Reserved_) _When_(!QUIC_PARAM_IS_GLOBAL(Param), _In_ _Pre_defensive_) HQUIC Handle, _In_ uint32_t Param, _In_ uint32_t BufferLength, _In_reads_bytes_(BufferLength) const void* Buffer ); Parameters Handle The valid handle to any API object. This includes handles to registration, configuration, listener, connection and stream objects. For global parameters, this parameter must be NULL. Param The parameter for which the value is to be set (for example, QUIC_PARAM_CONN_IDLE_TIMEOUT). BufferLength A pointer to the size, in bytes, of the Buffer buffer. Buffer A pointer to the buffer in which the value for the requested option is to be returned. Return Value The function returns a QUIC_STATUS. The app may use QUIC_FAILED or QUIC_SUCCEEDED to determine if the function failed or succeeded. Remarks TODO See Also Settings GetParam"
  },
  "docs/api/StreamClose.html": {
    "href": "docs/api/StreamClose.html",
    "title": "StreamClose function",
    "summary": "StreamClose function Closes an existing stream. Syntax typedef _IRQL_requires_max_(PASSIVE_LEVEL) void (QUIC_API * QUIC_STREAM_CLOSE_FN)( _In_ _Pre_defensive_ __drv_freesMem(Mem) HQUIC Stream ); Parameters Stream A Stream handle from a previous call to StreamOpen. Remarks The application should only close a stream after it has been completely shut down or if it was never successfully started. Closing a stream before it has been completely shut down produces undefined behavior because clean up of the stream must be reflected on the wire with an application specific error code. When the app closes a stream without first shutting down, MsQuic has to guess which error code to use (currently uses 0) when sending the state change to the peer. If the application needs to quickly discard all stream state and doesn't care about the result, it should first call StreamShutdown with the QUIC_STREAM_SHUTDOWN_FLAG_ABORT and QUIC_STREAM_SHUTDOWN_FLAG_IMMEDIATE flags, specifying an appropriate error code. Then, only after the QUIC_STREAM_EVENT_SHUTDOWN_COMPLETE should the app call close. This event will happen immediately. StreamClose may be called on any callback, including one for the stream being closed. StreamClose is equivalent to free and MUST be the final call on a stream handle. Any API calls using a stream handle after StreamClose has been called is a use-after-free error! See Also StreamOpen StreamStart StreamShutdown StreamSend StreamReceiveComplete StreamReceiveSetEnabled"
  },
  "docs/api/StreamOpen.html": {
    "href": "docs/api/StreamOpen.html",
    "title": "StreamOpen function",
    "summary": "StreamOpen function Creates a new stream. Syntax typedef _IRQL_requires_max_(DISPATCH_LEVEL) QUIC_STATUS (QUIC_API * QUIC_STREAM_OPEN_FN)( _In_ _Pre_defensive_ HQUIC Connection, _In_ QUIC_STREAM_OPEN_FLAGS Flags, _In_ _Pre_defensive_ QUIC_STREAM_CALLBACK_HANDLER Handler, _In_opt_ void* Context, _Outptr_ _At_(*Stream, __drv_allocatesMem(Mem)) _Pre_defensive_ HQUIC* Stream ); Parameters Connection The valid handle to an open connection object. The connection does not need to be started via ConnectionStart. Flags A set of flags that control the behavior of StreamOpen: Value Meaning QUIC_STREAM_OPEN_FLAG_NONE 0 No special behavior. Defaults to bidirectional stream. QUIC_STREAM_OPEN_FLAG_UNIDIRECTIONAL 1 Opens a unidirectional stream. QUIC_STREAM_OPEN_FLAG_0_RTT 2 Indicates that the stream may be sent in 0-RTT. QUIC_STREAM_OPEN_FLAG_DELAY_ID_FC_UPDATES 4 Indicates stream ID flow control limit updates for the connection should be delayed to StreamClose. QUIC_STREAM_OPEN_FLAG_APP_OWNED_BUFFERS 5 Receive buffers are owned by the app and will be provided using StreamProvideReceiveBuffers. MsQuic won't allocate any buffers for the stream. Handler A pointer to the app's callback handler to be invoked for all stream events. Context The app context pointer (possibly null) to be associated with the stream object and passed back to the app's handler when invoked. Stream On success, returns a handle to the newly created stream. Return Value The function returns a QUIC_STATUS. The app may use QUIC_FAILED or QUIC_SUCCEEDED to determine if the function failed or succeeded. Remarks This function is used to allocate a new stream object of the desired directionality; either bidirectional (both sides send and receive) or unidirectional (opener sends and peer receives). This function simply allocates the object and does not assign a stream ID or inform the peer that the stream was created. As indicated above, the parent connection object does not need to be started before the stream can be created. In fact, the MsQuic API is expressly designed to allow for the app to open streams, start them and queue data to be sent before starting the stream. In the 0-RTT scenario, this is practically required to ensure all the data is packed into the same UDP datagram(s). Important - No events are delivered on the stream until the app calls StreamStart (because of the race conditions that could occur) and it succeeds. This means that if the parent connection is shutdown (e.g. idle timeout or peer initiated) before calling StreamStart then the QUIC_STREAM_EVENT_SHUTDOWN_COMPLETE will not be delivered. So, apps that rely on that event to trigger clean up of the stream must handle the case where StreamStart is either not ever called or fails and clean up directly. See Also StreamClose StreamStart StreamShutdown StreamSend StreamReceiveComplete StreamReceiveSetEnabled"
  },
  "docs/api/StreamProvideReceiveBuffers.html": {
    "href": "docs/api/StreamProvideReceiveBuffers.html",
    "title": "StreamProvideReceiveBuffers function",
    "summary": "StreamProvideReceiveBuffers function Preview feature: This API is in preview. It should be considered unstable and can be subject to breaking changes. Provide application-owned buffers to MsQuic to store received data. It should be called only for a stream in app-owned buffer mode. Syntax typedef _IRQL_requires_max_(DISPATCH_LEVEL) QUIC_STATUS (QUIC_API * QUIC_STREAM_PROVIDE_RECEIVE_BUFFERS_FN)( _In_ _Pre_defensive_ HQUIC Stream, _In_ uint32_t BufferCount, _In_reads_(BufferCount) const QUIC_BUFFER* Buffers ); Parameters Stream: A handle to the stream BufferCount: The number of buffers provided Buffers: An array of QUIC_BUFFERs pointing to the memory buffers Remarks This is an asynchronous API but it can run inline if called in a callback. If called inline when handling a QUIC_CONNECTION_EVENT_PEER_STREAM_STARTED event, it will convert the stream to app-owned buffer mode. If called inline when handling a QUIC_STREAM_EVENT_RECEIVE_BUFFER_NEEDED event, the provided memory buffers will be used to store the received data. See also Streams StreamOpen Preview Features"
  },
  "docs/api/StreamReceiveComplete.html": {
    "href": "docs/api/StreamReceiveComplete.html",
    "title": "StreamReceiveComplete function",
    "summary": "StreamReceiveComplete function Completes a receive that was previously pended. Syntax typedef _IRQL_requires_max_(DISPATCH_LEVEL) void (QUIC_API * QUIC_STREAM_RECEIVE_COMPLETE_FN)( _In_ _Pre_defensive_ HQUIC Stream, _In_ uint64_t BufferLength ); Parameters Stream: A handle to a valid stream BufferLength: The number of bytes processed by the application Remarks This is an asynchronous API but can run inline if called in a callback. Default behavior The application must ensure that for each QUIC_STREAM_EVENT_RECEIVE processed asynchronously (QUIC_STATUS_PENDING was returned from the callback), StreamReceiveComplete is called exactly once. The application must ensure it calls StreamReceiveComplete a single time for every QUIC_STREAM_EVENT_RECEIVE processed asynchronously. Duplicate StreamReceiveComplete calls are ignored silently if no QUIC_STREAM_EVENT_RECEIVE is pending when the call is processed, but they could race with a new QUIC_STREAM_EVENT_RECEIVE event and complete it, likely breaking the app data processing. If BufferLength is smaller than the number of bytes indicated in the matching QUIC_STREAM_EVENT_RECEIVE, MsQuic will stop indicating new QUIC_STREAM_EVENT_RECEIVE events until a call to StreamReceiveSetEnabled. Multi-receive Mode If Multi-receive mode has been enabled on the connection, the behavior is different from default behavior detailed above. In Multi-receive mode, calls to StreamReceiveComplete do not need to match QUIC_STREAM_EVENT_RECEIVE: there can be either more or fewer calls to StreamReceiveComplete than QUIC_STREAM_EVENT_RECEIVE events. MsQuic will keep on indicating QUIC_STREAM_EVENT_RECEIVE irrespectively from calls to StreamReceiveComplete and the value of BufferLength. The application must keep track of the accumulated TotalBufferLength from QUIC_STREAM_EVENT_RECEIVE events and ensure that: the sum of all BufferLength parameters in StreamReceiveComplete calls is always smaller or equal than the number of bytes received on the stream all bytes received are eventually completed in StreamReceiveComplete call OR the stream is aborted. See Also StreamOpen StreamClose StreamStart StreamShutdown StreamSend StreamReceiveSetEnabled"
  },
  "docs/api/StreamReceiveSetEnabled.html": {
    "href": "docs/api/StreamReceiveSetEnabled.html",
    "title": "StreamReceiveSetEnabled function",
    "summary": "StreamReceiveSetEnabled function Enables or disables receive callbacks on a stream. Syntax typedef _IRQL_requires_max_(DISPATCH_LEVEL) QUIC_STATUS (QUIC_API * QUIC_STREAM_RECEIVE_SET_ENABLED_FN)( _In_ _Pre_defensive_ HQUIC Stream, _In_ BOOLEAN IsEnabled ); Parameters Stream: A handle to a valid stream IsEnabled: Whether MsQuic can indicate QUIC_STREAM_EVENT_RECEIVE notifications. Return Value The function returns a QUIC_STATUS. The app may use QUIC_FAILED or QUIC_SUCCEEDED to determine if the function failed or succeeded. Remarks This function always delegates to the worker queue, even if called from a quic worker thread. This matters if disabling receives, as there could be a receive in the queue before this call is processed, and that receive would still indicated to the app. To disable receives reliably, reject a receive by draining 0 bytes in the QUIC_STREAM_EVENT_RECEIVE callback. See Also StreamOpen StreamClose StreamStart StreamShutdown StreamSend StreamReceiveComplete Streams"
  },
  "docs/api/StreamSend.html": {
    "href": "docs/api/StreamSend.html",
    "title": "StreamSend function",
    "summary": "StreamSend function Queues app data to be sent on a stream. Syntax typedef _IRQL_requires_max_(DISPATCH_LEVEL) QUIC_STATUS (QUIC_API * QUIC_STREAM_SEND_FN)( _In_ _Pre_defensive_ HQUIC Stream, _In_reads_(BufferCount) _Pre_defensive_ const QUIC_BUFFER* const Buffers, _In_ uint32_t BufferCount, _In_ QUIC_SEND_FLAGS Flags, _In_opt_ void* ClientSendContext ); Parameters Stream The valid handle to an open stream object. Buffers An array of QUIC_BUFFER structs that each contain a pointer and length to app data to send on the stream. This may be NULL only if BufferCount is zero. BufferCount The number of QUIC_BUFFER structs in the Buffers array. This may be zero. Flags The set of flags the controls the behavior of StreamSend: Value Meaning QUIC_SEND_FLAG_NONE 0 No special behavior. Data is not allowed in 0-RTT by default. QUIC_SEND_FLAG_ALLOW_0_RTT 1 Indicates that the data is allowed to be sent in 0-RTT (if available). Makes no guarantee the data will be sent in 0-RTT. Additionally, even if 0-RTT keys are available the data may end up being sent in 1-RTT for multiple reasons. QUIC_SEND_FLAG_START 2 Indicates that the stream should asynchronously start (equivalent to calling StreamStart). QUIC_SEND_FLAG_FIN 4 Indicates the the stream send is the last or final data to be sent on the stream and should be gracefully shutdown (equivalent to calling StreamShutdown with the QUIC_STREAM_SHUTDOWN_FLAG_GRACEFUL flag). QUIC_SEND_FLAG_DGRAM_PRIORITY 8 Unused and ignored for StreamSend QUIC_SEND_FLAG_DELAY_SEND 16 Provides a hint to MsQuic to indicate the data does not need to be sent immediately, likely because more is soon to follow. QUIC_SEND_FLAG_CANCEL_ON_LOSS 32 Informs MsQuic to irreversibly mark the associated stream to be canceled when packet loss has been detected on it. I.e., all sends on a given stream are subject to this behavior from the moment the flag has been supplied for the first time. QUIC_SEND_FLAG_CANCEL_ON_BLOCKED 64 Unused and ignored for StreamSend for now ClientSendContext The app context pointer (possibly null) to be associated with the send. Return Value The function returns a QUIC_STATUS. The app may use QUIC_FAILED or QUIC_SUCCEEDED to determine if the function failed or succeeded. Remarks This function is used to queue data on a stream to be sent. The function itself is non-blocking and simply queues the data and returns. The app may pass zero or more buffers of data that will be sent on the stream in the order they are passed. The buffers (both the QUIC_BUFFERs and the memory they reference) are \"owned\" by MsQuic (and must not be modified by the app) until MsQuic indicates the QUIC_STREAM_EVENT_SEND_COMPLETE event for the send. By default, data queued via StreamSend is not allowed to be sent in 0-RTT packets, but the app may override this by passing the QUIC_SEND_FLAG_ALLOW_0_RTT flag. This flag indicates that the data is acceptable to be sent in a 0-RTT packet, but does not guarantee that data will be sent in 0-RTT. There are several reasons it may not be sent in 0-RTT: The 0-RTT keys were not available. The server rejected 0-RTT data for some reason. Too much data was queued and it couldn't all fit. The data was sent, but eventually found to have been lost and retransmitted in a 1-RTT packet. Some apps may open and send on many different streams at a very high rate. In these scenarios, having to call StreamStart and StreamShutdown for every stream adds unwanted performance overhead. In order to optimize these scenarios, StreamStart supports the QUIC_SEND_FLAG_START and QUIC_SEND_FLAG_FIN flags, which allows the app to do something like this: HQUIC Stream; MsQuic->StreamOpen( Connection, QUIC_STREAM_OPEN_FLAG_UNIDIRECTIONAL, AppHandler, AppContext, &Stream); MsQuic->StreamSend( Stream, &AppData, 1, QUIC_SEND_FLAG_START | QUIC_SEND_FLAG_FIN, AppSendContext); Note For the sake of brevity, error handling and clean up has been omitted. This example opens a new unidirectional stream, and queues a send that starts the stream, sends some app data and gracefully closes the stream. In some scenarios, the app may know that additional data (possibly on a different stream) will soon be queued after the current call to StreamSend. In these cases it may be helpful for the app to pass the QUIC_SEND_FLAG_DELAY_SEND flag to hint that MsQuic should wait for more data before flushing the connection-wide send queue. Note that anything else on the connection might still end up triggering the send to flush. The app may call StreamSend (on any stream) with a null/empty buffer with QUIC_SEND_FLAG_DELAY_SEND unset to force a flush. Important: Data queued via StreamSend with the QUIC_SEND_FLAG_DELAY_SEND flag is not guaranteed to be sent until a subsequent StreamSend call on any stream is performed without the QUIC_SEND_FLAG_DELAY_SEND flag. For additional information on sending on streams see here. See Also StreamOpen StreamClose StreamStart StreamShutdown StreamReceiveComplete StreamReceiveSetEnabled"
  },
  "docs/api/StreamShutdown.html": {
    "href": "docs/api/StreamShutdown.html",
    "title": "StreamShutdown function",
    "summary": "StreamShutdown function Starts the shutdown process on a stream. Syntax typedef _IRQL_requires_max_(DISPATCH_LEVEL) QUIC_STATUS (QUIC_API * QUIC_STREAM_SHUTDOWN_FN)( _In_ _Pre_defensive_ HQUIC Stream, _In_ QUIC_STREAM_SHUTDOWN_FLAGS Flags, _In_ _Pre_defensive_ QUIC_UINT62 ErrorCode // Application defined error code ); Parameters Stream The valid handle to an open and started stream object. Flags The set of flags that controls the type and behavior of shutdown: Value Meaning QUIC_STREAM_SHUTDOWN_FLAG_NONE 0 Invalid option for StreamShutdown. QUIC_STREAM_SHUTDOWN_FLAG_GRACEFUL 1 Indicates the app is gracefully shutting down the stream in the send direction. QUIC_STREAM_SHUTDOWN_FLAG_ABORT_SEND 2 Indicates the app is abortively shutting down the stream in the send direction. QUIC_STREAM_SHUTDOWN_FLAG_ABORT_RECEIVE 4 Indicates the app is abortively shutting down the stream in the receive direction. QUIC_STREAM_SHUTDOWN_FLAG_IMMEDIATE 8 Indicates the app does not want to wait for the acknowledgment of the shutdown before getting the QUIC_STREAM_EVENT_SHUTDOWN_COMPLETE event. Only allowed for abortive shutdowns. QUIC_STREAM_SHUTDOWN_FLAG_INLINE 10 Indicates that the stream shutdown should be processed inmediately inline. This in only applicable for calls made within callbacks. WARNING: It can cause reentrant callbacks! QUIC_STREAM_SHUTDOWN_FLAG_ABORT is provided as a helper and is simply a logic OR of QUIC_STREAM_SHUTDOWN_FLAG_ABORT_SEND and QUIC_STREAM_SHUTDOWN_FLAG_ABORT_RECEIVE. ErrorCode Used for the abortive shutdown cases (QUIC_STREAM_SHUTDOWN_FLAG_ABORT_SEND and QUIC_STREAM_SHUTDOWN_FLAG_ABORT_RECEIVE) to indicate the reason why the abort happened to the peer. Return Value The function returns a QUIC_STATUS. The app may use QUIC_FAILED or QUIC_SUCCEEDED to determine if the function failed or succeeded. Remarks This function allows an app to (either gracefully or abortively) shut down one or both directions of a stream. For abortive shutdowns, the app specifies an ErrorCode that is transmitted to the peer to indicate why the shutdown happened. Graceful shutdowns have no error code as they are implied to be the normal operation of a stream. If the app doesn't care to wait for the acknowledgment of an abortive shutdown, it can use the QUIC_STREAM_SHUTDOWN_FLAG_IMMEDIATE flag, which will result in MsQuic immediately (not necessarily inline to the call though) indicating the QUIC_STREAM_EVENT_SHUTDOWN_COMPLETE event to the app, after which, the app may safely StreamClose the stream. MsQuic will internally maintain the stream for as long as necessary and then clean it up. The stream can also be gracefully shutdown via the QUIC_SEND_FLAG_FIN flag. See StreamSend for more details. Any stream (even one that hasn't been started) may be called to shutdown. If the stream has not been started yet, then the shutdown is effectively queued. If the app never calls StreamStart then the shutdown will never been sent out on the wire. Reliable Reset If an app decides to enable Preview Features, the shutdown path can be configured with the QUIC_PARAM_STREAM_RELIABLE_OFFSET Stream parameter, which determines the number of bytes a sender must deliver before it can shut down their SEND path. See Also StreamOpen StreamClose StreamStart StreamSend StreamReceiveComplete StreamReceiveSetEnabled"
  },
  "docs/api/StreamStart.html": {
    "href": "docs/api/StreamStart.html",
    "title": "StreamStart function",
    "summary": "StreamStart function Assigns an ID and starts processing the stream. Syntax typedef _IRQL_requires_max_(PASSIVE_LEVEL) QUIC_STATUS (QUIC_API * QUIC_STREAM_START_FN)( _In_ _Pre_defensive_ HQUIC Stream, _In_ QUIC_STREAM_START_FLAGS Flags ); Parameters Stream The valid handle to an open stream object. Flags The set of flags the controls the behavior of StreamStart: Value Meaning QUIC_STREAM_START_FLAG_NONE 0 No special behavior. Executes as a blocking call, returning only after the operation has completed. The peer is not informed of the stream starting until the app sends data. QUIC_STREAM_START_FLAG_IMMEDIATE 1 Indicates that the peer should be immediately informed of the stream opening (or at least as soon as flow control allows) and not wait for any data to be sent first. QUIC_STREAM_START_FLAG_FAIL_BLOCKED 2 Only opens the stream if flow control (from the peer) allows. If the stream count limit has currently been reached the start will fail with QUIC_STATUS_STREAM_LIMIT_REACHED. QUIC_STREAM_START_FLAG_SHUTDOWN_ON_FAIL 4 Causes the stream to immediate shutdown (abortive) if the start operation fails. QUIC_STREAM_START_FLAG_INDICATE_PEER_ACCEPT 8 Indicates the app wants the QUIC_STREAM_EVENT_PEER_ACCEPTED event to be delivered if the stream isn't initially accepted (allowed by flow control) at start completion. Return Value The function returns a QUIC_STATUS. The app may use QUIC_FAILED or QUIC_SUCCEEDED to determine if the function failed or succeeded. Remarks This function starts the processing of the stream by the connection. Once called, the stream can start receiving events to the handler passed into StreamOpen. If the start operation fails, the only event that will be delivered is QUIC_STREAM_EVENT_START_COMPLETE with the failure status code. The first step of the start process is assigning the stream an identifier (stream ID). The stream ID space is flow controlled, meaning the peer is able to control how many streams the app can open (on-wire). Though, even if the peer won't accept any more streams currently, this API (by default) allows the app to still start the stream and assigns a local stream ID. But in this case, the stream is just queued locally until the peer will accept it. If the app does not want the queuing behavior, and wishes to fail instead, it can use the QUIC_STREAM_START_FLAG_FAIL_BLOCKED flag. If there is not enough flow control to allow the stream to be sent on the wire, then the start will fail (via a QUIC_STREAM_EVENT_START_COMPLETE event) with the QUIC_STATUS_STREAM_LIMIT_REACHED status. The QUIC_STREAM_START_FLAG_INDICATE_PEER_ACCEPT flag can be used to get the QUIC_STREAM_EVENT_PEER_ACCEPTED event to know when the stream becomes unblocked by flow control. If the peer already provided enough flow control to accept the stream when it was initially started, the QUIC_STREAM_EVENT_PEER_ACCEPTED event is not delivered and the QUIC_STREAM_EVENT_START_COMPLETE's PeerAccepted field will be TRUE. If is not initially accepted, if/once the peer provides enough flow control to allow the stream to be sent on the wire, then the QUIC_STREAM_EVENT_PEER_ACCEPTED event will be indicated to the app. The stream can also be started via the QUIC_SEND_FLAG_START flag. See StreamSend for more details. Important - No events are delivered on the stream until the app calls StreamStart (because of the race conditions that could occur) and it succeeds. This means that if the parent connection is shutdown (e.g. idle timeout or peer initiated) before calling StreamStart then the QUIC_STREAM_EVENT_SHUTDOWN_COMPLETE will not be delivered. So, apps that rely on that event to trigger clean up of the stream must handle the case where StreamStart is either not ever called or fails and clean up directly. See Also StreamOpen StreamClose StreamShutdown StreamSend StreamReceiveComplete StreamReceiveSetEnabled"
  },
  "index.html": {
    "href": "index.html",
    "title": "MsQuic Documentation With DocFx:",
    "summary": "MsQuic Documentation With DocFx: Why? A Better Search Experience. Taking Advantage of built-in indexing offered by DocFx, and the nice UI configuration options (light / dark) mode, makes debugging a little less painful. Try out the search feature! Try out dark mode! Chatbot coming soon!"
  },
  "src/fuzzing/README.html": {
    "href": "src/fuzzing/README.html",
    "title": "Fuzzing",
    "summary": "Fuzzing This directory is used for fuzzing. OSS-Fuzz automatically builds, runs and reports issue if there is any problem. Write fuzzing OSS-Fuzz uses LibFuzzer by default which is included in clang. Refer Libfuzzer official document if you want more detail. Run locally You can build and run code by yourself. OSS-Fuzz offers convenient scripts cd $PATH_TO_OSS_FUZZ # build Docker image python infra/helper.py build_image msquic # build fuzzing code, memory sanitizer is not supported yet python infra/helper.py build_fuzzers --sanitizer <address/memory/undefined> msquic # run fuzzing python infra/helper.py run_fuzzer msquic $YOUR_COOL_FUZZING Refer OSS-Fuzz official document for more detail Reproduce and debug issue Prep Download test case file from oss-fuzz issue ticket from OSS-Fuzz issues Build base image for repro and debug export TESTFILE=$YOUR_TEST_FILE git clone --depth=1 https://github.com/google/oss-fuzz.git cd oss-fuzz python infra/helper.py pull_images python infra/helper.py build_image msquic python infra/helper.py build_fuzzers --sanitizer <address/memory/undefined> msquic Reproduce issue Reproduce issue with spinquic cd oss-fuzz python infra/helper.py reproduce msquic spinquic $TESTFILE Debug issue cd oss-fuzz cp $TESTFILE build/out/msquic/testcase # Launch docker container python3 infra/helper.py shell base-runner-debug # Run gdb in the container gdb --args /out/msquic/spinquic /out/msquic/testcase Refer links for more details Reproduce Debug Monitor your fuzzing Once fuzzing is deployed on OSS-Fuzz infra, it continuously run and report issue if it detects Receive notification List your email under auto_ccs or vendor_ccs section in project.yaml Most of developer should be under vendor_ccs. Please follow instruction in vendor_ccs and feel free to create PR and let us know on issue or discussion. Login OSS-Fuzz dashabord Your email need to be associated with google account Before adding change.... Please go to msquic project directory in OSS-Fuzz whether your change can be run without issue. You might need to change Dockerfile and/or build.sh for installing libraries, COPYing fuzzing source, configuration files and build options."
  },
  "src/perf/readme.html": {
    "href": "src/perf/readme.html",
    "title": "Secured Network Performance Testing",
    "summary": "Secured Network Performance Testing SecNetPerf is the standard (cross-platform) tool used for performance testing of MsQuic. It implements the protocol defined here. This protocol defines a generic interface that allows for client-driven performance testing. Server The server generally is meant to be run zero or minimal additional arguments. > secnetperf or perhaps the following for high throughput tests: > secnetperf -exec:maxtput There are all the arguments that can be passed to the server: Argument Usage Meaning bind -bind:<address> Binds to the specified local address. cc -cc:<cubic,bbr> Congestion control algorithm used. cibir -cibir:<hex_bytes> The well-known CIBIR identifier. cipher -cipher:<value> Decimal value of 1 or more QUIC_ALLOWED_CIPHER_SUITE_FLAGS. cpu -cpu:<cpu_indexes> Comma-separated list of CPUs to run on. ecn -ecn:<0,1> Enables sender-side ECN support. dscp -dscp:<0-63> Sets DSCP value used for outgoing traffic. exec -exec:<lowlat,maxtput,scavenger,realtime> The execution profile used for the application. pollidle -pollidle:<time_us> The time, in microseconds, to poll while idle before sleeping (falling back to interrupt-driven IO). stats -stats:<0,1> Prints out statistics at the end of each connection. delay [-delay:<value>[units]] Delay, with an optional unit (def unit is us), to be introduced before the server responds to a request. delayType [-delayType:<fixed,variable>] Optional delay type can be specified in conjunction with the 'delay' argument. 'fixed' introduces the specified delay for each request (default). 'variable' introduces a statistical variability to the specified delay (user mode only). Client Since tests are client-driven, the client side of secnetperf generally has several arguments passed in to specify which scenarios to run. For example, for a simple download test: > secnetperf -target:perf-server -down:1gb or for a repeated request/response style exchange > secnetperf -target:perf-server -rstream:1 -run:10s -up:500 -down:4000 The target must be specified to indicate the hostname of the server to connect to. Note that server, to, remote, and peer are all aliases for target. Remote Options The following options configure the behavior around connecting to the remote peer: Alias Usage Meaning ip, af -ip:<0,4,6> A address family hint for resolving the hostname to IP address. port -port:<value> The UDP port of the remote peer. cibir -cibir:<hex_bytes> The well-known CIBIR identifier. incttarget -inctarget:<0,1> Set to 1 to append core index to target hostname. Local Options The following options configure the behavior related to local execution: Alias Usage Meaning threads -threads:<value> The max number of worker threads to use. affinitize -affinitize:<0,1> Affinitizes worker threads to a core. comp -comp:<value> The network compartment ID to run in. Windows Only bind -bind:<addr(s)> The local IP address(es)/port(s) to bind to. share -share:<0,1> Set to 1 to append core index to target hostname. General Configuration Options The following options control various general configuration options: Alias Usage Meaning tcp -tcp:<0,1> Disables/enables TCP usage (instead of QUIC). encrypt -encrypt:<0,1> Disables/enables encryption. pacing -pacing:<0,1> Disables/enables send pacing. sendbuf -sendbuf:<0,1> Disables/enables send buffering. dscp -dscp:<0-63> Sets DSCP value used for outgoing traffic. ptput -ptput:<0,1> Print throughput information. pconnection, pconn -pconn:<0,1> Print connection statistics. pstream -pstream:<0,1> Print stream statistics. platency, plat -platency:<0,1> Print latency statistics. praw -praw:<0,1> Print raw information. Scenario Options The following options configure the various scenario behaviors: Alias Usage Meaning conns -conns:<value> The number of connections to use. streams, requests -streams:<value> The number of streams to send on at a time. upload, up, request -upload:<value>[units] The length of bytes (or optional time or length unit) to send on each stream. download, down, response -download:<value>[units] The length of bytes (or optional time or length unit) to receive on each stream. iosize -iosize:<value> The size of each send request queued. rconn, rc -rconn:<0,1> Repeat the scenario at the connection level. rstream, rs -rstream:<0,1> Repeat the scenario at the stream level. runtime, run, time -runtime:<value>[units] The total runtime (in us, or optional unit). Only relevant for repeat scenarios. Example Scenarios Download for 5 seconds, printing throughput information > secnetperf -target:localhost -exec:maxtput -down:5s -ptput:1 Started! Download: 2996595053 bytes @ 4793496 kbps (5001.101 ms). App Main returning status 0 Upload for 1 MB on 10 different streams, printing throughput information > secnetperf -target:localhost -exec:maxtput -up:10mb -streams:10 -ptput:1 Started! Upload: 10000000 bytes @ 1517393 kbps (52.722 ms). Upload: 10000000 bytes @ 1513403 kbps (52.861 ms). Upload: 10000000 bytes @ 1055868 kbps (75.767 ms). Upload: 10000000 bytes @ 655189 kbps (122.102 ms). Upload: 10000000 bytes @ 458289 kbps (174.562 ms). Upload: 10000000 bytes @ 457202 kbps (174.977 ms). Upload: 10000000 bytes @ 404422 kbps (197.813 ms). Upload: 10000000 bytes @ 403960 kbps (198.039 ms). Upload: 10000000 bytes @ 403632 kbps (198.200 ms). Upload: 10000000 bytes @ 403057 kbps (198.483 ms). App Main returning status 0 Upload for 10 seconds on 10 different connections, printing throughput information > secnetperf -target:localhost -exec:maxtput -up:10s -conns:10 -ptput:1 Started! Upload: 3590914048 bytes @ 2869166 kbps (10012.423 ms). Upload: 3586523136 bytes @ 2865446 kbps (10013.163 ms). Upload: 1803091968 bytes @ 1439601 kbps (10019.950 ms). Upload: 1765015552 bytes @ 1408638 kbps (10023.949 ms). Upload: 1161232384 bytes @ 925992 kbps (10032.325 ms). Upload: 1208811520 bytes @ 963208 kbps (10039.870 ms). Upload: 1170145280 bytes @ 932025 kbps (10043.895 ms). Upload: 1198981120 bytes @ 954894 kbps (10044.932 ms). Upload: 1228996608 bytes @ 977891 kbps (10054.261 ms). Upload: 1196163072 bytes @ 951211 kbps (10060.125 ms). App Main returning status 0 Send 512 byte requests, receive 4 KB responses on a single connection repeatidly for 7 seconds, printing total requests per second (RPS) and latency at the end > secnetperf -target:localhost -rstream:1 -run:7s -up:512 -down:4kb -plat:1 Started! Result: 21566 RPS, Latency,us 0th: 39, 50th: 44, 90th: 46, 99th: 108, 99.9th: 166, 99.99th: 235, 99.999th: 7456, 99.9999th: 7567, Max: 7567 App Main returning status 0 Do ths same as above, but using TCP/TLS instead of QUIC > secnetperf -target:localhost -rstream:1 -run:7s -up:512 -down:4kb -plat:1 -tcp:1 Started! Result: 30555 RPS, Latency,us 0th: 24, 50th: 32, 90th: 34, 99th: 81, 99.9th: 131, 99.99th: 192, 99.999th: 456, 99.9999th: 1766, Max: 1766 App Main returning status 0"
  },
  "src/plugins/dbg/readme.html": {
    "href": "src/plugins/dbg/readme.html",
    "title": "quic.dll",
    "summary": "quic.dll WinDbg debugger extension for the MsQuic library. Publishing Instructions Increment the version number in GalleryManifest.xml. Create a folder with name equal to the version number. Copy GalleryManifest.xml into the folder. To the version folder, add subfolders for x86 and amd64. Copy the corresponding versions of quic.dll in each of those subfolders. Zip it all up. Share it out. Send mail to dex-triage@microsoft.com with the path to the shared folder."
  },
  "src/plugins/trace/README.html": {
    "href": "src/plugins/trace/README.html",
    "title": "Windows Performance Analyzer Plugin",
    "summary": "Windows Performance Analyzer Plugin This page provides the install, setup and usage instructions for Windows Performance Analyzer (WPA) and use it to analyze MsQuic traces. Install Instructions The following are currently only possible on Windows. Other platforms may be supported by WPA in the future. Install WPA Download the preview version from the Windows Store or (for MSFT internal) from http://aka.ms/getwpa. Download MsQuic WPA Plugin Navigate to our GitHub Action for building the plugin. Click on the latest build. Scroll to the bottom and download the ptix_quictrace_Release artifact. Extract the .ptix file. Install the Plugin Open WPA and use the Install Plugin dialog to install the MsQuic WPA plugin. Restart WPA. Usage Instructions WPA is extremely powerful. It can operate very quickly on multi-gigabyte trace files and let you slice & dice the data many different ways to really drill down into what's going on. Load trace file ETW trace Select and Open .etl file LTTng trace Directory Select directory which includes traces. WPA automatically traverses and find trace files. File Compress the directory as zip change the extension to .ctf Select the .ctf file Call stacks and CPU Usage Windows One of the built-in capabilities of WPA is the ability to analyze CPU trace information to see the CPU usage of the various call stacks in the code. For instance, in the above Flame Graph you can easily see that the most expensive function (58% of total CPU usage!) is CxPlatEncrypt. Linux Linux perf command is one of the way to collect such information. # on Linux (kernel > 5.10) sudo apt-get install -y linux-perf # on Linux (kernel <= 5.10) sudo apt-get install -y linux-tools-`uname -r` # use your own options perf record -a -g -F 10 -o out.perf.data # \".perf.data.txt\" extension is required for later visualize on WPA perf script -i out.perf.data > out.perf.data.txt Visualize perf artifact on WPA The perf command's artifact can be visualized on Windows through WPA. Follow steps below to load perf extension on WPA. # on Windows cd ${WORKDIR} git clone https://github.com/microsoft/Microsoft-Performance-Tools-Linux-Android cd .\\Microsoft-Performance-Tools-Linux-Android\\PerfDataExtensions dotnet build # use absolute path wpa.exe -addsearchdir ${WORKDIR}\\Microsoft-Performance-Tools-Linux-Android\\PerfDataExtensions\\bin\\Debug\\netstandard2.1\\ # Open out.perf.data.txt on WPA. You might need to open multiple time if you see error at opening (known issue?) Change visualization type by drop down menu as shown in image below. Also you can filter in data for each CPU etc. TODO - Add more details/instructions. QUIC Charts and Tables TODO"
  }
}