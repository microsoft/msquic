/* 
  This file was generated by KaRaMeL <https://github.com/FStarLang/karamel>
  KaRaMeL invocation: /home/eioannidis/karamel/krml -skip-compilation -skip-makefiles -skip-linking -bundle RecvBufferWrapper=RecvBufferWrapper,Pulse.Lib.CircularBuffer,Pulse.Lib.CircularBuffer.*,Pulse.Lib.RangeVec,Pulse.Lib.RangeMap.Spec -library Pulse.Lib.Vector -warn-error -15 -warn-error -4 -warn-error -2 -warn-error -26 -warn-error -18 -warn-error -9 -warn-error -17 -warn-error -1 -warn-error -5 -warn-error -11 -warn-error -13 -tmpdir _new_c_output /home/eioannidis/karamel/krmllib/.extract/C_Endianness.krml /home/eioannidis/karamel/krmllib/.extract/C_Failure.krml /home/eioannidis/karamel/krmllib/.extract/C.krml /home/eioannidis/karamel/krmllib/.extract/C_Loops.krml /home/eioannidis/karamel/krmllib/.extract/C_String.krml /home/eioannidis/karamel/krmllib/.extract/FStar_All.krml /home/eioannidis/karamel/krmllib/.extract/FStar_Attributes.krml /home/eioannidis/karamel/krmllib/.extract/FStar_BigOps.krml /home/eioannidis/karamel/krmllib/.extract/FStar_BitVector.krml /home/eioannidis/karamel/krmllib/.extract/FStar_BV.krml /home/eioannidis/karamel/krmllib/.extract/FStar_Bytes.krml /home/eioannidis/karamel/krmllib/.extract/FStar_Calc.krml /home/eioannidis/karamel/krmllib/.extract/FStar_Char.krml /home/eioannidis/karamel/krmllib/.extract/FStar_Classical.krml /home/eioannidis/karamel/krmllib/.extract/FStar_Classical_Sugar.krml /home/eioannidis/karamel/krmllib/.extract/FStar_Date.krml /home/eioannidis/karamel/krmllib/.extract/FStar_Dyn.krml /home/eioannidis/karamel/krmllib/.extract/FStar_Endianness.krml /home/eioannidis/karamel/krmllib/.extract/FStar_ErasedLogic.krml /home/eioannidis/karamel/krmllib/.extract/FStar_Exn.krml /home/eioannidis/karamel/krmllib/.extract/FStar_Float.krml /home/eioannidis/karamel/krmllib/.extract/FStar_FunctionalExtensionality.krml /home/eioannidis/karamel/krmllib/.extract/FStar_Ghost.krml /home/eioannidis/karamel/krmllib/.extract/FStar_GSet.krml /home/eioannidis/karamel/krmllib/.extract/FStar_Heap.krml /home/eioannidis/karamel/krmllib/.extract/FStar_HyperStack_All.krml /home/eioannidis/karamel/krmllib/.extract/FStar_HyperStack_IO.krml /home/eioannidis/karamel/krmllib/.extract/FStar_HyperStack.krml /home/eioannidis/karamel/krmllib/.extract/FStar_HyperStack_ST.krml /home/eioannidis/karamel/krmllib/.extract/FStar_IndefiniteDescription.krml /home/eioannidis/karamel/krmllib/.extract/FStar_Int16.krml /home/eioannidis/karamel/krmllib/.extract/FStar_Int32.krml /home/eioannidis/karamel/krmllib/.extract/FStar_Int64.krml /home/eioannidis/karamel/krmllib/.extract/FStar_Int8.krml /home/eioannidis/karamel/krmllib/.extract/FStar_Int_Cast_Full.krml /home/eioannidis/karamel/krmllib/.extract/FStar_Int_Cast.krml /home/eioannidis/karamel/krmllib/.extract/FStar_Int.krml /home/eioannidis/karamel/krmllib/.extract/FStar_IO.krml /home/eioannidis/karamel/krmllib/.extract/FStar_Issue.krml /home/eioannidis/karamel/krmllib/.extract/FStar_Krml_Endianness.krml /home/eioannidis/karamel/krmllib/.extract/FStar_List.krml /home/eioannidis/karamel/krmllib/.extract/FStar_List_Tot_Base.krml /home/eioannidis/karamel/krmllib/.extract/FStar_List_Tot.krml /home/eioannidis/karamel/krmllib/.extract/FStar_List_Tot_Properties.krml /home/eioannidis/karamel/krmllib/.extract/FStar_Map.krml /home/eioannidis/karamel/krmllib/.extract/FStar_Math_Lemmas.krml /home/eioannidis/karamel/krmllib/.extract/FStar_Math_Lib.krml /home/eioannidis/karamel/krmllib/.extract/FStar_ModifiesGen.krml /home/eioannidis/karamel/krmllib/.extract/FStar_Monotonic_Heap.krml /home/eioannidis/karamel/krmllib/.extract/FStar_Monotonic_HyperHeap.krml /home/eioannidis/karamel/krmllib/.extract/FStar_Monotonic_HyperStack.krml /home/eioannidis/karamel/krmllib/.extract/FStar_Monotonic_Pure.krml /home/eioannidis/karamel/krmllib/.extract/FStar_Monotonic_Witnessed.krml /home/eioannidis/karamel/krmllib/.extract/FStar_Mul.krml /home/eioannidis/karamel/krmllib/.extract/FStar_NormSteps.krml /home/eioannidis/karamel/krmllib/.extract/FStar_Order.krml /home/eioannidis/karamel/krmllib/.extract/FStar_Pervasives.krml /home/eioannidis/karamel/krmllib/.extract/FStar_Pervasives_Native.krml /home/eioannidis/karamel/krmllib/.extract/FStar_Pprint.krml /home/eioannidis/karamel/krmllib/.extract/FStar_PredicateExtensionality.krml /home/eioannidis/karamel/krmllib/.extract/FStar_Prelude.krml /home/eioannidis/karamel/krmllib/.extract/FStar_Preorder.krml /home/eioannidis/karamel/krmllib/.extract/FStar_PropositionalExtensionality.krml /home/eioannidis/karamel/krmllib/.extract/FStar_Range.krml /home/eioannidis/karamel/krmllib/.extract/FStar_Sealed_Inhabited.krml /home/eioannidis/karamel/krmllib/.extract/FStar_Sealed.krml /home/eioannidis/karamel/krmllib/.extract/FStar_Seq_Base.krml /home/eioannidis/karamel/krmllib/.extract/FStar_Seq.krml /home/eioannidis/karamel/krmllib/.extract/FStar_Seq_Properties.krml /home/eioannidis/karamel/krmllib/.extract/FStar_Set.krml /home/eioannidis/karamel/krmllib/.extract/FStar_Squash.krml /home/eioannidis/karamel/krmllib/.extract/FStar_ST.krml /home/eioannidis/karamel/krmllib/.extract/FStar_String.krml /home/eioannidis/karamel/krmllib/.extract/FStar_StrongExcludedMiddle.krml /home/eioannidis/karamel/krmllib/.extract/FStar_TSet.krml /home/eioannidis/karamel/krmllib/.extract/FStar_UInt128.krml /home/eioannidis/karamel/krmllib/.extract/FStar_UInt16.krml /home/eioannidis/karamel/krmllib/.extract/FStar_UInt32.krml /home/eioannidis/karamel/krmllib/.extract/FStar_UInt64.krml /home/eioannidis/karamel/krmllib/.extract/FStar_UInt8.krml /home/eioannidis/karamel/krmllib/.extract/FStar_UInt.krml /home/eioannidis/karamel/krmllib/.extract/FStar_Universe.krml /home/eioannidis/karamel/krmllib/.extract/LowStar_Buffer.krml /home/eioannidis/karamel/krmllib/.extract/LowStar_BufferOps.krml /home/eioannidis/karamel/krmllib/.extract/LowStar_Endianness.krml /home/eioannidis/karamel/krmllib/.extract/LowStar_Failure.krml /home/eioannidis/karamel/krmllib/.extract/LowStar_Lib_AssocList.krml /home/eioannidis/karamel/krmllib/.extract/LowStar_Lib_LinkedList2.krml /home/eioannidis/karamel/krmllib/.extract/LowStar_Lib_LinkedList.krml /home/eioannidis/karamel/krmllib/.extract/LowStar_Modifies.krml /home/eioannidis/karamel/krmllib/.extract/LowStar_Monotonic_Buffer.krml /home/eioannidis/karamel/krmllib/.extract/LowStar_Printf.krml /home/eioannidis/karamel/krmllib/.extract/Spec_Loops.krml /home/eioannidis/karamel/krmllib/.extract/TestLib.krml /home/eioannidis/karamel/krmllib/.extract/WasmSupport.krml _output/Pulse_Lib_CircularBuffer_GapTrack.krml _output/Pulse_Lib_CircularBuffer.krml _output/Pulse_Lib_CircularBuffer_Modular.krml _output/Pulse_Lib_CircularBuffer_Pow2.krml _output/Pulse_Lib_CircularBuffer_Spec.krml _output/Pulse_Lib_RangeMap_Spec.krml _output/Pulse_Lib_RangeVec.krml _output/Pulse_Lib_Vector.krml _output/RecvBufferWrapper.krml
  F* version: <unknown>
  KaRaMeL version: a4caa585
 */

#include "internal/RecvBufferWrapper.h"

static Pulse_Lib_RangeVec_range default_range = { .start = (size_t)0U, .len = (size_t)1U };

static Pulse_Lib_Vector_vector_internal__Pulse_Lib_RangeVec_range *range_vec_create(void)
{
  Pulse_Lib_Vector_vector_internal__Pulse_Lib_RangeVec_range
  *rv = Pulse_Lib_Vector_create(default_range, (size_t)1U);
  Pulse_Lib_Vector_pop_back(rv, (void *)0U, (void *)0U);
  return rv;
}

static void range_vec_free(Pulse_Lib_Vector_vector_internal__Pulse_Lib_RangeVec_range *rv)
{
  Pulse_Lib_Vector_free(rv, (void *)0U, (void *)0U);
}

static size_t
range_vec_contiguous_from(
  Pulse_Lib_Vector_vector_internal__Pulse_Lib_RangeVec_range *rv,
  size_t base
)
{
  size_t sz = Pulse_Lib_Vector_size(rv, (void *)0U, (void *)0U);
  if (sz == (size_t)0U)
    return (size_t)0U;
  else
  {
    Pulse_Lib_RangeVec_range first = Pulse_Lib_Vector_at(rv, (size_t)0U, (void *)0U, (void *)0U);
    size_t r_high = first.start + first.len;
    if (first.start <= base && base < r_high)
      return r_high - base;
    else
      return (size_t)0U;
  }
}

static size_t
range_vec_max_endpoint(Pulse_Lib_Vector_vector_internal__Pulse_Lib_RangeVec_range *rv)
{
  size_t sz = Pulse_Lib_Vector_size(rv, (void *)0U, (void *)0U);
  if (sz == (size_t)0U)
    return (size_t)0U;
  else
  {
    size_t last_idx = sz - (size_t)1U;
    Pulse_Lib_RangeVec_range last = Pulse_Lib_Vector_at(rv, last_idx, (void *)0U, (void *)0U);
    return last.start + last.len;
  }
}

static void
vec_insert_at(
  Pulse_Lib_Vector_vector_internal__Pulse_Lib_RangeVec_range *rv,
  size_t i,
  Pulse_Lib_RangeVec_range r
)
{
  Pulse_Lib_Vector_push_back(rv, r, (void *)0U, (void *)0U);
  size_t sz = Pulse_Lib_Vector_size(rv, (void *)0U, (void *)0U);
  if (sz > (size_t)1U && i < sz - (size_t)1U)
  {
    size_t j = sz - (size_t)1U;
    bool cont = true;
    while (cont)
    {
      size_t jv = j;
      if (jv > i)
      {
        Pulse_Lib_RangeVec_range
        prev = Pulse_Lib_Vector_at(rv, jv - (size_t)1U, (void *)0U, (void *)0U);
        Pulse_Lib_Vector_set(rv, jv, prev, (void *)0U, (void *)0U);
        size_t new_j = jv - (size_t)1U;
        j = new_j;
        if (new_j == i)
          cont = false;
      }
      else
        cont = false;
    }
    Pulse_Lib_Vector_set(rv, i, r, (void *)0U, (void *)0U);
  }
}

static void
vec_remove_range(
  Pulse_Lib_Vector_vector_internal__Pulse_Lib_RangeVec_range *rv,
  size_t i,
  size_t count
)
{
  size_t sz = Pulse_Lib_Vector_size(rv, (void *)0U, (void *)0U);
  size_t dst_end = sz - count;
  size_t j = i;
  bool shift_cont = true;
  while (shift_cont)
  {
    size_t jv = j;
    if (jv < dst_end)
    {
      Pulse_Lib_RangeVec_range val_ = Pulse_Lib_Vector_at(rv, jv + count, (void *)0U, (void *)0U);
      Pulse_Lib_Vector_set(rv, jv, val_, (void *)0U, (void *)0U);
      j = jv + (size_t)1U;
    }
    else
      shift_cont = false;
  }
  size_t k = (size_t)0U;
  bool pop_cont = true;
  while (pop_cont)
  {
    size_t kv = k;
    if (kv < count)
    {
      Pulse_Lib_Vector_pop_back(rv, (void *)0U, (void *)0U);
      size_t new_k = kv + (size_t)1U;
      k = new_k;
      if (new_k == count)
        pop_cont = false;
    }
    else
      pop_cont = false;
  }
}

static void
range_vec_drain(Pulse_Lib_Vector_vector_internal__Pulse_Lib_RangeVec_range *rv, size_t new_bo)
{
  size_t sz = Pulse_Lib_Vector_size(rv, (void *)0U, (void *)0U);
  KRML_MAYBE_UNUSED_VAR(sz);
  Pulse_Lib_RangeVec_range first = Pulse_Lib_Vector_at(rv, (size_t)0U, (void *)0U, (void *)0U);
  size_t r_high = first.start + first.len;
  Pulse_Lib_RangeMap_Spec_interval
  first_spec = { .low = FStar_SizeT_v(first.start), .count = FStar_SizeT_v(first.len) };
  KRML_MAYBE_UNUSED_VAR(first_spec);
  if (r_high <= new_bo)
    vec_remove_range(rv, (size_t)0U, (size_t)1U);
  else if (first.start < new_bo)
  {
    size_t new_len = r_high - new_bo;
    Pulse_Lib_RangeVec_range new_range = { .start = new_bo, .len = new_len };
    Pulse_Lib_Vector_set(rv, (size_t)0U, new_range, (void *)0U, (void *)0U);
  }
}

static void
range_vec_add(
  Pulse_Lib_Vector_vector_internal__Pulse_Lib_RangeVec_range *rv,
  size_t offset,
  size_t len
)
{
  size_t sz = Pulse_Lib_Vector_size(rv, (void *)0U, (void *)0U);
  size_t off_plus_len = offset + len;
  size_t idx = (size_t)0U;
  bool search = true;
  while (search)
  {
    size_t iv = idx;
    if (iv < sz)
    {
      Pulse_Lib_RangeVec_range r = Pulse_Lib_Vector_at(rv, iv, (void *)0U, (void *)0U);
      size_t high = r.start + r.len;
      if (high < offset)
        idx = iv + (size_t)1U;
      else
        search = false;
    }
    else
      search = false;
  }
  size_t iv = idx;
  if (sz == (size_t)0U || iv == sz)
  {
    Pulse_Lib_RangeVec_range r = { .start = offset, .len = len };
    vec_insert_at(rv, iv, r);
  }
  else
  {
    Pulse_Lib_RangeVec_range first_r = Pulse_Lib_Vector_at(rv, iv, (void *)0U, (void *)0U);
    if (off_plus_len < first_r.start)
    {
      Pulse_Lib_RangeVec_range new_r = { .start = offset, .len = len };
      vec_insert_at(rv, iv, new_r);
    }
    else
    {
      size_t merged_low;
      if (offset < first_r.start)
        merged_low = offset;
      else
        merged_low = first_r.start;
      size_t first_high = first_r.start + first_r.len;
      size_t mh0_val;
      if (off_plus_len > first_high)
        mh0_val = off_plus_len;
      else
        mh0_val = first_high;
      size_t merged_high = mh0_val;
      size_t j = iv + (size_t)1U;
      bool merge_cont = true;
      while (merge_cont)
      {
        size_t jv = j;
        if (jv < sz)
        {
          Pulse_Lib_RangeVec_range r = Pulse_Lib_Vector_at(rv, jv, (void *)0U, (void *)0U);
          size_t mh = merged_high;
          if (mh >= r.start)
          {
            size_t r_high = r.start + r.len;
            if (r_high > mh)
              merged_high = r_high;
            j = jv + (size_t)1U;
          }
          else
            merge_cont = false;
        }
        else
          merge_cont = false;
      }
      size_t jv = j;
      size_t final_high = merged_high;
      size_t final_len = final_high - merged_low;
      Pulse_Lib_RangeVec_range merged_r = { .start = merged_low, .len = final_len };
      Pulse_Lib_Vector_set(rv, iv, merged_r, (void *)0U, (void *)0U);
      if (jv > iv + (size_t)1U)
      {
        size_t remove_count = jv - (iv + (size_t)1U);
        vec_remove_range(rv, iv + (size_t)1U, remove_count);
      }
    }
  }
}

size_t Pulse_Lib_CircularBuffer_cb_max_length_sz;

static size_t read_length(Pulse_Lib_CircularBuffer_cb_internal *cb)
{
  Pulse_Lib_CircularBuffer_cb_internal cb_val = *cb;
  return cb_val.pl;
}

static size_t get_total_length(Pulse_Lib_Vector_vector_internal__Pulse_Lib_RangeVec_range *rm)
{
  return range_vec_max_endpoint(rm);
}

static void set_virtual_length(Pulse_Lib_CircularBuffer_cb_internal *cb, size_t new_vl)
{
  Pulse_Lib_CircularBuffer_cb_internal cb_val = *cb;
  Pulse_Lib_CircularBuffer_cb_internal
  new_cbi =
    {
      .buf = cb_val.buf, .rs = cb_val.rs, .al = cb_val.al, .pl = cb_val.pl, .vl = new_vl,
      .bo = cb_val.bo
    };
  *cb = new_cbi;
}

static K____Pulse_Lib_CircularBuffer_cb_internal___Pulse_Lib_Vector_vector_internal__Pulse_Lib_RangeVec_range_
create(size_t alloc_len, size_t virt_len)
{
  KRML_CHECK_SIZE(sizeof (uint8_t), alloc_len);
  uint8_t *buf_vec = KRML_HOST_CALLOC(alloc_len, sizeof (uint8_t));
  size_t al_v = alloc_len;
  size_t vl_v = virt_len;
  Pulse_Lib_CircularBuffer_cb_internal
  vi =
    {
      .buf = buf_vec, .rs = (size_t)0U, .al = al_v, .pl = (size_t)0U, .vl = vl_v, .bo = (size_t)0U
    };
  Pulse_Lib_CircularBuffer_cb_internal
  *cb = KRML_HOST_MALLOC(sizeof (Pulse_Lib_CircularBuffer_cb_internal));
  if (cb != NULL)
    cb[0U] = vi;
  Pulse_Lib_Vector_vector_internal__Pulse_Lib_RangeVec_range *rm = range_vec_create();
  return
    (
      (K____Pulse_Lib_CircularBuffer_cb_internal___Pulse_Lib_Vector_vector_internal__Pulse_Lib_RangeVec_range_){
        .fst = cb,
        .snd = rm
      }
    );
}

static void resize(Pulse_Lib_CircularBuffer_cb_internal *cb, size_t new_al)
{
  Pulse_Lib_CircularBuffer_cb_internal cb_val = *cb;
  KRML_CHECK_SIZE(sizeof (uint8_t), new_al);
  uint8_t *new_vec = KRML_HOST_CALLOC(new_al, sizeof (uint8_t));
  size_t i = (size_t)0U;
  size_t vi0 = i;
  bool cond = vi0 < cb_val.al;
  while (cond)
  {
    size_t vi = i;
    size_t temp = cb_val.rs + vi;
    size_t src_idx = temp % cb_val.al;
    uint8_t byte_val = cb_val.buf[src_idx];
    new_vec[vi] = byte_val;
    i = vi + (size_t)1U;
    size_t vi0 = i;
    cond = vi0 < cb_val.al;
  }
  KRML_HOST_FREE(cb_val.buf);
  Pulse_Lib_CircularBuffer_cb_internal
  new_cbi =
    {
      .buf = new_vec, .rs = (size_t)0U, .al = new_al, .pl = cb_val.pl, .vl = cb_val.vl,
      .bo = cb_val.bo
    };
  *cb = new_cbi;
}

static void
verified_free_cb(
  Pulse_Lib_CircularBuffer_cb_internal *cb,
  Pulse_Lib_Vector_vector_internal__Pulse_Lib_RangeVec_range *rm
)
{
  Pulse_Lib_CircularBuffer_cb_internal cb_val = *cb;
  KRML_HOST_FREE(cb_val.buf);
  range_vec_free(rm);
  KRML_HOST_FREE(cb);
}

static size_t get_alloc_length(Pulse_Lib_CircularBuffer_cb_internal *cb)
{
  Pulse_Lib_CircularBuffer_cb_internal cb_val = *cb;
  return cb_val.al;
}

static void
read_buffer(Pulse_Lib_CircularBuffer_cb_internal *cb, uint8_t *dst, size_t read_len)
{
  Pulse_Lib_CircularBuffer_cb_internal cb_val = *cb;
  size_t ri = (size_t)0U;
  size_t vi0 = ri;
  bool cond = vi0 < read_len;
  while (cond)
  {
    size_t vi = ri;
    size_t pidx = (cb_val.rs + vi) % cb_val.al;
    uint8_t byte_val = cb_val.buf[pidx];
    dst[vi] = byte_val;
    ri = vi + (size_t)1U;
    size_t vi0 = ri;
    cond = vi0 < read_len;
  }
}

static Pulse_Lib_CircularBuffer_write_result
write_buffer(
  Pulse_Lib_CircularBuffer_cb_internal *cb,
  Pulse_Lib_Vector_vector_internal__Pulse_Lib_RangeVec_range *rm,
  size_t abs_offset,
  uint8_t *src,
  size_t write_len
)
{
  Pulse_Lib_CircularBuffer_cb_internal cb_val = *cb;
  size_t bo = cb_val.bo;
  size_t al = cb_val.al;
  size_t old_pl = cb_val.pl;
  size_t abs_end = abs_offset + write_len;
  if (abs_end <= bo)
    return
      (
        (Pulse_Lib_CircularBuffer_write_result){
          .wrote = false,
          .new_data_ready = false,
          .resize_failed = false
        }
      );
  else
  {
    size_t rel_offset;
    if (abs_offset >= bo)
      rel_offset = abs_offset - bo;
    else
      rel_offset = (size_t)0U;
    size_t skip;
    if (abs_offset < bo)
      skip = bo - abs_offset;
    else
      skip = (size_t)0U;
    size_t trimmed_len = write_len - skip;
    size_t needed = rel_offset + trimmed_len;
    if (needed > al)
      if (needed > Pulse_Lib_CircularBuffer_cb_max_length_sz)
        return
          (
            (Pulse_Lib_CircularBuffer_write_result){
              .wrote = false,
              .new_data_ready = false,
              .resize_failed = true
            }
          );
      else
      {
        size_t nal_ref = al;
        size_t cur0 = nal_ref;
        bool cond = cur0 < needed;
        while (cond)
        {
          size_t cur = nal_ref;
          nal_ref = cur + cur;
          size_t cur0 = nal_ref;
          cond = cur0 < needed;
        }
        size_t new_al = nal_ref;
        resize(cb, new_al);
        Pulse_Lib_CircularBuffer_cb_internal cb_val2 = *cb;
        size_t wi = (size_t)0U;
        size_t vi0 = wi;
        bool cond0 = vi0 < trimmed_len;
        while (cond0)
        {
          size_t vi = wi;
          size_t src_idx = skip + vi;
          uint8_t byte_val = src[src_idx];
          size_t off = rel_offset + vi;
          size_t pidx = (cb_val2.rs + off) % cb_val2.al;
          cb_val2.buf[pidx] = byte_val;
          wi = vi + (size_t)1U;
          size_t vi0 = wi;
          cond0 = vi0 < trimmed_len;
        }
        size_t rm_abs = cb_val2.bo + rel_offset;
        range_vec_add(rm, rm_abs, trimmed_len);
        size_t new_pl = range_vec_contiguous_from(rm, cb_val2.bo);
        bool ndr = new_pl > (size_t)0U && old_pl == (size_t)0U;
        Pulse_Lib_CircularBuffer_cb_internal
        new_cbi =
          {
            .buf = cb_val2.buf, .rs = cb_val2.rs, .al = cb_val2.al, .pl = new_pl, .vl = cb_val2.vl,
            .bo = cb_val2.bo
          };
        *cb = new_cbi;
        return
          (
            (Pulse_Lib_CircularBuffer_write_result){
              .wrote = true,
              .new_data_ready = ndr,
              .resize_failed = false
            }
          );
      }
    else
    {
      size_t wi = (size_t)0U;
      size_t vi0 = wi;
      bool cond = vi0 < trimmed_len;
      while (cond)
      {
        size_t vi = wi;
        size_t src_idx = skip + vi;
        uint8_t byte_val = src[src_idx];
        size_t off = rel_offset + vi;
        size_t pidx = (cb_val.rs + off) % cb_val.al;
        cb_val.buf[pidx] = byte_val;
        wi = vi + (size_t)1U;
        size_t vi0 = wi;
        cond = vi0 < trimmed_len;
      }
      size_t rm_abs = cb_val.bo + rel_offset;
      range_vec_add(rm, rm_abs, trimmed_len);
      size_t new_pl = range_vec_contiguous_from(rm, cb_val.bo);
      bool ndr = new_pl > (size_t)0U && old_pl == (size_t)0U;
      Pulse_Lib_CircularBuffer_cb_internal
      new_cbi =
        {
          .buf = cb_val.buf, .rs = cb_val.rs, .al = cb_val.al, .pl = new_pl, .vl = cb_val.vl,
          .bo = cb_val.bo
        };
      *cb = new_cbi;
      return
        (
          (Pulse_Lib_CircularBuffer_write_result){
            .wrote = true,
            .new_data_ready = ndr,
            .resize_failed = false
          }
        );
    }
  }
}

static bool
drain(
  Pulse_Lib_CircularBuffer_cb_internal *cb,
  Pulse_Lib_Vector_vector_internal__Pulse_Lib_RangeVec_range *rm,
  size_t n
)
{
  Pulse_Lib_CircularBuffer_cb_internal cb_val = *cb;
  size_t temp = cb_val.rs + n;
  size_t new_rs = temp % cb_val.al;
  size_t new_bo = cb_val.bo + n;
  if (n > (size_t)0U)
  {
    range_vec_drain(rm, new_bo);
    size_t new_pl = range_vec_contiguous_from(rm, new_bo);
    Pulse_Lib_CircularBuffer_cb_internal
    new_cbi =
      {
        .buf = cb_val.buf, .rs = new_rs, .al = cb_val.al, .pl = new_pl, .vl = cb_val.vl,
        .bo = new_bo
      };
    *cb = new_cbi;
    return new_pl == (size_t)0U;
  }
  else
  {
    size_t new_pl = range_vec_contiguous_from(rm, new_bo);
    Pulse_Lib_CircularBuffer_cb_internal
    new_cbi =
      {
        .buf = cb_val.buf, .rs = new_rs, .al = cb_val.al, .pl = new_pl, .vl = cb_val.vl,
        .bo = new_bo
      };
    *cb = new_cbi;
    return new_pl == (size_t)0U;
  }
}

static Pulse_Lib_CircularBuffer_read_view
read_zerocopy_core(size_t read_len, Pulse_Lib_CircularBuffer_cb_internal cbi)
{
  size_t rs = cbi.rs;
  size_t al = cbi.al;
  bool wraps = rs + read_len > al;
  if (wraps)
  {
    size_t len1 = al - rs;
    size_t len2 = read_len - len1;
    return
      (
        (Pulse_Lib_CircularBuffer_read_view){
          .arr = cbi.buf,
          .off1 = rs,
          .len1 = len1,
          .off2 = (size_t)0U,
          .len2 = len2
        }
      );
  }
  else
    return
      (
        (Pulse_Lib_CircularBuffer_read_view){
          .arr = cbi.buf,
          .off1 = rs,
          .len1 = read_len,
          .off2 = (size_t)0U,
          .len2 = (size_t)0U
        }
      );
}

static Pulse_Lib_CircularBuffer_read_view
read_zerocopy(Pulse_Lib_CircularBuffer_cb_internal *cb, size_t read_len)
{
  Pulse_Lib_CircularBuffer_cb_internal cb_val = *cb;
  Pulse_Lib_CircularBuffer_read_view rv = read_zerocopy_core(read_len, cb_val);
  return rv;
}

static void release_read(Pulse_Lib_CircularBuffer_cb_internal *cb)
{
  KRML_MAYBE_UNUSED_VAR(cb);
}

static bool
drain_after_read(
  Pulse_Lib_CircularBuffer_cb_internal *cb,
  Pulse_Lib_Vector_vector_internal__Pulse_Lib_RangeVec_range *rm,
  size_t drain_len
)
{
  release_read(cb);
  return drain(cb, rm, drain_len);
}

K____Pulse_Lib_CircularBuffer_cb_internal___Pulse_Lib_Vector_vector_internal__Pulse_Lib_RangeVec_range_
RecvBufferWrapper_create(size_t alloc_len, size_t virt_len)
{
  return create(alloc_len, virt_len);
}

void
RecvBufferWrapper_free(
  Pulse_Lib_CircularBuffer_cb_internal *cb,
  Pulse_Lib_Vector_vector_internal__Pulse_Lib_RangeVec_range *rm
)
{
  verified_free_cb(cb, rm);
}

size_t
RecvBufferWrapper_read_length(
  Pulse_Lib_CircularBuffer_cb_internal *cb,
  Pulse_Lib_Vector_vector_internal__Pulse_Lib_RangeVec_range *rm
)
{
  KRML_MAYBE_UNUSED_VAR(rm);
  return read_length(cb);
}

size_t
RecvBufferWrapper_get_total_length(
  Pulse_Lib_CircularBuffer_cb_internal *cb,
  Pulse_Lib_Vector_vector_internal__Pulse_Lib_RangeVec_range *rm
)
{
  KRML_MAYBE_UNUSED_VAR(cb);
  return get_total_length(rm);
}

size_t
RecvBufferWrapper_get_alloc_length(
  Pulse_Lib_CircularBuffer_cb_internal *cb,
  Pulse_Lib_Vector_vector_internal__Pulse_Lib_RangeVec_range *rm
)
{
  KRML_MAYBE_UNUSED_VAR(rm);
  return get_alloc_length(cb);
}

bool
RecvBufferWrapper_drain(
  Pulse_Lib_CircularBuffer_cb_internal *cb,
  Pulse_Lib_Vector_vector_internal__Pulse_Lib_RangeVec_range *rm,
  size_t n
)
{
  return drain(cb, rm, n);
}

Pulse_Lib_CircularBuffer_write_result
RecvBufferWrapper_write_buffer(
  Pulse_Lib_CircularBuffer_cb_internal *cb,
  Pulse_Lib_Vector_vector_internal__Pulse_Lib_RangeVec_range *rm,
  size_t abs_offset,
  uint8_t *src,
  size_t write_len
)
{
  return write_buffer(cb, rm, abs_offset, src, write_len);
}

void
RecvBufferWrapper_read_buffer(
  Pulse_Lib_CircularBuffer_cb_internal *cb,
  Pulse_Lib_Vector_vector_internal__Pulse_Lib_RangeVec_range *rm,
  uint8_t *dst,
  size_t read_len
)
{
  KRML_MAYBE_UNUSED_VAR(rm);
  read_buffer(cb, dst, read_len);
}

void
RecvBufferWrapper_resize(
  Pulse_Lib_CircularBuffer_cb_internal *cb,
  Pulse_Lib_Vector_vector_internal__Pulse_Lib_RangeVec_range *rm,
  size_t new_al
)
{
  KRML_MAYBE_UNUSED_VAR(rm);
  resize(cb, new_al);
}

void
RecvBufferWrapper_set_virtual_length(
  Pulse_Lib_CircularBuffer_cb_internal *cb,
  Pulse_Lib_Vector_vector_internal__Pulse_Lib_RangeVec_range *rm,
  size_t new_vl
)
{
  KRML_MAYBE_UNUSED_VAR(rm);
  set_virtual_length(cb, new_vl);
}

Pulse_Lib_CircularBuffer_read_view
RecvBufferWrapper_read_zerocopy(
  Pulse_Lib_CircularBuffer_cb_internal *cb,
  Pulse_Lib_Vector_vector_internal__Pulse_Lib_RangeVec_range *rm,
  size_t read_len
)
{
  KRML_MAYBE_UNUSED_VAR(rm);
  return read_zerocopy(cb, read_len);
}

void
RecvBufferWrapper_release_read(
  Pulse_Lib_CircularBuffer_cb_internal *cb,
  Pulse_Lib_Vector_vector_internal__Pulse_Lib_RangeVec_range *rm,
  Pulse_Lib_CircularBuffer_read_view rv
)
{
  KRML_MAYBE_UNUSED_VAR(rm);
  KRML_MAYBE_UNUSED_VAR(rv);
  release_read(cb);
}

bool
RecvBufferWrapper_drain_after_read(
  Pulse_Lib_CircularBuffer_cb_internal *cb,
  Pulse_Lib_Vector_vector_internal__Pulse_Lib_RangeVec_range *rm,
  Pulse_Lib_CircularBuffer_read_view rv,
  size_t drain_len
)
{
  KRML_MAYBE_UNUSED_VAR(rv);
  return drain_after_read(cb, rm, drain_len);
}

