/* 
  This file was generated by KaRaMeL <https://github.com/FStarLang/karamel>
  KaRaMeL invocation: /home/eioannidis/karamel/_build/default/src/Karamel.exe -skip-compilation -skip-makefiles -skip-linking -bundle CircularBufferWrapper=CircularBufferWrapper,Pulse.Lib.CircularBuffer,Pulse.Lib.CircularBuffer.Spec,Pulse.Lib.CircularBuffer.GapTrack,Pulse.Lib.CircularBuffer.Pow2,Pulse.Lib.CircularBuffer.Modular -no-prefix CircularBufferWrapper -warn-error -15-2-4-7-3-1-5 -tmpdir /tmp/cb_nofsti/c_out /tmp/cb_nofsti/CircularBufferWrapper.krml /tmp/cb_nofsti/Pulse_Lib_CircularBuffer.krml /tmp/cb_nofsti/Pulse_Lib_CircularBuffer_Spec.krml /tmp/cb_nofsti/Pulse_Lib_CircularBuffer_GapTrack.krml /tmp/cb_nofsti/Pulse_Lib_CircularBuffer_Pow2.krml /tmp/cb_nofsti/Pulse_Lib_CircularBuffer_Modular.krml
  F* version: <unknown>
  KaRaMeL version: 1d8e0b74
 */

#include "CircularBufferWrapper.h"

static Pulse_Lib_CircularBuffer_cb_internal *create(size_t alloc_len, size_t virt_len)
{
  KRML_CHECK_SIZE(sizeof (uint8_t), alloc_len);
  uint8_t *buf_vec = KRML_HOST_CALLOC(alloc_len, sizeof (uint8_t));
  size_t al_v = alloc_len;
  size_t vl_v = virt_len;
  Pulse_Lib_CircularBuffer_cb_internal
  vi = { .buf = buf_vec, .rs = (size_t)0U, .al = al_v, .pl = (size_t)0U, .vl = vl_v };
  Pulse_Lib_CircularBuffer_cb_internal
  *buf = KRML_HOST_MALLOC(sizeof (Pulse_Lib_CircularBuffer_cb_internal));
  if (buf != NULL)
    buf[0U] = vi;
  return buf;
}

static size_t read_length(Pulse_Lib_CircularBuffer_cb_internal *cb)
{
  Pulse_Lib_CircularBuffer_cb_internal cb_val = *cb;
  return cb_val.pl;
}

static void drain(Pulse_Lib_CircularBuffer_cb_internal *cb, size_t n)
{
  Pulse_Lib_CircularBuffer_cb_internal cb_val = *cb;
  size_t temp = cb_val.rs + n;
  size_t new_rs = temp % cb_val.al;
  size_t new_pl = cb_val.pl - n;
  Pulse_Lib_CircularBuffer_cb_internal
  new_cbi = { .buf = cb_val.buf, .rs = new_rs, .al = cb_val.al, .pl = new_pl, .vl = cb_val.vl };
  *cb = new_cbi;
}

static void resize(Pulse_Lib_CircularBuffer_cb_internal *cb, size_t new_al)
{
  Pulse_Lib_CircularBuffer_cb_internal cb_val = *cb;
  KRML_CHECK_SIZE(sizeof (uint8_t), new_al);
  uint8_t *new_vec = KRML_HOST_CALLOC(new_al, sizeof (uint8_t));
  size_t i = (size_t)0U;
  size_t vi0 = i;
  bool cond = vi0 < cb_val.al;
  while (cond)
  {
    size_t vi = i;
    size_t temp = cb_val.rs + vi;
    size_t src_idx = temp % cb_val.al;
    uint8_t byte_val = cb_val.buf[src_idx];
    new_vec[vi] = byte_val;
    i = vi + (size_t)1U;
    size_t vi0 = i;
    cond = vi0 < cb_val.al;
  }
  KRML_HOST_FREE(cb_val.buf);
  Pulse_Lib_CircularBuffer_cb_internal
  new_cbi = { .buf = new_vec, .rs = (size_t)0U, .al = new_al, .pl = cb_val.pl, .vl = cb_val.vl };
  *cb = new_cbi;
}

static void free(Pulse_Lib_CircularBuffer_cb_internal *cb)
{
  Pulse_Lib_CircularBuffer_cb_internal cb_val = *cb;
  KRML_HOST_FREE(cb_val.buf);
  KRML_HOST_FREE(cb);
}

static size_t get_alloc_length(Pulse_Lib_CircularBuffer_cb_internal *cb)
{
  Pulse_Lib_CircularBuffer_cb_internal cb_val = *cb;
  return cb_val.al;
}

static bool
write_buffer(Pulse_Lib_CircularBuffer_cb_internal *cb, uint8_t *src, size_t write_len)
{
  Pulse_Lib_CircularBuffer_cb_internal cb_val = *cb;
  size_t needed = cb_val.pl + write_len;
  if (needed > cb_val.al)
  {
    size_t nal_ref = cb_val.al;
    size_t cur0 = nal_ref;
    bool cond = cur0 < needed;
    while (cond)
    {
      size_t cur = nal_ref;
      nal_ref = cur + cur;
      size_t cur0 = nal_ref;
      cond = cur0 < needed;
    }
    size_t new_al = nal_ref;
    KRML_CHECK_SIZE(sizeof (uint8_t), new_al);
    uint8_t *new_vec = KRML_HOST_CALLOC(new_al, sizeof (uint8_t));
    size_t i = (size_t)0U;
    size_t vi0 = i;
    bool cond0 = vi0 < cb_val.al;
    while (cond0)
    {
      size_t vi = i;
      size_t temp = cb_val.rs + vi;
      size_t src_idx = temp % cb_val.al;
      uint8_t byte_val = cb_val.buf[src_idx];
      new_vec[vi] = byte_val;
      i = vi + (size_t)1U;
      size_t vi0 = i;
      cond0 = vi0 < cb_val.al;
    }
    KRML_HOST_FREE(cb_val.buf);
    Pulse_Lib_CircularBuffer_cb_internal
    new_cbi = { .buf = new_vec, .rs = (size_t)0U, .al = new_al, .pl = cb_val.pl, .vl = cb_val.vl };
    *cb = new_cbi;
    Pulse_Lib_CircularBuffer_cb_internal cb_val2 = *cb;
    size_t wi = (size_t)0U;
    bool pcont = (size_t)0U < write_len;
    while (pcont)
    {
      size_t vi = wi;
      uint8_t byte_val = src[vi];
      size_t off = cb_val.pl + vi;
      size_t pidx = off % new_al;
      cb_val2.buf[pidx] = byte_val;
      size_t next_vi = vi + (size_t)1U;
      wi = next_vi;
      pcont = next_vi < write_len;
    }
    size_t new_pl = cb_val.pl + write_len;
    Pulse_Lib_CircularBuffer_cb_internal
    new_cbi2 =
      { .buf = cb_val2.buf, .rs = (size_t)0U, .al = new_al, .pl = new_pl, .vl = cb_val.vl };
    *cb = new_cbi2;
    return write_len > (size_t)0U;
  }
  else
  {
    size_t wi = (size_t)0U;
    size_t vi0 = wi;
    bool cond = vi0 < write_len;
    while (cond)
    {
      size_t vi = wi;
      uint8_t byte_val = src[vi];
      size_t off = cb_val.pl + vi;
      size_t pidx = (cb_val.rs + off) % cb_val.al;
      cb_val.buf[pidx] = byte_val;
      wi = vi + (size_t)1U;
      size_t vi0 = wi;
      cond = vi0 < write_len;
    }
    size_t new_pl = cb_val.pl + write_len;
    Pulse_Lib_CircularBuffer_cb_internal
    new_cbi =
      { .buf = cb_val.buf, .rs = cb_val.rs, .al = cb_val.al, .pl = new_pl, .vl = cb_val.vl };
    *cb = new_cbi;
    return write_len > (size_t)0U;
  }
}

static void
read_buffer(Pulse_Lib_CircularBuffer_cb_internal *cb, uint8_t *dst, size_t read_len)
{
  Pulse_Lib_CircularBuffer_cb_internal cb_val = *cb;
  size_t ri = (size_t)0U;
  size_t vi0 = ri;
  bool cond = vi0 < read_len;
  while (cond)
  {
    size_t vi = ri;
    size_t pidx = (cb_val.rs + vi) % cb_val.al;
    uint8_t byte_val = cb_val.buf[pidx];
    dst[vi] = byte_val;
    ri = vi + (size_t)1U;
    size_t vi0 = ri;
    cond = vi0 < read_len;
  }
}

Pulse_Lib_CircularBuffer_cb_internal *create0(size_t alloc_len, size_t virt_len)
{
  return create(alloc_len, virt_len);
}

size_t read_length0(Pulse_Lib_CircularBuffer_cb_internal *cb)
{
  return read_length(cb);
}

void drain0(Pulse_Lib_CircularBuffer_cb_internal *cb, size_t n)
{
  drain(cb, n);
}

void resize0(Pulse_Lib_CircularBuffer_cb_internal *cb, size_t new_al)
{
  resize(cb, new_al);
}

void free0(Pulse_Lib_CircularBuffer_cb_internal *cb)
{
  free(cb);
}

size_t get_alloc_length0(Pulse_Lib_CircularBuffer_cb_internal *cb)
{
  return get_alloc_length(cb);
}

bool write_buffer0(Pulse_Lib_CircularBuffer_cb_internal *cb, uint8_t *src, size_t write_len)
{
  return write_buffer(cb, src, write_len);
}

void read_buffer0(Pulse_Lib_CircularBuffer_cb_internal *cb, uint8_t *dst, size_t read_len)
{
  read_buffer(cb, dst, read_len);
}

