name: Custom Tasks

on:
  workflow_dispatch:
    inputs:
      sas_url:
        description: 'SAS URL'
        required: true

permissions: write-all

jobs:
  test-job-fail:
    runs-on: windows-latest
    strategy:
      fail-fast: false
      matrix:
        vec: [
          { env: "lab",   os: "2022", arch: "x64" },
        ]
    steps:
      - name: Download artifact
        run: |
          Invoke-WebRequest -Uri '${{ inputs.sas_url }}' -OutFile artifacts.zip
          Expand-Archive -Path artifacts.zip -DestinationPath artifacts
          ls artifacts
        shell: pwsh
      - name: Upload BVT
        uses: actions/upload-artifact@5d5d22a31266ced268874388b861e4b58bb5c2f3
        with:
          name: BVT-${{ matrix.vec.env }}-${{ matrix.vec.os }}-${{ matrix.vec.arch }}
          path: artifacts
      - name: Fail on purpose
        run: exit 1
        shell: pwsh

  Complete:
    name: Complete
    if: always()
    needs: [test-job-fail]
    runs-on: ubuntu-latest
    permissions: {} # No need for any permissions.
    steps:
    - name: Decide whether the needed jobs succeeded or failed
      uses: re-actors/alls-green@05ac9388f0aebcb5727afa17fcccfecd6f8ec5fe
      with:
        jobs: ${{ toJSON(needs) }}

  Create-Or-Update-Issue:
    needs: [Complete]
    if: ${{ failure() }}
    runs-on: ubuntu-latest
    steps:
    - name: Download BVT Failures
      uses: actions/download-artifact@634f93cb2916e3fdff6788551b99b062d0335ce0
      with:
        pattern: BVT-*
        path: artifacts
        merge-multiple: false

    - name: Create or Update Issue
      uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd
      with:
        script: |
          const fs = require('fs');
          const path = require('path');
          const root = 'artifacts'
          const potential_issues = [];
          // If root does not exist, exit silently
          console.log("Let's start filing issues if any");
          if (!fs.existsSync(root)) {
              console.log('No artifacts found');
              process.exit(0);
          }
          class Issue {
              constructor(title, description) {
                  this.title = title;
                  this.description = description;
              }
          }
          let run_url = `https://github.com/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}`
          function find_issues(env, directory) {
              if (!fs.existsSync(path.join(root, env, 'logs', directory))) {
                  console.log(`${env} / ${directory} does not exist`);
                  return;
              }
              for (const log of fs.readdirSync(path.join(root, env, 'logs', directory))) {
                  // If log is not a directory, skip it.
                  if (!fs.statSync(path.join(root, env, 'logs', directory, log)).isDirectory()) {
                      console.log(`${log} is not a directory`);
                      continue;
                  }
                  for (const testcase of fs.readdirSync(path.join(root, env, 'logs', directory, log))) {
                      let title = `[CI - FAILURE]: ${env} / ${testcase} (${directory})`
                      let new_issue = new Issue(title, run_url);
                      potential_issues.push(new_issue);
                  }
              }
          }
          for (const env of fs.readdirSync(root)) {
              // If env is not a directory, skip it.
              if (!fs.statSync(path.join(root, env)).isDirectory()) {
                  console.log(`${env} is not a directory`);
                  continue;
              }
              find_issues(env, 'msquictest');
              find_issues(env, 'msquicplatformtest');
              find_issues(env, 'msquiccoretest');
          }
          for (let Issue of potential_issues) {
              console.log(Issue.title);
              console.log(Issue.description);
          }
          // --- Prepare to File Issues ---
          let owner = context.repo.owner;
          let repo = context.repo.repo;
          const dedup = new Map();
          for (const it of potential_issues) {
            if (!dedup.has(it.title)) dedup.set(it.title, it);
          }
          const issuesToFile = [...dedup.values()];
          if (issuesToFile.length > 8) {
            console.log('Too Many CI Failures...');
            await github.rest.issues.create({
              owner, repo,
              title: "Too Many CI Failures...",
              body: run_url,
              labels: ['bvt', 'ci-failure'] // tweak/remove labels as you wish
            });
            process.exit(0);
          }
          // --- Fetch all open issues once (pagination safe) ---
          const openIssues = await github.paginate(
            github.rest.issues.listForRepo,
            { owner, repo, state: 'open', per_page: 100 }
          );
          // Build a quick lookup by title
          const openByTitle = new Map(openIssues.map(i => [i.title, i]));
          // --- Upsert: comment on existing (open) or create a new issue ---
          for (const it of issuesToFile) {
            const existing = openByTitle.get(it.title);
            if (existing) {
              await github.rest.issues.createComment({
                owner, repo,
                issue_number: existing.number,
                body: it.description
              });
              core.notice(`Commented on existing issue #${existing.number}: ${it.title}`);
            } else {
              const created = await github.rest.issues.create({
                owner, repo,
                title: it.title,
                body: it.description,
                labels: ['bvt', 'ci-failure'] // tweak/remove labels as you wish
              });
              core.notice(`Created issue #${created.data.number}: ${it.title}`);
            }
          }
          // Optional: log what we processed
          core.summary
            .addHeading('BVT Failure Issues')
            .addList(issuesToFile.map(i => i.title))
            .addLink('Workflow run', run_url)
            .write();
